<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Matrix Algebra<br/>
<small>
[<a class="el" href="group__qvmath.html">Math functionality</a>]</small>
</h1>
<p>Matrix algebra related functions (see also source programs in directory examples/matrixalgebra-tests for an exhaustive set of examples of use).  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b">GSL_THIN_DECOMP_MOD</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f">GSL_THIN_DECOMP</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a43eb44439df1e8e6797917e721016774">GSL_THIN_DECOMP_JACOBI</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c">LAPACK_FULL_DGESVD</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e">LAPACK_FULL_DGESDD</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for Singular Value Decomposition (SVD). </p>
 <a href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">TQVSV_Method</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aec23f378cb62ec5c9647fe24d8b4ab37">GSL_ONLY_DECOMP_MOD</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0af7facc299fdba1379bd6ba8acd863125">GSL_ONLY_DECOMP</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aae6dd5f0dbab3b0f4d55ad5fb711b6cd">GSL_ONLY_DECOMP_JACOBI</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0a07c014f720d296deab282e63cf84897d">LAPACK_ONLY_DGESVD</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aa99ca829614308fcefd46e2d828dff67">LAPACK_ONLY_DGESDD</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for Singular Values only computation (SV). </p>
 <a href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> { <a class="el" href="group__qvmatrixalgebra.html#ggac52aa1a4772c42c68e53baf5a22e15c8ad805bb0106a0bbf7eea0549f4a5525d1">GSL_CHOLESKY</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggac52aa1a4772c42c68e53baf5a22e15c8a80e13036cfa7096deb292e1b197459bf">LAPACK_CHOLESKY_DPOTRF</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for Cholesky Decomposition. </p>
 <a href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> { <a class="el" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a17474e8b41843fa89de4b33a88cf3ed4">GSL_HOUSEHOLDER_THIN_QR</a>, 
<a class="el" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532">GSL_HOUSEHOLDER_FULL_QR</a>, 
<a class="el" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8">LAPACK_THIN_DGEQR2</a>, 
<a class="el" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for QR Decomposition. </p>
 <a href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> { <a class="el" href="group__qvmatrixalgebra.html#gga3b29cddbb2d5f75b1278f8a6d4abd736ac377c182c3ec3cc88190908e82e05aef">GSL_LU</a>, 
<a class="el" href="group__qvmatrixalgebra.html#gga3b29cddbb2d5f75b1278f8a6d4abd736a6ced16c7e295a05f04ae431e76530e43">LAPACK_DGETRF</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for LU Decomposition. </p>
 <a href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">TQVEigenDecomposition_Method</a> { <a class="el" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a26b778a18b5ed84f1c9dea5d8419981e">GSL_EIGENSYMM</a>, 
<a class="el" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a7f4f96ab3bd135f5842b0d25bb5d86a1">LAPACK_DSYEV</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for EigenDecomposition. </p>
 <a href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">TQVEigenValues_Method</a> { <a class="el" href="group__qvmatrixalgebra.html#gga4d0b532a36bb590714b98f651a87f9d2a6deda0800fef3c39404fa629cc5d00b9">GSL_EIGENSYMM_ONLY</a>, 
<a class="el" href="group__qvmatrixalgebra.html#gga4d0b532a36bb590714b98f651a87f9d2a135e946a582e39b85260fa48d418ed9e">LAPACK_DSYEV_ONLY</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for EigenValues only computation. </p>
 <a href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd">QVMKL_DSS</a> =  0, 
<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a4e5ab535616a47622854edcf1d96684f">QVMKL_ISS</a> =  1, 
<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a46209f9833cca62b5a9227d173c6d9a5">QVCHOLMOD_DSS</a> =  2, 
<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1cfab50cd282632e71c4a7fe885705b1">QV_SCG</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a5c07aa6579256ac88d6949c8238c08f4">QV_BJPCG</a> =  4, 
<a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a15407dbc0a00f2cf16f73f5b4ec74b67">QV_DENSE</a> =  5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Available methods for sparse linear system solving. </p>
 <a href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb">singularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, <a class="el" href="classQVVector.html">QVVector</a> &amp;s, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Value Decomposition (SVD)</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix M.  <a href="#gabe654b66e21aa3d27131c5f65fcc9dfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351">solveFromSingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="classQVVector.html">QVVector</a> &amp;s, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#gae7291c840628d8c7f67f90096f470351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gad74c5a3f06b0c9c72148b44e31264c1c">solveFromSingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="classQVVector.html">QVVector</a> &amp;s, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#gad74c5a3f06b0c9c72148b44e31264c1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">solveBySingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#ga8ee6615a4f3e6751e0eedf6128267af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada">solveBySingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#gac5e38c9a7f64b9c7785f4d353c0b9ada"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga5209fc0ff91662f73a505f094689dfa6">solveBySingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, <a class="el" href="classQVVector.html">QVVector</a> &amp;s, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#ga5209fc0ff91662f73a505f094689dfa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea">solveBySingularValueDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, <a class="el" href="classQVVector.html">QVVector</a> &amp;s, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>.  <a href="#gaeb13fad2bc51086f94ac91464d29a0ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga78792d4a8a6337b8b92a86a07ede57ac">singularValueDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="classQVVector.html">QVVector</a> &amp;s, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;V)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the SVD of a matrix.  <a href="#ga78792d4a8a6337b8b92a86a07ede57ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga5d6aa6239753252830669883619f5da7">singularValues</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;s, const <a class="el" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">TQVSV_Method</a> method=DEFAULT_TQVSV_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the singular values of a matrix.  <a href="#ga5d6aa6239753252830669883619f5da7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga7e4b10036a1a456b58ffcb0ad0e30d52">singularValuesResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVVector.html">QVVector</a> &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the singular values of a matrix.  <a href="#ga7e4b10036a1a456b58ffcb0ad0e30d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932">CholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> method=DEFAULT_TQVCHOLESKY_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> of a symmetric and positive definite matrix.  <a href="#gab845aa50ce874199ad7676904829b932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76">solveFromCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#gafc11c4eb4acc7453b7bed072d6bf0a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaed3915fd119f48853adcb72010e6cd09">solveFromCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#gaed3915fd119f48853adcb72010e6cd09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de">solveByCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> method=DEFAULT_TQVCHOLESKY_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#ga7afb7ef53aed190e810886e4941bc3de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga067556526a2c186f723d887a30658402">solveByCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> method=DEFAULT_TQVCHOLESKY_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#ga067556526a2c186f723d887a30658402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga0092ee2d02048fb7eb478af02bc6b9ff">solveByCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> method=DEFAULT_TQVCHOLESKY_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#ga0092ee2d02048fb7eb478af02bc6b9ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5">solveByCholeskyDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a> method=DEFAULT_TQVCHOLESKY_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>.  <a href="#ga806c89d90cce22d877df1f18fa9689f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gab24bc732bdada660cceccecd98a4a5f2">CholeskyDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the Cholesky decomposition of a matrix.  <a href="#gab24bc732bdada660cceccecd98a4a5f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf">LUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/LU_decomposition">LU decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix.  <a href="#gae5f89f5ce3f124ded687ebdcb4d621bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076">solveFromLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained LU decomposition of M:  <a href="#gaa964f05ab494b8a34381d6fa81ce2076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gad8bfbb08c8abc180fc75d1c95cd384b2">solveFromLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>.  <a href="#gad8bfbb08c8abc180fc75d1c95cd384b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c">solveByLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>.  <a href="#ga1e0e534e13e16518cc1c1aa750357a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gab8d289ba74af9334d85562f62f51ebf9">solveByLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>.  <a href="#gab8d289ba74af9334d85562f62f51ebf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga8f32485d24aa4e57caeb3d441c74413c">solveByLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>.  <a href="#ga8f32485d24aa4e57caeb3d441c74413c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea">solveByLUDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>.  <a href="#ga4b46c4e87f6ed2d6864770250d4975ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga88586226df85602c9e139b6d4ee1fbcb">LUDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;P, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;U)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the LU decomposition of a matrix.  <a href="#ga88586226df85602c9e139b6d4ee1fbcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0">QRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix.  <a href="#gadabb7917a1bf7e229a4c7a9b8037b5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga00e06784b460e9b3c4a1377b50b2ccb5">QRDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the QR decomposition of a matrix.  <a href="#ga00e06784b460e9b3c4a1377b50b2ccb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b">QLDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">QL decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix.  <a href="#ga2a46051b1a07328de88e5e73710b7f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga42e745f3d76515e05ab8c16c24e0056a">QLDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the QL decomposition of a matrix.  <a href="#ga42e745f3d76515e05ab8c16c24e0056a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718">RQDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">RQ decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix.  <a href="#gaa825c3d75d892d43c6f20fa3ae909718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaa37783c86d91abd724a2eab2cd609ddd">RQDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the RQ decomposition of a matrix.  <a href="#gaa37783c86d91abd724a2eab2cd609ddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392">LQDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">LQ decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix.  <a href="#gaac2e3437531d9acfec99b6b7ee300392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gabcf3725f2738f4fb4e823d5a7175ecb9">LQDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;L, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the LQ decomposition of a matrix.  <a href="#gabcf3725f2738f4fb4e823d5a7175ecb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c">solveFromQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained QR decomposition of M:  <a href="#ga4c9f02ada4121317c084f1c7ec09e17c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga228fdd20d46605f6177054634126320c">solveFromQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained QR decomposition of M:  <a href="#ga228fdd20d46605f6177054634126320c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">solveByQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the QR decomposition of M:  <a href="#ga0a31c23838ccb1a35229cda96266c640"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3">solveByQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the QR decomposition of M:  <a href="#ga35e4e3e2dd0a5ebbd93f672bf569e4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga7ec9b2e2693b1e700892e6a4aa6398c3">solveByQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the QR decomposition of M:  <a href="#ga7ec9b2e2693b1e700892e6a4aa6398c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3">solveByQRDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;R, const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a> method=DEFAULT_TQVQR_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the QR decomposition of M:  <a href="#gade60b82ebf24951f074f43c211fd67a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gae95e6a42f2cce467f30a55289a0f9824">eigenDecomposition</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;lambda, <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q, const <a class="el" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">TQVEigenDecomposition_Method</a> method=DEFAULT_TQVEIGENDECOMPOSITION_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigen-decomposition</a> of a symmetric matrix.  <a href="#gae95e6a42f2cce467f30a55289a0f9824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga5ccc97075c8c8d5340dd6b8b2ace3190">eigenDecompositionResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVVector.html">QVVector</a> &amp;lambda, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;Q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the eigendecomposition of a matrix.  <a href="#ga5ccc97075c8c8d5340dd6b8b2ace3190"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gabbfe32bf1d0c4def6ecb805bca65d03c">eigenValues</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;lambda, const <a class="el" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">TQVEigenValues_Method</a> method=DEFAULT_TQVEIGENVALUES_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the eigenvalues of a matrix.  <a href="#gabbfe32bf1d0c4def6ecb805bca65d03c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga124008527c22895b3dc8b828eb867306">eigenValuesResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVVector.html">QVVector</a> &amp;lambda)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for correctness of the eigenvalues of a symmetric matrix.  <a href="#ga124008527c22895b3dc8b828eb867306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVMatrix.html">QVMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gadf6472ec782375d465ff1e87b3ae2557">pseudoInverse</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD, const double epsilon=1.0E-10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse">Moore–Penrose pseudoinverse</a> of a matrix.  <a href="#gadf6472ec782375d465ff1e87b3ae2557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga18cb128a894fa599a42b85e403049416">determinant</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a> method=DEFAULT_TQVLU_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the <a href="http://en.wikipedia.org/wiki/Determinant">determinant</a> of a square matrix.  <a href="#ga18cb128a894fa599a42b85e403049416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4">solveHomogeneous</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;A, QVector&lt; double &gt; &amp;x, const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a> method=DEFAULT_TQVSVD_METHOD)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves an <a href="http://en.wikipedia.org/wiki/System_of_linear_equations#Homogeneous_systems">homogeneous linear system of equations</a>.  <a href="#gabcefb2cb61ed46e61130f4892308fee4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572">solveResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;X, const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the residual of the solution to a linear matrix equation.  <a href="#ga70717e261a395b8c380c4321dbb12572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaf2e939fc01193d7854e855684b87d7ed">solveResidual</a> (const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;M, const <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the residual of the solution to a linear vector equation.  <a href="#gaf2e939fc01193d7854e855684b87d7ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158">sparseSolve</a> (const <a class="el" href="classQVSparseBlockMatrix.html">QVSparseBlockMatrix</a> &amp;M, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const <a class="el" href="classQVVector.html">QVVector</a> &amp;b, const bool isSymmetric=false, const bool isPosDefinite=false, const <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a> method=DEFAULT_TQVSPARSESOLVE_METHOD, const bool start_from_x=false, const bool iters_or_resid=true, const int iters=0, const double resid=1.0E-10, int &amp;final_iter_count=dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves a <a href="http://en.wikipedia.org/wiki/Sparse_matrix">sparse system</a> of linear equations, taking advantage of sparseness to accelerate the computation.  <a href="#gaf7293f186086b4b233cf51046f016158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvmatrixalgebra.html#gada28dcc8be2cf1b93f3b1f201cafdb88">solveHomogeneous</a> (const <a class="el" href="classQVSparseBlockMatrix.html">QVSparseBlockMatrix</a> &amp;A, <a class="el" href="classQVVector.html">QVVector</a> &amp;x, const int maxIterations=10, const double minRelativeError=0.0, const <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a> method=QVMKL_DSS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves a sparse homogeneous linear system using the <a href="http://en.wikipedia.org/wiki/Inverse_iteration">inverse iteration</a> algorithm and the MKL sparse routines.  <a href="#gada28dcc8be2cf1b93f3b1f201cafdb88"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Matrix algebra related functions (see also source programs in directory examples/matrixalgebra-tests for an exhaustive set of examples of use). </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad753ba41cd08df7e8d4173d8c2ac2575"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVSVD_Method" ref="gad753ba41cd08df7e8d4173d8c2ac2575" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for Singular Value Decomposition (SVD). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b"></a><!-- doxytag: member="GSL_THIN_DECOMP_MOD" ref="ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b" args="" -->GSL_THIN_DECOMP_MOD</em>&nbsp;</td><td>
<p>GSL Golub-Reinsch modified algorithm (thin); faster for M &gt;&gt; N. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f"></a><!-- doxytag: member="GSL_THIN_DECOMP" ref="ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f" args="" -->GSL_THIN_DECOMP</em>&nbsp;</td><td>
<p>GSL Golub-Reinsch default algorithm (thin) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575a43eb44439df1e8e6797917e721016774"></a><!-- doxytag: member="GSL_THIN_DECOMP_JACOBI" ref="ggad753ba41cd08df7e8d4173d8c2ac2575a43eb44439df1e8e6797917e721016774" args="" -->GSL_THIN_DECOMP_JACOBI</em>&nbsp;</td><td>
<p>GSL one sided Jacobi algorithm (thin); slower, but more accurate. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c"></a><!-- doxytag: member="LAPACK_FULL_DGESVD" ref="ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c" args="" -->LAPACK_FULL_DGESVD</em>&nbsp;</td><td>
<p>Lapack DGESVD method (full); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e"></a><!-- doxytag: member="LAPACK_FULL_DGESDD" ref="ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e" args="" -->LAPACK_FULL_DGESDD</em>&nbsp;</td><td>
<p>Lapack DGESDD divide and conquer method (full); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85"></a><!-- doxytag: member="LAPACK_THIN_DGESVD" ref="ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85" args="" -->LAPACK_THIN_DGESVD</em>&nbsp;</td><td>
<p>Lapack DGESVD method (thin); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372"></a><!-- doxytag: member="LAPACK_THIN_DGESDD" ref="ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372" args="" -->LAPACK_THIN_DGESDD</em>&nbsp;</td><td>
<p>Lapack DGESDD divide and conquer method (thin); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00075">75</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae838fb93502416d5876dd38769e3c5a0"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVSV_Method" ref="gae838fb93502416d5876dd38769e3c5a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">TQVSV_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for Singular Values only computation (SV). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae838fb93502416d5876dd38769e3c5a0aec23f378cb62ec5c9647fe24d8b4ab37"></a><!-- doxytag: member="GSL_ONLY_DECOMP_MOD" ref="ggae838fb93502416d5876dd38769e3c5a0aec23f378cb62ec5c9647fe24d8b4ab37" args="" -->GSL_ONLY_DECOMP_MOD</em>&nbsp;</td><td>
<p>Only returns singular values, but computes complete decomposition using GSL_THIN_DECOMP_MOD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae838fb93502416d5876dd38769e3c5a0af7facc299fdba1379bd6ba8acd863125"></a><!-- doxytag: member="GSL_ONLY_DECOMP" ref="ggae838fb93502416d5876dd38769e3c5a0af7facc299fdba1379bd6ba8acd863125" args="" -->GSL_ONLY_DECOMP</em>&nbsp;</td><td>
<p>Only returns singular values, but computes complete decomposition using GSL_THIN_DECOMP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae838fb93502416d5876dd38769e3c5a0aae6dd5f0dbab3b0f4d55ad5fb711b6cd"></a><!-- doxytag: member="GSL_ONLY_DECOMP_JACOBI" ref="ggae838fb93502416d5876dd38769e3c5a0aae6dd5f0dbab3b0f4d55ad5fb711b6cd" args="" -->GSL_ONLY_DECOMP_JACOBI</em>&nbsp;</td><td>
<p>Only returns singular values, but computes complete decomposition using GSL_THIN_DECOMP_JACOBI. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae838fb93502416d5876dd38769e3c5a0a07c014f720d296deab282e63cf84897d"></a><!-- doxytag: member="LAPACK_ONLY_DGESVD" ref="ggae838fb93502416d5876dd38769e3c5a0a07c014f720d296deab282e63cf84897d" args="" -->LAPACK_ONLY_DGESVD</em>&nbsp;</td><td>
<p>Lapack DGESVD divide and conquer method (only compute singular values, more efficient than complete decomposition); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae838fb93502416d5876dd38769e3c5a0aa99ca829614308fcefd46e2d828dff67"></a><!-- doxytag: member="LAPACK_ONLY_DGESDD" ref="ggae838fb93502416d5876dd38769e3c5a0aa99ca829614308fcefd46e2d828dff67" args="" -->LAPACK_ONLY_DGESDD</em>&nbsp;</td><td>
<p>Lapack DGESDD method (only compute singular values, more efficient than complete decomposition); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00087">87</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac52aa1a4772c42c68e53baf5a22e15c8"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVCholesky_Method" ref="gac52aa1a4772c42c68e53baf5a22e15c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for Cholesky Decomposition. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac52aa1a4772c42c68e53baf5a22e15c8ad805bb0106a0bbf7eea0549f4a5525d1"></a><!-- doxytag: member="GSL_CHOLESKY" ref="ggac52aa1a4772c42c68e53baf5a22e15c8ad805bb0106a0bbf7eea0549f4a5525d1" args="" -->GSL_CHOLESKY</em>&nbsp;</td><td>
<p>GSL Cholesky method; </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac52aa1a4772c42c68e53baf5a22e15c8a80e13036cfa7096deb292e1b197459bf"></a><!-- doxytag: member="LAPACK_CHOLESKY_DPOTRF" ref="ggac52aa1a4772c42c68e53baf5a22e15c8a80e13036cfa7096deb292e1b197459bf" args="" -->LAPACK_CHOLESKY_DPOTRF</em>&nbsp;</td><td>
<p>Lapack DPOTRF method ; </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00097">97</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga34489f7f981fd3ad10dcd6e287644c21"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVQR_Method" ref="ga34489f7f981fd3ad10dcd6e287644c21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for QR Decomposition. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga34489f7f981fd3ad10dcd6e287644c21a17474e8b41843fa89de4b33a88cf3ed4"></a><!-- doxytag: member="GSL_HOUSEHOLDER_THIN_QR" ref="gga34489f7f981fd3ad10dcd6e287644c21a17474e8b41843fa89de4b33a88cf3ed4" args="" -->GSL_HOUSEHOLDER_THIN_QR</em>&nbsp;</td><td>
<p>GSL Householder QR method (thin); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532"></a><!-- doxytag: member="GSL_HOUSEHOLDER_FULL_QR" ref="gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532" args="" -->GSL_HOUSEHOLDER_FULL_QR</em>&nbsp;</td><td>
<p>GSL Householder QR method (full); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8"></a><!-- doxytag: member="LAPACK_THIN_DGEQR2" ref="gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8" args="" -->LAPACK_THIN_DGEQR2</em>&nbsp;</td><td>
<p>Lapack DGEQR2 (unblocked QR) method (thin); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919"></a><!-- doxytag: member="LAPACK_FULL_DGEQR2" ref="gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919" args="" -->LAPACK_FULL_DGEQR2</em>&nbsp;</td><td>
<p>Lapack DGEQR2 (unblocked QR) method (full); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00104">104</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b29cddbb2d5f75b1278f8a6d4abd736"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVLU_Method" ref="ga3b29cddbb2d5f75b1278f8a6d4abd736" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for LU Decomposition. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga3b29cddbb2d5f75b1278f8a6d4abd736ac377c182c3ec3cc88190908e82e05aef"></a><!-- doxytag: member="GSL_LU" ref="gga3b29cddbb2d5f75b1278f8a6d4abd736ac377c182c3ec3cc88190908e82e05aef" args="" -->GSL_LU</em>&nbsp;</td><td>
<p>GSL (Gauss elimination with partial pivoting method); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3b29cddbb2d5f75b1278f8a6d4abd736a6ced16c7e295a05f04ae431e76530e43"></a><!-- doxytag: member="LAPACK_DGETRF" ref="gga3b29cddbb2d5f75b1278f8a6d4abd736a6ced16c7e295a05f04ae431e76530e43" args="" -->LAPACK_DGETRF</em>&nbsp;</td><td>
<p>Lapack DGETRF (Gauss elimination with partial pivoting); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00113">113</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae21e0895ad3ca32f8fdc58b4bf22bec8"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVEigenDecomposition_Method" ref="gae21e0895ad3ca32f8fdc58b4bf22bec8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">TQVEigenDecomposition_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for EigenDecomposition. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae21e0895ad3ca32f8fdc58b4bf22bec8a26b778a18b5ed84f1c9dea5d8419981e"></a><!-- doxytag: member="GSL_EIGENSYMM" ref="ggae21e0895ad3ca32f8fdc58b4bf22bec8a26b778a18b5ed84f1c9dea5d8419981e" args="" -->GSL_EIGENSYMM</em>&nbsp;</td><td>
<p>GSL eigendecomposition of a real symmetric matrix (eigenvalues and eigenvectors); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae21e0895ad3ca32f8fdc58b4bf22bec8a7f4f96ab3bd135f5842b0d25bb5d86a1"></a><!-- doxytag: member="LAPACK_DSYEV" ref="ggae21e0895ad3ca32f8fdc58b4bf22bec8a7f4f96ab3bd135f5842b0d25bb5d86a1" args="" -->LAPACK_DSYEV</em>&nbsp;</td><td>
<p>Lapack DSYEV eigendecomposition (eigenvalues and eigenvectors); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00120">120</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d0b532a36bb590714b98f651a87f9d2"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVEigenValues_Method" ref="ga4d0b532a36bb590714b98f651a87f9d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">TQVEigenValues_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for EigenValues only computation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4d0b532a36bb590714b98f651a87f9d2a6deda0800fef3c39404fa629cc5d00b9"></a><!-- doxytag: member="GSL_EIGENSYMM_ONLY" ref="gga4d0b532a36bb590714b98f651a87f9d2a6deda0800fef3c39404fa629cc5d00b9" args="" -->GSL_EIGENSYMM_ONLY</em>&nbsp;</td><td>
<p>GSL eigendecomposition of a real symmetric matrix (eigenvalues only); </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4d0b532a36bb590714b98f651a87f9d2a135e946a582e39b85260fa48d418ed9e"></a><!-- doxytag: member="LAPACK_DSYEV_ONLY" ref="gga4d0b532a36bb590714b98f651a87f9d2a135e946a582e39b85260fa48d418ed9e" args="" -->LAPACK_DSYEV_ONLY</em>&nbsp;</td><td>
<p>Lapack DSYEV eigendecomposition (eigenvalues only); </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00127">127</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaacdaea1a26a36293bfb60ca30909ba42"></a><!-- doxytag: member="qvmatrixalgebra.h::TQVSparseSolve_Method" ref="gaacdaea1a26a36293bfb60ca30909ba42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available methods for sparse linear system solving. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd"></a><!-- doxytag: member="QVMKL_DSS" ref="ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd" args="" -->QVMKL_DSS</em>&nbsp;</td><td>
<p>Intel MKL direct sparse solver. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a4e5ab535616a47622854edcf1d96684f"></a><!-- doxytag: member="QVMKL_ISS" ref="ggaacdaea1a26a36293bfb60ca30909ba42a4e5ab535616a47622854edcf1d96684f" args="" -->QVMKL_ISS</em>&nbsp;</td><td>
<p>Intel MKL iterative sparse solver. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a46209f9833cca62b5a9227d173c6d9a5"></a><!-- doxytag: member="QVCHOLMOD_DSS" ref="ggaacdaea1a26a36293bfb60ca30909ba42a46209f9833cca62b5a9227d173c6d9a5" args="" -->QVCHOLMOD_DSS</em>&nbsp;</td><td>
<p>CHOLMOD direct sparse solver. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a1cfab50cd282632e71c4a7fe885705b1"></a><!-- doxytag: member="QV_SCG" ref="ggaacdaea1a26a36293bfb60ca30909ba42a1cfab50cd282632e71c4a7fe885705b1" args="" -->QV_SCG</em>&nbsp;</td><td>
<p>Iterative sparse conjugate gradient. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a5c07aa6579256ac88d6949c8238c08f4"></a><!-- doxytag: member="QV_BJPCG" ref="ggaacdaea1a26a36293bfb60ca30909ba42a5c07aa6579256ac88d6949c8238c08f4" args="" -->QV_BJPCG</em>&nbsp;</td><td>
<p>Block Jacobian preconditioned conjugate gradient. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaacdaea1a26a36293bfb60ca30909ba42a15407dbc0a00f2cf16f73f5b4ec74b67"></a><!-- doxytag: member="QV_DENSE" ref="ggaacdaea1a26a36293bfb60ca30909ba42a15407dbc0a00f2cf16f73f5b4ec74b67" args="" -->QV_DENSE</em>&nbsp;</td><td>
<p>Direct dense method. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html#l00134">134</a> of file <a class="el" href="qvmath_2qvmatrixalgebra_8h_source.html">qvmatrixalgebra.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabe654b66e21aa3d27131c5f65fcc9dfb"></a><!-- doxytag: member="qvmatrixalgebra.h::singularValueDecomposition" ref="gabe654b66e21aa3d27131c5f65fcc9dfb" args="(const QVMatrix &amp;M, QVMatrix &amp;U, QVVector &amp;s, QVMatrix &amp;V, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Value Decomposition (SVD)</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix M. </p>
<p>The SV decomposition obtains two matrices <em>U</em> and <em>V</em> and a vector <em>s</em> from an original matrix <em>M</em> satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/></p>
<p>If the decomposition method is 'full', both U and V are square matrices of sizes <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> and <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>, respectively, while the <img class="formulaInl" alt="$diag(s)$" src="form_77.png"/> matrix is of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, with all values zero, except on values <img class="formulaInl" alt="$s(i)$" src="form_78.png"/> on its main diagonal, which correspond to the singular values in decreasing order.</p>
<p>If the decomposition is 'thin', then U and V are only of sizes <img class="formulaInl" alt="$ m \times \min(m,n) $" src="form_79.png"/> and <img class="formulaInl" alt="$ \min(m,n) \times n $" src="form_80.png"/>, while the <img class="formulaInl" alt="$diag(s)$" src="form_77.png"/> matrix is square of size <img class="formulaInl" alt="$ \min(m,n) \times \min(m,n) $" src="form_81.png"/>, and containing the singular values in decreasing order in the elements of its diagonal.</p>
<p>In any case, both matrices <em>U</em> and <em>V</em> have always orthonormal columns (that is, <img class="formulaInl" alt="$ U^T U = I $" src="form_82.png"/> and <img class="formulaInl" alt="$ V^T V = I $" src="form_83.png"/> ), and if the decomposition method is 'full', are fully orthogonal square matrices.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U from the SVD decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>param to store the s vector of singular values from the SVD decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>param to store the matrix V from the SVD decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gad74c5a3f06b0c9c72148b44e31264c1c" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromSingularValueDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00204">204</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#ga72b520d418b7835458269a7d803c6668">computeProjectiveHomography()</a>, <a class="el" href="group__qvprojectivegeometry.html#ga017edd807b040c198a02733e4b81e1df">getCameraPosesFromEssentialMatrix()</a>, <a class="el" href="group__qvmatrixalgebra.html#gadf6472ec782375d465ff1e87b3ae2557">pseudoInverse()</a>, and <a class="el" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4">solveHomogeneous()</a>.</p>

</div>
</div>
<a class="anchor" id="gae7291c840628d8c7f67f90096f470351"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromSingularValueDecomposition" ref="gae7291c840628d8c7f67f90096f470351" args="(const QVMatrix &amp;U, const QVVector &amp;s, const QVMatrix &amp;V, QVMatrix &amp;X, const QVMatrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromSingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained with the following expression:</p>
<p><img class="formulaInl" alt="$ X = V diag(s)^{-1} U^T B $" src="form_87.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input matrix U from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>input vector of singular values from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>input matrix V from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00224">224</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada">solveBySingularValueDecomposition()</a>, and <a class="el" href="group__qvmatrixalgebra.html#gad74c5a3f06b0c9c72148b44e31264c1c">solveFromSingularValueDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="gad74c5a3f06b0c9c72148b44e31264c1c"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromSingularValueDecomposition" ref="gad74c5a3f06b0c9c72148b44e31264c1c" args="(const QVMatrix &amp;U, const QVVector &amp;s, const QVMatrix &amp;V, QVVector &amp;x, const QVVector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromSingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained with the following expression:</p>
<p><img class="formulaInl" alt="$ x = V diag(s)^{-1} U^T b $" src="form_90.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input matrix U from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>input vector of singular values from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>input matrix V from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition(const QVMatrix &amp;, const QVVector &amp;, const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00241">241</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ee6615a4f3e6751e0eedf6128267af8"></a><!-- doxytag: member="qvmatrixalgebra.h::solveBySingularValueDecomposition" ref="ga8ee6615a4f3e6751e0eedf6128267af8" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveBySingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained by computing the singular value decomposition of <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<p><img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/></p>
<p>And then using the following expression</p>
<p><img class="formulaInl" alt="$ X = V diag(s)^{-1} U^T B $" src="form_87.png"/>.</p>
<p>Being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<ul>
<li>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</li>
<li>For sub-determined systems (<img class="formulaInl" alt="$m<n$" src="form_95.png"/>), the obtained solution has minimum norm amongst all the valid solutions.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the SVD computation (see <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gad74c5a3f06b0c9c72148b44e31264c1c" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromSingularValueDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00260">260</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac5e38c9a7f64b9c7785f4d353c0b9ada"></a><!-- doxytag: member="qvmatrixalgebra.h::solveBySingularValueDecomposition" ref="gac5e38c9a7f64b9c7785f4d353c0b9ada" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveBySingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained by computing the singular value decomposition of <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<p><img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/></p>
<p>And then using the following expression</p>
<p><img class="formulaInl" alt="$ x = V diag(s)^{-1} U^T b $" src="form_90.png"/>.</p>
<p>Being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<ul>
<li>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</li>
<li>For sub-determined systems (<img class="formulaInl" alt="$m<n$" src="form_95.png"/>), the obtained solution has minimum norm amongst all the valid solutions.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8" title="Solves the linear system  for the unknown matrix , using the singular value decomposition...">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a>; </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00250">250</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="classQVMatrix.html#a35e6590cf43e82694aa2b3d8e6559136">QVMatrix::matrixDivide()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5209fc0ff91662f73a505f094689dfa6"></a><!-- doxytag: member="qvmatrixalgebra.h::solveBySingularValueDecomposition" ref="ga5209fc0ff91662f73a505f094689dfa6" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, QVMatrix &amp;U, QVVector &amp;s, QVMatrix &amp;V, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveBySingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained by computing the singular value decomposition of <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<p><img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/></p>
<p>And then using the following expression</p>
<p><img class="formulaInl" alt="$ X = V diag(s)^{-1} U^T B $" src="form_87.png"/>.</p>
<p>The function also returns the matrices <img class="formulaInl" alt="$ U$" src="form_96.png"/> and <img class="formulaInl" alt="$ V$" src="form_97.png"/>, and the vector <img class="formulaInl" alt="$ s$" src="form_98.png"/> resulting from the singular value decomposition.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U resulting from the singular value decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>param to store the vector s resulting from the singular value decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>param to store the matrix V resulting from the singular value decomposition (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8" title="Solves the linear system  for the unknown matrix , using the singular value decomposition...">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00280">280</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb13fad2bc51086f94ac91464d29a0ea"></a><!-- doxytag: member="qvmatrixalgebra.h::solveBySingularValueDecomposition" ref="gaeb13fad2bc51086f94ac91464d29a0ea" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, QVMatrix &amp;U, QVVector &amp;s, QVMatrix &amp;V, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveBySingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the singular value decomposition <img class="formulaInl" alt="$M = U diag(s) V^T$" src="form_86.png"/>. </p>
<p>The solution is obtained by computing the singular value decomposition of <img class="formulaInl" alt="$M$" src="form_91.png"/>:</p>
<p><img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/></p>
<p>And then using the following expression</p>
<p><img class="formulaInl" alt="$ x = V diag(s)^{-1} U^T b $" src="form_90.png"/>.</p>
<p>The function also returns the matrices <img class="formulaInl" alt="$ U$" src="form_96.png"/> and <img class="formulaInl" alt="$ V$" src="form_97.png"/>, and the vector <img class="formulaInl" alt="$ s$" src="form_98.png"/> resulting from the singular value decomposition.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U resulting from the singular value decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>param to store the vector s resulting from the singular value decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>param to store the matrix V resulting from the singular value decomposition (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8" title="Solves the linear system  for the unknown matrix , using the singular value decomposition...">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a>; </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00269">269</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga78792d4a8a6337b8b92a86a07ede57ac"></a><!-- doxytag: member="qvmatrixalgebra.h::singularValueDecompositionResidual" ref="ga78792d4a8a6337b8b92a86a07ede57ac" args="(const QVMatrix &amp;M, const QVMatrix &amp;U, const QVVector &amp;s, const QVMatrix &amp;V)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double singularValueDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the SVD of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||U diag(s) V^T-M)||_{Frobenius} + ||V^T V - I||_{Frobenius} + ||U^T U - I||_{Frobenius}$" src="form_99.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = U diag(s) V^T $" src="form_74.png"/> is a correct SVD of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input U matrix from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>input vector of singular values from the SVD decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>input V matrix from the SVD decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00287">287</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d6aa6239753252830669883619f5da7"></a><!-- doxytag: member="qvmatrixalgebra.h::singularValues" ref="ga5d6aa6239753252830669883619f5da7" args="(const QVMatrix &amp;M, QVVector &amp;s, const TQVSV_Method method=DEFAULT_TQVSV_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void singularValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">TQVSV_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSV_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the singular values of a matrix. </p>
<p>This function computes only the singular values of a matrix (which, depending on the used method, will be much faster than performing a full decomposition).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>vector of singular values from the SVD decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the SV computation (see <a class="el" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0">TQVSV_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00304">304</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e4b10036a1a456b58ffcb0ad0e30d52"></a><!-- doxytag: member="qvmatrixalgebra.h::singularValuesResidual" ref="ga7e4b10036a1a456b58ffcb0ad0e30d52" args="(const QVMatrix &amp;M, const QVVector &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double singularValuesResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the singular values of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||M||^2_{Frobenius} - ||s||^2$" src="form_100.png"/>, which should be close to zero if <img class="formulaInl" alt="$s$" src="form_101.png"/> are the singular values of M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>input vector of singular values from the SVD decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SingularValues </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00321">321</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab845aa50ce874199ad7676904829b932"></a><!-- doxytag: member="qvmatrixalgebra.h::CholeskyDecomposition" ref="gab845aa50ce874199ad7676904829b932" args="(const QVMatrix &amp;M, QVMatrix &amp;L, const TQVCholesky_Method method=DEFAULT_TQVCHOLESKY_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVCHOLESKY_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> of a symmetric and positive definite matrix. </p>
<p>The Cholesky decomposition obtains a lower triangular matrix <em>L</em> with strictly positive diagonal entries from an original matrix <em>M</em>, satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/></p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the resulting matrix L from the Cholesky decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Matrix M must be symmetric. More precisely, the GSL_CHOLESKY method will only use the lower triangular part of M as input, while the LAPACK_CHOLESKY_DPOTRF method will only use the upper triangular part (the rest of the matrix will not be read in any of both cases, because M is supposed to be symmetric).</dd>
<dd>
Matrix M must also be positive definite. Otherwise, problems will arise: the GSL_CHOLESKY will fail and abort the program, while the LAPACK_CHOLESKY_DPOTRF will have an undefined behavior.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gaed3915fd119f48853adcb72010e6cd09" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromCholeskyDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5" title="Solves the linear system  for the unknown vector , using the Cholesky decomposition...">solveByCholeskyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00382">382</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafc11c4eb4acc7453b7bed072d6bf0a76"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromCholeskyDecomposition" ref="gafc11c4eb4acc7453b7bed072d6bf0a76" args="(const QVMatrix &amp;L, QVMatrix &amp;X, const QVMatrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to solve the linear system.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the Cholesky decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932" title="Obtains the Cholesky decomposition of a symmetric and positive definite matrix.">CholeskyDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5" title="Solves the linear system  for the unknown vector , using the Cholesky decomposition...">solveByCholeskyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00387">387</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de">solveByCholeskyDecomposition()</a>, and <a class="el" href="group__qvmatrixalgebra.html#gaed3915fd119f48853adcb72010e6cd09">solveFromCholeskyDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed3915fd119f48853adcb72010e6cd09"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromCholeskyDecomposition" ref="gaed3915fd119f48853adcb72010e6cd09" args="(const QVMatrix &amp;L, QVVector &amp;x, const QVVector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to solve the linear system.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the Cholesky decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00394">394</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7afb7ef53aed190e810886e4941bc3de"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByCholeskyDecomposition" ref="ga7afb7ef53aed190e810886e4941bc3de" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, const TQVCholesky_Method method=DEFAULT_TQVCHOLESKY_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVCHOLESKY_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to obtain the unknown matrix X.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the SVD computation (see <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932" title="Obtains the Cholesky decomposition of a symmetric and positive definite matrix.">CholeskyDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaed3915fd119f48853adcb72010e6cd09" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromCholeskyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00403">403</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#gabe1f2349f630e5584249273044cce486">optimizeReprojectionErrorFor3DPoint()</a>, <a class="el" href="group__qvprojectivegeometry.html#ga3f3a84e1786f64ea1e8ba2975759f406">optimizeReprojectionErrorForCameraPose()</a>, <a class="el" href="group__qvprojectivegeometry.html#ga6a50717778dcec283e6294ba95e41078">optimizeReprojectionErrorForCameraPoseCauchy()</a>, and <a class="el" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158">sparseSolve()</a>.</p>

</div>
</div>
<a class="anchor" id="ga067556526a2c186f723d887a30658402"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByCholeskyDecomposition" ref="ga067556526a2c186f723d887a30658402" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, const TQVCholesky_Method method=DEFAULT_TQVCHOLESKY_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVCHOLESKY_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to obtain the unknown vector x.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVCholesky_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00412">412</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0092ee2d02048fb7eb478af02bc6b9ff"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByCholeskyDecomposition" ref="ga0092ee2d02048fb7eb478af02bc6b9ff" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, QVMatrix &amp;L, const TQVCholesky_Method method=DEFAULT_TQVCHOLESKY_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVCHOLESKY_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to obtain the unknown matrix X.</p>
<p>The matrix <img class="formulaInl" alt="$ L$" src="form_106.png"/> resulting from the Cholesky decomposition is also returned.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the Cholesky decomposition (overwritten on output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVCholesky_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00422">422</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga806c89d90cce22d877df1f18fa9689f5"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByCholeskyDecomposition" ref="ga806c89d90cce22d877df1f18fa9689f5" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, QVMatrix &amp;L, const TQVCholesky_Method method=DEFAULT_TQVCHOLESKY_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByCholeskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8">TQVCholesky_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVCHOLESKY_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the Cholesky decomposition <img class="formulaInl" alt="$ M = L L^{T} $" src="form_102.png"/>. </p>
<p>The matrix <img class="formulaInl" alt="$ M $" src="form_103.png"/> must be a symmetric positive definite matrix. The two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$L^T$" src="form_105.png"/> are solved by back-substitution to obtain the unknown matrix X.</p>
<p>The matrix <img class="formulaInl" alt="$ L$" src="form_106.png"/> resulting from the Cholesky decomposition is also returned.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the Cholesky decomposition (overwritten on output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVCholesky_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00430">430</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab24bc732bdada660cceccecd98a4a5f2"></a><!-- doxytag: member="qvmatrixalgebra.h::CholeskyDecompositionResidual" ref="gab24bc732bdada660cceccecd98a4a5f2" args="(const QVMatrix &amp;M, const QVMatrix &amp;L)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CholeskyDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the Cholesky decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||L L^T-M)||_{Frobenius}$" src="form_107.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = L L^T $" src="form_108.png"/> is a correct Cholesky decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the Cholesky decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932" title="Obtains the Cholesky decomposition of a symmetric and positive definite matrix.">CholeskyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00441">441</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae5f89f5ce3f124ded687ebdcb4d621bf"></a><!-- doxytag: member="qvmatrixalgebra.h::LUDecomposition" ref="gae5f89f5ce3f124ded687ebdcb4d621bf" args="(const QVMatrix &amp;M, QVMatrix &amp;P, QVMatrix &amp;L, QVMatrix &amp;U, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/LU_decomposition">LU decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix. </p>
<p>The LU decomposition obtains three matrices: <em>P</em> <em>L</em>, and <em>U</em> from an original matrix <em>M</em>, satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/></p>
<p>Being the original matrix M of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, result matrices <em>L</em> and <em>U</em> are lower and upper triangular matrices of sizes <img class="formulaInl" alt="$ m \times min(m,n) $" src="form_110.png"/> and <img class="formulaInl" alt="$ min(m,n) \times n $" src="form_111.png"/> respectively, while <em>P</em> is a square <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> permutation matrix (in which each row and column have one and only one value equal to one, the rest of values being zeros).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>param to store the matrix P resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The GSL_LU method only accepts a square matrix (<img class="formulaInl" alt="$ m = n$" src="form_112.png"/>) as input, otherwise it will fail and abort the program showing an adequate message. The LAPACK_DGETRF is more general, and accepts general rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrices.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gad8bfbb08c8abc180fc75d1c95cd384b2" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromLUDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea" title="Solves the linear system  for the unknown vector , using the LU decomposition .">solveByLUDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00552">552</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvmatrixalgebra.html#ga18cb128a894fa599a42b85e403049416">determinant()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa964f05ab494b8a34381d6fa81ce2076"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromLUDecomposition" ref="gaa964f05ab494b8a34381d6fa81ce2076" args="(const QVMatrix &amp;P, const QVMatrix &amp;L, const QVMatrix &amp;U, QVMatrix &amp;X, const QVMatrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained LU decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/></p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf" title="Obtains the LU decomposition of a rectangular  matrix.">LUDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea" title="Solves the linear system  for the unknown vector , using the LU decomposition .">solveByLUDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00557">557</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c">solveByLUDecomposition()</a>, and <a class="el" href="group__qvmatrixalgebra.html#gad8bfbb08c8abc180fc75d1c95cd384b2">solveFromLUDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8bfbb08c8abc180fc75d1c95cd384b2"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromLUDecomposition" ref="gad8bfbb08c8abc180fc75d1c95cd384b2" args="(const QVMatrix &amp;P, const QVMatrix &amp;L, const QVMatrix &amp;U, QVVector &amp;x, const QVVector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>. </p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition(const QVMatrix &amp;, const QVMatrix &amp;, const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00578">578</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e0e534e13e16518cc1c1aa750357a3c"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByLUDecomposition" ref="ga1e0e534e13e16518cc1c1aa750357a3c" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>. </p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the LU decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The GSL_LU method only accepts a square system (<img class="formulaInl" alt="$ m = n$" src="form_112.png"/>) as input, otherwise it will fail and abort the program showing an adequate message. The LAPACK_DGETRF is more general, and accepts general rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> system, if m&lt;n (sub-determined). In this case, the solution vector obtained has n-m zeros in the last n-m positions. LU decomposition is not adequate in any case for solving overdetermined systems of equations (m&gt;n). Use <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a> or <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> instead for solving this type of systems in the minimum squares sense. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf" title="Obtains the LU decomposition of a rectangular  matrix.">LUDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gad8bfbb08c8abc180fc75d1c95cd384b2" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromLUDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00587">587</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab8d289ba74af9334d85562f62f51ebf9"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByLUDecomposition" ref="gab8d289ba74af9334d85562f62f51ebf9" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>. </p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the LU decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The GSL_LU method only accepts a square system (<img class="formulaInl" alt="$ m = n$" src="form_112.png"/>) as input, otherwise it will fail and abort the program showing an adequate message. The LAPACK_DGETRF is more general, and accepts general rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> system, if m&lt;n (sub-determined). In this case, the solution vector obtained has n-m zeros in the last n-m positions. LU decomposition is not adequate in any case for solving overdetermined systems of equations (m&gt;n). Use <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a> or <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> instead for solving this type of systems in the minimum squares sense. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVLU_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00595">595</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f32485d24aa4e57caeb3d441c74413c"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByLUDecomposition" ref="ga8f32485d24aa4e57caeb3d441c74413c" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, QVMatrix &amp;P, QVMatrix &amp;L, QVMatrix &amp;U, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>. </p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<p>The function also returns the matrices <img class="formulaInl" alt="$ P$" src="form_115.png"/>, <img class="formulaInl" alt="$ L$" src="form_106.png"/>, and <img class="formulaInl" alt="$ U$" src="form_96.png"/> resulting from the LU decomposition.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>param to store the matrix P resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the LU decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The GSL_LU method only accepts a square system (<img class="formulaInl" alt="$ m = n$" src="form_112.png"/>) as input, otherwise it will fail and abort the program showing an adequate message. The LAPACK_DGETRF is more general, and accepts general rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> system, if m&lt;n (sub-determined). In this case, the solution vector obtained has n-m zeros in the last n-m positions. LU decomposition is not adequate in any case for solving overdetermined systems of equations (m&gt;n). Use <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a> or <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> instead for solving this type of systems in the minimum squares sense. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVLU_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00605">605</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b46c4e87f6ed2d6864770250d4975ea"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByLUDecomposition" ref="ga4b46c4e87f6ed2d6864770250d4975ea" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, QVMatrix &amp;P, QVMatrix &amp;L, QVMatrix &amp;U, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByLUDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the LU decomposition <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/>. </p>
<p>The solution for the linear system is obtained by solving the two resultant triangular systems on <img class="formulaInl" alt="$L$" src="form_104.png"/> and <img class="formulaInl" alt="$U$" src="form_113.png"/> by back-substitution, while permuting the elements according to <img class="formulaInl" alt="$ P $" src="form_114.png"/>.</p>
<p>The function also returns the matrices <img class="formulaInl" alt="$ P$" src="form_115.png"/>, <img class="formulaInl" alt="$ L$" src="form_106.png"/>, and <img class="formulaInl" alt="$ U$" src="form_96.png"/> resulting from the LU decomposition.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>param to store the matrix P resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the LU decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>param to store the matrix U resulting from the LU decomposition (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The GSL_LU method only accepts a square system (<img class="formulaInl" alt="$ m = n$" src="form_112.png"/>) as input, otherwise it will fail and abort the program showing an adequate message. The LAPACK_DGETRF is more general, and accepts general rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> system, if m&lt;n (sub-determined). In this case, the solution vector obtained has n-m zeros in the last n-m positions. LU decomposition is not adequate in any case for solving overdetermined systems of equations (m&gt;n). Use <a class="el" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">solveBySingularValueDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, TQVSVD_Method)</a> or <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> instead for solving this type of systems in the minimum squares sense. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVLU_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00613">613</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga88586226df85602c9e139b6d4ee1fbcb"></a><!-- doxytag: member="qvmatrixalgebra.h::LUDecompositionResidual" ref="ga88586226df85602c9e139b6d4ee1fbcb" args="(const QVMatrix &amp;M, const QVMatrix &amp;P, const QVMatrix &amp;L, const QVMatrix &amp;U)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LUDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the LU decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||P L U - M)||_{Frobenius}$" src="form_116.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = P L U $" src="form_109.png"/> is a correct LU decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the LU decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>input matrix from the LU decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf" title="Obtains the LU decomposition of a rectangular  matrix.">LUDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00624">624</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadabb7917a1bf7e229a4c7a9b8037b5f0"></a><!-- doxytag: member="qvmatrixalgebra.h::QRDecomposition" ref="gadabb7917a1bf7e229a4c7a9b8037b5f0" args="(const QVMatrix &amp;M, QVMatrix &amp;Q, QVMatrix &amp;R, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix. </p>
<p>The QR decomposition obtains two matrices <em>Q</em> and <em>R</em> from an original matrix <em>M</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> that satisfy the following equation:</p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>For a square matrix M (m=n), Q is orthogonal and R is upper triangular, both square of size <img class="formulaInl" alt="$ m \times m$" src="form_118.png"/> = <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>For full decomposition methods, or if m&lt;n, matrix <em>Q</em> is orthogonal of size <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> and <em>R</em> is an upper triangular matrix of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>.</p>
<p>For thin decomposition methods, and if m&gt;n, matrix <em>Q</em> has size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, with orthogonal columns, and <em>R</em> is an upper triangular matrix of size <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the resulting matrix Q from the QR decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>param to store the resulting matrix R from the QR decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b" title="Obtains the QL decomposition of a rectangular  matrix.">QLDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392" title="Obtains the LQ decomposition of a rectangular  matrix.">LQDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718" title="Obtains the RQ decomposition of a rectangular  matrix.">RQDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga228fdd20d46605f6177054634126320c" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromQRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00761">761</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga00e06784b460e9b3c4a1377b50b2ccb5"></a><!-- doxytag: member="qvmatrixalgebra.h::QRDecompositionResidual" ref="ga00e06784b460e9b3c4a1377b50b2ccb5" args="(const QVMatrix &amp;M, const QVMatrix &amp;Q, const QVMatrix &amp;R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double QRDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the QR decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||Q R - M)||_{Frobenius} + ||Q^T Q - I)||_{Frobenius}$" src="form_119.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/> is a correct QR decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix from the QR decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>input matrix from the QR decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00766">766</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a46051b1a07328de88e5e73710b7f0b"></a><!-- doxytag: member="qvmatrixalgebra.h::QLDecomposition" ref="ga2a46051b1a07328de88e5e73710b7f0b" args="(const QVMatrix &amp;M, QVMatrix &amp;Q, QVMatrix &amp;L, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QLDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">QL decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix. </p>
<p>The QL decomposition obtains two matrices <em>Q</em> and <em>L</em> from an original matrix <em>M</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> that satisfy the following equation:</p>
<p><img class="formulaInl" alt="$ M = Q L $" src="form_120.png"/></p>
<p>For a square matrix M (m=n), Q is orthogonal and L is lower triangular,both square of size <img class="formulaInl" alt="$ m \times m$" src="form_118.png"/> = <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>If m&gt;n, then thin decomposition methods obtain a <em>Q</em> matrix of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, with orthogonal columns, and a matrix <em>L</em> which is a lower triangular matrix of size <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>, while full decomposition methods obtain a matrix <em>Q</em> orthogonal of size <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> and a matrix <em>L</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> whose first m-n rows are zero, and whose last n rows form a lower triangular matrix.</p>
<p>If m&lt;n, then both full and thin decomposition methods obtain a matrix <em>Q</em> orthogonal of size <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> and a matrix <em>L</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> whose first m-n cols are in general not zero and whose last n columns form a lower triangular matrix.</p>
<p>This function uses the underlying function <a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0">QRDecomposition</a> to perform the QL decomposition, so the available methods are the same than the ones used in the QR decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the matrix Q resulting from the QL decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the QL decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392" title="Obtains the LQ decomposition of a rectangular  matrix.">LQDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718" title="Obtains the RQ decomposition of a rectangular  matrix.">RQDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00771">771</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga42e745f3d76515e05ab8c16c24e0056a"></a><!-- doxytag: member="qvmatrixalgebra.h::QLDecompositionResidual" ref="ga42e745f3d76515e05ab8c16c24e0056a" args="(const QVMatrix &amp;M, const QVMatrix &amp;Q, const QVMatrix &amp;L)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double QLDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the QL decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||Q L - M)||_{Frobenius} + ||Q^T Q - I)||_{Frobenius}$" src="form_121.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = Q L $" src="form_120.png"/> is a correct QL decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix from the QL decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the QL decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b" title="Obtains the QL decomposition of a rectangular  matrix.">QLDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00784">784</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa825c3d75d892d43c6f20fa3ae909718"></a><!-- doxytag: member="qvmatrixalgebra.h::RQDecomposition" ref="gaa825c3d75d892d43c6f20fa3ae909718" args="(const QVMatrix &amp;M, QVMatrix &amp;R, QVMatrix &amp;Q, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RQDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">RQ decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix. </p>
<p>The RQ decomposition obtains two matrices <em>R</em> and <em>Q</em> from an original matrix <em>M</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> that satisfy the following equation:</p>
<p><img class="formulaInl" alt="$ M = R Q $" src="form_122.png"/></p>
<p>For a square matrix M (m=n), R is upper triangular and Q orthogonal, both square of size <img class="formulaInl" alt="$ m \times m$" src="form_118.png"/> = <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>If m&gt;n, then both full and thin decomposition methods obtain a matrix <em>R</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> whose first m-n rows are in general not zero and whose last n rows form an upper triangular matrix, and a matrix <em>Q</em> which is orthogonal of size <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>If m&lt;n, then thin decomposition methods obtain a matrix <em>R</em> which is an upper triangular matrix of size <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/> and a <em>Q</em> matrix of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, with orthogonal rows, while full decomposition methods obtain a matrix <em>R</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> whose first n-m columns are zero, and whose last m columns form a lower triangular matrix, and a matrix <em>Q</em> orthogonal of size <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>This function uses the underlying function <a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0">QRDecomposition</a> to perform the RQ decomposition, so the available methods are the same than the ones used in the QR decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>param to store the matrix R resulting from the RQ decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the matrix Q resulting from the RQ decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b" title="Obtains the QL decomposition of a rectangular  matrix.">QLDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392" title="Obtains the LQ decomposition of a rectangular  matrix.">LQDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00789">789</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa37783c86d91abd724a2eab2cd609ddd"></a><!-- doxytag: member="qvmatrixalgebra.h::RQDecompositionResidual" ref="gaa37783c86d91abd724a2eab2cd609ddd" args="(const QVMatrix &amp;M, const QVMatrix &amp;R, const QVMatrix &amp;Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RQDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the RQ decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||R Q - M)||_{Frobenius} + ||Q Q^T - I)||_{Frobenius}$" src="form_123.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = R Q $" src="form_122.png"/> is a correct RQ decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>input matrix from the RQ decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix from the RQ decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718" title="Obtains the RQ decomposition of a rectangular  matrix.">RQDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00802">802</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaac2e3437531d9acfec99b6b7ee300392"></a><!-- doxytag: member="qvmatrixalgebra.h::LQDecomposition" ref="gaac2e3437531d9acfec99b6b7ee300392" args="(const QVMatrix &amp;M, QVMatrix &amp;L, QVMatrix &amp;Q, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LQDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/QR_decomposition#QL.2C_RQ_and_LQ_decompositions">LQ decomposition</a> of a rectangular <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> matrix. </p>
<p>The LQ decomposition obtains two matrices <em>L</em> and <em>Q</em> from an original matrix <em>M</em> of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> that satisfy the following equation:</p>
<p><img class="formulaInl" alt="$ M = L Q $" src="form_124.png"/></p>
<p>For a square matrix M (m=n), L is lower triangular and Q orthogonal, both square of size <img class="formulaInl" alt="$ m \times m$" src="form_118.png"/> = <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/>.</p>
<p>For full decomposition methods, or if m&gt;n, <em>L</em> is a lower triangular matrix of size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/> and matrix <em>Q</em> is orthogonal of size <img class="formulaInl" alt="$ n \times n $" src="form_76.png"/> .</p>
<p>For thin decomposition methods, and if m&lt;n, <em>L</em> is a lower triangular matrix of size <img class="formulaInl" alt="$ m \times m $" src="form_75.png"/>, and matrix <em>Q</em> has size <img class="formulaInl" alt="$ m \times n $" src="form_73.png"/>, with orthogonal rows.</p>
<p>This function uses the underlying function <a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0">QRDecomposition</a> to perform the LQ decomposition, so the available methods are the same than the ones used in the QR decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>param containing the matrix to decompose </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>param to store the matrix L resulting from the LQ decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the matrix Q resulting from the LQ decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b" title="Obtains the QL decomposition of a rectangular  matrix.">QLDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718" title="Obtains the RQ decomposition of a rectangular  matrix.">RQDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00807">807</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabcf3725f2738f4fb4e823d5a7175ecb9"></a><!-- doxytag: member="qvmatrixalgebra.h::LQDecompositionResidual" ref="gabcf3725f2738f4fb4e823d5a7175ecb9" args="(const QVMatrix &amp;M, const QVMatrix &amp;L, const QVMatrix &amp;Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LQDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the LQ decomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||L Q - M)||_{Frobenius} + ||Q Q^T - I)||_{Frobenius}$" src="form_125.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = L Q $" src="form_124.png"/> is a correct LQ decomposition of matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>input matrix from the LQ decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix from the LQ decomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392" title="Obtains the LQ decomposition of a rectangular  matrix.">LQDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00820">820</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c9f02ada4121317c084f1c7ec09e17c"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromQRDecomposition" ref="ga4c9f02ada4121317c084f1c7ec09e17c" args="(const QVMatrix &amp;Q, const QVMatrix &amp;R, QVMatrix &amp;X, const QVMatrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the previously obtained QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M X = Q R $" src="form_126.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix Q from the QR decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>input matrix R from the QR decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00825">825</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3">solveByQRDecomposition()</a>, and <a class="el" href="group__qvmatrixalgebra.html#ga228fdd20d46605f6177054634126320c">solveFromQRDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="ga228fdd20d46605f6177054634126320c"></a><!-- doxytag: member="qvmatrixalgebra.h::solveFromQRDecomposition" ref="ga228fdd20d46605f6177054634126320c" args="(const QVMatrix &amp;Q, const QVMatrix &amp;R, QVVector &amp;x, const QVVector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveFromQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the previously obtained QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input matrix Q from the QR decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>input matrix R from the QR decomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition(const QVMatrix &amp;, const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00846">846</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a31c23838ccb1a35229cda96266c640"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByQRDecomposition" ref="ga0a31c23838ccb1a35229cda96266c640" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>, being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the QR computation (see <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga228fdd20d46605f6177054634126320c" title="Solves the linear system  for the unknown vector , using the previously obtained...">solveFromQRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00864">864</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga35e4e3e2dd0a5ebbd93f672bf569e4a3"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByQRDecomposition" ref="ga35e4e3e2dd0a5ebbd93f672bf569e4a3" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>, being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640" title="Solves the linear system  for the unknown matrix , using the QR decomposition of...">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00855">855</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ec9b2e2693b1e700892e6a4aa6398c3"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByQRDecomposition" ref="ga7ec9b2e2693b1e700892e6a4aa6398c3" args="(const QVMatrix &amp;M, QVMatrix &amp;X, const QVMatrix &amp;B, QVMatrix &amp;Q, QVMatrix &amp;R, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M X = B$" src="form_84.png"/> for the unknown matrix <img class="formulaInl" alt="$X$" src="form_85.png"/>, using the QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>. The function also returns the matrices <img class="formulaInl" alt="$ Q$" src="form_128.png"/> and <img class="formulaInl" alt="$ R$" src="form_48.png"/> resulting from the QR decomposition.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>, being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>unknown matrix (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the matrix Q resulting from the QR decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>param to store the matrix R resulting from the QR decomposition (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640" title="Solves the linear system  for the unknown matrix , using the QR decomposition of...">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00882">882</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gade60b82ebf24951f074f43c211fd67a3"></a><!-- doxytag: member="qvmatrixalgebra.h::solveByQRDecomposition" ref="gade60b82ebf24951f074f43c211fd67a3" args="(const QVMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, QVMatrix &amp;Q, QVMatrix &amp;R, const TQVQR_Method method=DEFAULT_TQVQR_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveByQRDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21">TQVQR_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVQR_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system <img class="formulaInl" alt="$M x = b$" src="form_88.png"/> for the unknown vector <img class="formulaInl" alt="$x$" src="form_89.png"/>, using the QR decomposition of M: </p>
<p><img class="formulaInl" alt="$ M = Q R $" src="form_117.png"/></p>
<p>The solution is obtained by solving the triangular system <img class="formulaInl" alt="$ R X = Q^T B $" src="form_127.png"/>. The function also returns the matrices <img class="formulaInl" alt="$ Q$" src="form_128.png"/> and <img class="formulaInl" alt="$ R$" src="form_48.png"/> resulting from the QR decomposition.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For overdetermined systems (<img class="formulaInl" alt="$m>n$" src="form_93.png"/>, being <img class="formulaInl" alt="$m \times n$" src="form_92.png"/> the size of the coefficient matrix <img class="formulaInl" alt="$M$" src="form_91.png"/>), the obtained solution minimizes the sums of squares of the residuals of the <img class="formulaInl" alt="$m$" src="form_94.png"/> equations.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>unknown vector (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>param to store the matrix Q resulting from the QR decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>param to store the matrix R resulting from the QR decomposition (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640" title="Solves the linear system  for the unknown matrix , using the QR decomposition of...">solveByQRDecomposition(const QVMatrix &amp;, QVMatrix &amp;, const QVMatrix &amp;, const TQVQR_Method)</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00872">872</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae95e6a42f2cce467f30a55289a0f9824"></a><!-- doxytag: member="qvmatrixalgebra.h::eigenDecomposition" ref="gae95e6a42f2cce467f30a55289a0f9824" args="(const QVMatrix &amp;M, QVVector &amp;lambda, QVMatrix &amp;Q, const TQVEigenDecomposition_Method method=DEFAULT_TQVEIGENDECOMPOSITION_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigenDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">TQVEigenDecomposition_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVEIGENDECOMPOSITION_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigen-decomposition</a> of a symmetric matrix. </p>
<p>The eigen-decomposition obtains the factorization of a symmetric matrix <em>M</em> into a canonical form, represented in terms of a set of eigenvectors and their corresponding eigenvalues.</p>
<p>Each eigenvector <img class="formulaInl" alt="$ \mathbf{v}_i $" src="form_129.png"/> and its corresponding eigenvalue <img class="formulaInl" alt="$ \lambda_i $" src="form_130.png"/> satisfy the following equation.</p>
<p><img class="formulaInl" alt="$ M \mathbf{v}_i = \lambda_i \mathbf{v}_i $" src="form_131.png"/></p>
<p>This function returns the eigenvectors and their corresponding eigenvalues in a <em>Q</em> matrix and a <em>lambda</em> vector, respectively. Each eigenvector is stored as a row of the <em>Q</em> matrix. The <em>i</em>-th element of the vector <em>lambda</em> contains the eigenvalue corresponding to the eigenvector stored in the <em>i</em>-th row. Eigenvectors are mutually orthogonal, therefore, Q is an orthonormal matrix (i.e. <img class="formulaInl" alt="$ Q Q^T = Q^T Q = I $" src="form_132.png"/>)</p>
<p>Thus, the following equation holds, given that the matrix <img class="formulaInl" alt="$ Q $" src="form_133.png"/> and the vector <img class="formulaInl" alt="$ \vec{\lambda} $" src="form_134.png"/> contain respectively the eigen-vectors and the eigen-values of the symmetric matrix <em>M</em>:</p>
<p><img class="formulaInl" alt="$ M = Q diag(\vec{\lambda}) Q^{T} $" src="form_135.png"/></p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>symmetric matrix to obtain eigen-decomposition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>vector containing the eigenvalues from the eigen-decomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>matrix containing the eigenvectors from the eigen-decomposition of M; eigenvectors are stored as row vectors (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8">TQVEigenDecomposition_Method</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00990">990</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ccc97075c8c8d5340dd6b8b2ace3190"></a><!-- doxytag: member="qvmatrixalgebra.h::eigenDecompositionResidual" ref="ga5ccc97075c8c8d5340dd6b8b2ace3190" args="(const QVMatrix &amp;M, const QVVector &amp;lambda, const QVMatrix &amp;Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double eigenDecompositionResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the eigendecomposition of a matrix. </p>
<p>This function computes the value <img class="formulaInl" alt="$||Q diag(\lambda) Q^T-M)||_{Frobenius} + ||Q^T Q - I||_{Frobenius}$" src="form_136.png"/>, which should be close to zero if <img class="formulaInl" alt="$ M = Q diag(\lambda) Q^T $" src="form_137.png"/> is a correct eigendecomposition of symmetric matrix M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input symmetric M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>input vector of eigenvalues from the eigendecomposition of M </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>input Q matrix from the eigendecomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>EigenDecomposition </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l00995">995</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabbfe32bf1d0c4def6ecb805bca65d03c"></a><!-- doxytag: member="qvmatrixalgebra.h::eigenValues" ref="gabbfe32bf1d0c4def6ecb805bca65d03c" args="(const QVMatrix &amp;M, QVVector &amp;lambda, const TQVEigenValues_Method method=DEFAULT_TQVEIGENVALUES_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigenValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">TQVEigenValues_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVEIGENVALUES_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the eigenvalues of a matrix. </p>
<p>This function computes only the eigenvalues of a symmetric matrix (which, depending also on the used method, will be much faster than performing a full eigendecomposition).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input symmetric M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>vector of eigenvalues from the eigendecomposition (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the eigenvalues computation (see <a class="el" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2">TQVEigenValues_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>EigenDecomposition </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01008">1008</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga124008527c22895b3dc8b828eb867306"></a><!-- doxytag: member="qvmatrixalgebra.h::eigenValuesResidual" ref="ga124008527c22895b3dc8b828eb867306" args="(const QVMatrix &amp;M, const QVVector &amp;lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double eigenValuesResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for correctness of the eigenvalues of a symmetric matrix. </p>
<p>This function returns the difference between the sum of diagonal elements of the matrix (i.e., its trace) and the sum of the elements of <img class="formulaInl" alt="$\lambda$" src="form_138.png"/> (which are supposed to be its eigenvalues). This should be close to zero if the <img class="formulaInl" alt="$\lambda$" src="form_138.png"/> are really the eigenvalues of M.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input M matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lambda</em>&nbsp;</td><td>input vector of eigenvalues from the eigendecomposition of M</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>EigenValues </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01020">1020</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadf6472ec782375d465ff1e87b3ae2557"></a><!-- doxytag: member="qvmatrixalgebra.h::pseudoInverse" ref="gadf6472ec782375d465ff1e87b3ae2557" args="(const QVMatrix &amp;M, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD, const double epsilon=1.0E&#45;10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVMatrix.html">QVMatrix</a> pseudoInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code>1.0E-10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse">Moore–Penrose pseudoinverse</a> of a matrix. </p>
<p>The pseudoinverse is computed using the SVD of the input matrix, and then using the reciprocal of the obtained singular values. The used formula is <img class="formulaInl" alt="$ M^{+} = \sum_{i} (1/s_i) (v_i \otimes u_i) $" src="form_139.png"/>, being <img class="formulaInl" alt="$u_i$" src="form_140.png"/> and <img class="formulaInl" alt="$v_i$" src="form_141.png"/> column vectors of the orthogonal U and V matrices obtained by SVD. Singular values which, when divided by the first singular value, are smaller than the epsilon parameter are discarded in the computation.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>input matrix to obtain pseudoinverse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>singular values with value smaller than epsilon will be discarded in computation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01037">1037</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#gae622eb1823659bb0d8dd9528f22e2f1c">computeAffineHomography()</a>, <a class="el" href="group__qvsfm.html#ga88e5c045a99ad4e58d312ccee761860d">correctIntrinsics()</a>, <a class="el" href="classQVMatrix.html#ab00a021c82b223c25b6d51c203e30d16">QVMatrix::inverse()</a>, <a class="el" href="qvprojective_8cpp.html#aefe2c68264497da296129eb3c0cc8ed4">linearCameraCenterResection()</a>, and <a class="el" href="group__qvstatistics.html#gae616e493b5a83636ca91f8397ad899e7">qvLinearRegularizedRegression()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18cb128a894fa599a42b85e403049416"></a><!-- doxytag: member="qvmatrixalgebra.h::determinant" ref="ga18cb128a894fa599a42b85e403049416" args="(const QVMatrix &amp;M, const TQVLU_Method method=DEFAULT_TQVLU_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVLU_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the <a href="http://en.wikipedia.org/wiki/Determinant">determinant</a> of a square matrix. </p>
<p>The determinant is obtained by first obtaining the LU decomposition of the matrix, then multiplying the values in the diagonal of U, and finally multiplying the result by the signature of the permutation P in the decomposition <img class="formulaInl" alt="$ M = PLU $" src="form_142.png"/></p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>matrix to obtain the determinant </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the LU decomposition (see <a class="el" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736">TQVLU_Method</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of the determinant </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01057">1057</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="classQVMatrix.html#a340dd57c9cd0130521af15af550cfef2">QVMatrix::det()</a>, <a class="el" href="group__qvprojectivegeometry.html#ga017edd807b040c198a02733e4b81e1df">getCameraPosesFromEssentialMatrix()</a>, and <a class="el" href="classQVEuclideanMapping3.html#a9fa1c24113751ff783141415a3dc38c8">QVEuclideanMapping3::QVEuclideanMapping3()</a>.</p>

</div>
</div>
<a class="anchor" id="gabcefb2cb61ed46e61130f4892308fee4"></a><!-- doxytag: member="qvmatrixalgebra.h::solveHomogeneous" ref="gabcefb2cb61ed46e61130f4892308fee4" args="(const QVMatrix &amp;A, QVector&lt; double &gt; &amp;x, const TQVSVD_Method method=DEFAULT_TQVSVD_METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveHomogeneous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSVD_METHOD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves an <a href="http://en.wikipedia.org/wiki/System_of_linear_equations#Homogeneous_systems">homogeneous linear system of equations</a>. </p>
<p>Given a matrix <em>M</em>, this functions obtain the vector <em>x</em> satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M\mathbf{x} = \mathbf{0} $" src="form_143.png"/></p>
<p>The solution is based on the SVD decomposition of the matrix <em>A</em>. Vector <em>x</em> is set to the last column of the matrix <em>V</em> from the SVD decomposition of <em>M</em>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>coeficient matrix for the homogeneous equation system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>vector to store the solution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the SVD decomposition (see <a class="el" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575">TQVSVD_Method</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01092">1092</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef">linear3DPointTriangulation()</a>, and <a class="el" href="group__qvprojectivegeometry.html#gae1435ef34731a4088d1c45deab3d3ba5">linearCameraResection()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70717e261a395b8c380c4321dbb12572"></a><!-- doxytag: member="qvmatrixalgebra.h::solveResidual" ref="ga70717e261a395b8c380c4321dbb12572" args="(const QVMatrix &amp;M, const QVMatrix &amp;X, const QVMatrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double solveResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the residual of the solution to a linear matrix equation. </p>
<p>This function computes the value <img class="formulaInl" alt="$ ||M X - B||^2_{Frobenius} $" src="form_144.png"/>, which should be close to zero if X is the solution to the matrix equation <img class="formulaInl" alt="$ M X = B$" src="form_145.png"/>, or should be minimized if the system was solved in the minimum squares sense.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>input unknown matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input right hand side matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the computed residual</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5" title="Solves the linear system  for the unknown vector , using the Cholesky decomposition...">solveByCholeskyDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea" title="Solves the linear system  for the unknown vector , using the LU decomposition .">solveByLUDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01101">1101</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2e939fc01193d7854e855684b87d7ed"></a><!-- doxytag: member="qvmatrixalgebra.h::solveResidual" ref="gaf2e939fc01193d7854e855684b87d7ed" args="(const QVMatrix &amp;M, const QVVector &amp;x, const QVVector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double solveResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVMatrix.html">QVMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the residual of the solution to a linear vector equation. </p>
<p>This function computes the value <img class="formulaInl" alt="$||M x - B||^2 $" src="form_146.png"/>, which should be close to zero if x is the solution to the equation <img class="formulaInl" alt="$ M x = b$" src="form_147.png"/>, or should be minimized if the system was solved in the minimum squares sense.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coefficient matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>input unknown vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right hand side vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the computed residual</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5" title="Solves the linear system  for the unknown vector , using the Cholesky decomposition...">solveByCholeskyDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea" title="Solves the linear system  for the unknown vector , using the LU decomposition .">solveByLUDecomposition</a> <a class="el" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01108">1108</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7293f186086b4b233cf51046f016158"></a><!-- doxytag: member="qvmatrixalgebra.h::sparseSolve" ref="gaf7293f186086b4b233cf51046f016158" args="(const QVSparseBlockMatrix &amp;M, QVVector &amp;x, const QVVector &amp;b, const bool isSymmetric=false, const bool isPosDefinite=false, const TQVSparseSolve_Method method=DEFAULT_TQVSPARSESOLVE_METHOD, const bool start_from_x=false, const bool iters_or_resid=true, const int iters=0, const double resid=1.0E&#45;10, int &amp;final_iter_count=dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sparseSolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVSparseBlockMatrix.html">QVSparseBlockMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>isSymmetric</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>isPosDefinite</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>DEFAULT_TQVSPARSESOLVE_METHOD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>start_from_x</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>iters_or_resid</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>resid</em> = <code>1.0E-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>final_iter_count</em> = <code>dummy</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a <a href="http://en.wikipedia.org/wiki/Sparse_matrix">sparse system</a> of linear equations, taking advantage of sparseness to accelerate the computation. </p>
<p>Given a coefficient matrix <em>M</em> and an objective vector <em>b</em>, this functions obtains the vector <em>x</em> satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M\mathbf{x} = \mathbf{b} $" src="form_148.png"/></p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Only upper-diagonal blocks should be defined in the input M matrix.</dd>
<dd>
Either GSL or MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coeficient sparse block matrix in the matrix equation form of the problem (must be square) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>vector to store the solution (overwritten on output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>input right-hand side vector in the matrix equation form of the problem </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isSymmetric</em>&nbsp;</td><td>indicates if M must be considered symmetric (in this case, only the upper triangular part is taken into account, which will speed up the computation). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isPosDefinite</em>&nbsp;</td><td>indicates if M is positive definite (in this case, the solver will take this into account to speed up the computation). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_from_x</em>&nbsp;</td><td>only for the QVMKL_ISS method, if true, start from the input value of x </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iters_or_resid</em>&nbsp;</td><td>only for the QVMKL_ISS method, if true, use max iterations termination test (see param iters), otherwise use max residual (see param max_resid) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iters</em>&nbsp;</td><td>only for the incremental methods (QVMKL_ISS and QV_SCG). Number of iterations to execute (if zero, iterate until convergence or error) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_resid</em>&nbsp;</td><td>only for the incremental methods (QVMKL_ISS and QV_SCG). Iterate until square of residual is below this parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iters</em>&nbsp;</td><td>only for the QVMKL_ISS method, final number of iterations really executed (overwritten on output)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>square norm of current residual, for incremental methods (QVMKL_ISS and QV_SCG), always 0.0 for QVMKL_DSS</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01216">1216</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

<p>Referenced by <a class="el" href="group__qvsfm.html#gad245d4a452046e18d3e4854398add123">globalEpipolarAdjustment()</a>, and <a class="el" href="group__qvsfm.html#ga854751f95bc2cd345b9f5cceaea3b192">incrementalGEA()</a>.</p>

</div>
</div>
<a class="anchor" id="gada28dcc8be2cf1b93f3b1f201cafdb88"></a><!-- doxytag: member="qvmatrixalgebra.h::solveHomogeneous" ref="gada28dcc8be2cf1b93f3b1f201cafdb88" args="(const QVSparseBlockMatrix &amp;A, QVVector &amp;x, const int maxIterations=10, const double minRelativeError=0.0, const TQVSparseSolve_Method method=QVMKL_DSS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool solveHomogeneous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVSparseBlockMatrix.html">QVSparseBlockMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVVector.html">QVVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>maxIterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>minRelativeError</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>QVMKL_DSS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a sparse homogeneous linear system using the <a href="http://en.wikipedia.org/wiki/Inverse_iteration">inverse iteration</a> algorithm and the MKL sparse routines. </p>
<p>Given a matrix <em>M</em>, this function obtains the vector <em>x</em> satisfying the following equation:</p>
<p><img class="formulaInl" alt="$ M\mathbf{x} = \mathbf{0} $" src="form_143.png"/></p>
<p>An iterative process is used to converge from an initial random solution to the optimal solution of the equation.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>MKL compatibility must be enabled to use this function. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>input coeficient sparse block matrix in the matrix equation form of the problem (must be square) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>this vector will contain the solution to the homogeneous linear system in return. An initial approximation to the solution can be provided in this argument. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxIterations</em>&nbsp;</td><td>number of maximal iterations to perform in the algoritm. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minRelativeError</em>&nbsp;</td><td>the iteration process will stop if the value <img class="formulaInl" alt="$ \|x_i - x_{i-1} \| $" src="form_149.png"/> (the difference between the solutions obtained in the last two iterations) is smaller than this value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>method to use in the computation (see <a class="el" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42">TQVSparseSolve_Method</a>). Only method <a class="el" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd">QVMKL_DSS</a> is currently implemented for this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function works only with MKL. </dd></dl>

<p>Definition at line <a class="el" href="qvmatrixalgebra_8cpp_source.html#l01629">1629</a> of file <a class="el" href="qvmatrixalgebra_8cpp_source.html">qvmatrixalgebra.cpp</a>.</p>

</div>
</div>
</div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
