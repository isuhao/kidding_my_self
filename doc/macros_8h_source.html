<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvipp/macros.h</h1><a href="macros_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;qvipp.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;QVMatrix&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">// Macro to call IPP functions</span>
<a name="l00030"></a>00030 <span class="preprocessor">#define IPP_DEBUG(function, ipp_function, ...)                          \</span>
<a name="l00031"></a>00031 <span class="preprocessor">        {                                                               \</span>
<a name="l00032"></a>00032 <span class="preprocessor">        IppStatus status = ipp_function(__VA_ARGS__);                   \</span>
<a name="l00033"></a>00033 <span class="preprocessor">        Q_ASSERT_X(     status == ippStsNoErr, #ipp_function,           \</span>
<a name="l00034"></a>00034 <span class="preprocessor">                        ippGetStatusString(status));                    \</span>
<a name="l00035"></a>00035 <span class="preprocessor">        Q_UNUSED(status);                                               \</span>
<a name="l00036"></a>00036 <span class="preprocessor">        }                                                               \</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="comment">// To actualize ROI for output images</span>
<a name="l00040"></a><a class="code" href="macros_8h.html#af5414c6a3786023ef4b0faae8de42947">00040</a> <span class="comment"></span><span class="preprocessor">#define COMPOSE_ROI(DestImage, SrcImage, DestROIOffset, incW, incH)             \</span>
<a name="l00041"></a>00041 <span class="preprocessor">        {                                                                       \</span>
<a name="l00042"></a>00042 <span class="preprocessor">        const int       roiX = DestROIOffset.x(),                               \</span>
<a name="l00043"></a>00043 <span class="preprocessor">                        roiY = DestROIOffset.y(),                               \</span>
<a name="l00044"></a>00044 <span class="preprocessor">                        roiWidth = SrcImage.getROI().width() - (incW),          \</span>
<a name="l00045"></a>00045 <span class="preprocessor">                        roiHeight = SrcImage.getROI().height() - (incH);                \</span>
<a name="l00046"></a>00046 <span class="preprocessor">        if( roiX + roiWidth &lt; 0 ||  roiY + roiHeight &lt; 0) return;               \</span>
<a name="l00047"></a>00047 <span class="preprocessor">        DestImage.resize(roiX + roiWidth, roiY + roiHeight);                    \</span>
<a name="l00048"></a>00048 <span class="preprocessor">        DestImage.setROI(roiX, roiY, roiWidth, roiHeight);                      \</span>
<a name="l00049"></a>00049 <span class="preprocessor">        }</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="comment">// Checks</span>
<a name="l00052"></a>00052 <span class="preprocessor">#define CHECK_SAME_STEP(Image1, Image2)                 Q_ASSERT(Image1.getStep() == Image2.getStep())</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_SAME_ROISIZE(Image1, Image2)              Q_ASSERT(Image1.getROI().size() == Image2.getROI().size())</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_COMPATIBLE_IMAGES(NAME, Image1, Image2)   Q_ASSERT(Image1.getROI().size() == Image2.getROI().size())</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="comment">// Reads a pointer to the image, counting the ROI</span>
<a name="l00057"></a>00057 <span class="preprocessor">#define PDATA_READ(Image)       (&amp;Image.getReadData()[Image.getROI().y()*Image.getStep()/Image.getTypeSize() + Image.getChannels()*Image.getROI().x()])</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#define PDATA_WRITE(Image)      (&amp;Image.getWriteData()[Image.getROI().y()*Image.getStep()/Image.getTypeSize() + Image.getChannels()*Image.getROI().x()])</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#define PDATA_READ_MARGIN(Image, marginCols, marginRows)                                \</span>
<a name="l00061"></a>00061 <span class="preprocessor">        (&amp;Image.getReadData()[                                                          \</span>
<a name="l00062"></a>00062 <span class="preprocessor">                (Image.getROI().y()+marginRows)*Image.getStep()/Image.getTypeSize()     \</span>
<a name="l00063"></a>00063 <span class="preprocessor">                + Image.getChannels()*(Image.getROI().x()+marginCols)]                  \</span>
<a name="l00064"></a>00064 <span class="preprocessor">                )</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="comment">// Get the size of the image</span>
<a name="l00067"></a>00067 <span class="preprocessor">#define IMAGE_ROISIZE(Image)    ((IppiSize){ Image.getROI().width(), Image.getROI().height() })</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define IMAGE_ROIRECT(Image)    ((IppiRect){ Image.getROI().x(), Image.getROI().y(), Image.getROI().width(), Image.getROI().height() })</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define IMAGE_SIZE(Image)       ((IppiSize){ Image.getCols(), Image.getRows() })</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define IPP_SIZE(X,Y)           ( (IppiSize) { (X), (Y) })</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define IPP_POINT(X,Y)          ( (IppiPoint) { (X), (Y) })</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define IPP_SIZE_FROM_QSIZE(MaskSize)   IPP_SIZE(MaskSize.width(), MaskSize.height())</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define IPP_POINT_FROM_QPOINT(Point)    IPP_POINT(Point.x(), Point.y())</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="preprocessor">#define IPP_MASK_SIZE_ROWS(Size)(       (Size == ippMskSize3x1  || Size == ippMskSize5x1)? 1:   \</span>
<a name="l00076"></a>00076 <span class="preprocessor">                                        (Size == ippMskSize1x3  || Size == ippMskSize3x3)? 3: 5 )</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#define IPP_MASK_SIZE_COLS(Size)(       (Size == ippMskSize1x3  || Size == ippMskSize1x5)? 1:   \</span>
<a name="l00079"></a>00079 <span class="preprocessor">                                        (Size == ippMskSize3x1  || Size == ippMskSize3x3)? 3: 5 )</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00081"></a>00081 <span class="comment">// START OF MACROS</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">// Funciones con una imagen de entrada y otra de salida, del mismo tipo.</span>
<a name="l00085"></a>00085 <span class="comment">// Filtros que aplican una máscara de tamaño 3x3. El ROI de destino es más pequeño que el ROI origen.</span>
<a name="l00086"></a>00086 <span class="comment">// Ejemplos: ippiFilterSharpen</span>
<a name="l00087"></a>00087 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_Cj_ROIOFFSET_BORDER3x3(NAME, TYPE, C, SUBFIX)           \</span>
<a name="l00088"></a>00088 <span class="preprocessor">void NAME(const QVImage&lt;TYPE, C&gt; &amp;src, QVImage&lt;TYPE, C&gt; &amp;dest, const QPoint &amp;destROIOffset)                     \</span>
<a name="l00089"></a>00089 <span class="preprocessor">        {                                                                                                       \</span>
<a name="l00090"></a>00090 <span class="preprocessor">        const int maskCols = 3, maskRows = 3;                                                                   \</span>
<a name="l00091"></a>00091 <span class="preprocessor">                                                                                                                \</span>
<a name="l00092"></a>00092 <span class="preprocessor">        COMPOSE_ROI(dest, src, destROIOffset, maskCols-1, maskRows-1);                                          \</span>
<a name="l00093"></a>00093 <span class="preprocessor">                                                                                                                \</span>
<a name="l00094"></a>00094 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                         \</span>
<a name="l00095"></a>00095 <span class="preprocessor">                                PDATA_READ_MARGIN(src, (maskCols - 1)/2, (maskRows -1)/2), src.getStep(),       \</span>
<a name="l00096"></a>00096 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                              \</span>
<a name="l00097"></a>00097 <span class="preprocessor">                                IMAGE_ROISIZE(dest)                                                             \</span>
<a name="l00098"></a>00098 <span class="preprocessor">                                );                                                                              \</span>
<a name="l00099"></a>00099 <span class="preprocessor">        }</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="comment">// Tres imagenes de un canal de entrada, y una de varios canales de salida, todas del mismo tipo.</span>
<a name="l00102"></a>00102 <span class="comment">// Para operaciones de composición de varias imágenes de un solo canal en una de tres canales.</span>
<a name="l00103"></a>00103 <span class="comment">// Ejemplos: ippiCopy</span>
<a name="l00104"></a>00104 <span class="comment">//</span>
<a name="l00105"></a>00105 <span class="comment">// Comprobar: que las tres imagenes de entrada tienen el mismo step (sólo se le puede pasar uno</span>
<a name="l00106"></a>00106 <span class="comment">// a la función de las IPP) y el mismo tamaño para el ROI.</span>
<a name="l00107"></a>00107 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_C1_SRCIMAGE_Ti_C1_SRCIMAGE_Ti_C1_DESTIMAGE_Ti_Cj_ROIOFFSET(NAME, TYPE, C, SUBFIX)                               \</span>
<a name="l00108"></a>00108 <span class="preprocessor">void NAME(const QVImage&lt;TYPE, 1&gt; &amp;src1, const QVImage&lt;TYPE, 1&gt; &amp;src2, const QVImage&lt;TYPE, 1&gt; &amp;src3, QVImage&lt;TYPE, C&gt; &amp;dest, const QPoint &amp;destROIOffset)        \</span>
<a name="l00109"></a>00109 <span class="preprocessor">        {                                                                                                                                               \</span>
<a name="l00110"></a>00110 <span class="preprocessor">        CHECK_SAME_STEP(src1, src2);                                                                            \</span>
<a name="l00111"></a>00111 <span class="preprocessor">        CHECK_SAME_STEP(src2, src3);                                                                            \</span>
<a name="l00112"></a>00112 <span class="preprocessor">        CHECK_SAME_ROISIZE(src1, src2);                                                                         \</span>
<a name="l00113"></a>00113 <span class="preprocessor">        CHECK_SAME_ROISIZE(src2, src3);                                                                         \</span>
<a name="l00114"></a>00114 <span class="preprocessor">                                                                                                                \</span>
<a name="l00115"></a>00115 <span class="preprocessor">        COMPOSE_ROI(dest, src1, destROIOffset, 0, 0);                                                           \</span>
<a name="l00116"></a>00116 <span class="preprocessor">        const TYPE      * pSrc[3] = { PDATA_READ(src1), PDATA_READ(src2), PDATA_READ(src3) };                   \</span>
<a name="l00117"></a>00117 <span class="preprocessor">                                                                                                                \</span>
<a name="l00118"></a>00118 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                         \</span>
<a name="l00119"></a>00119 <span class="preprocessor">                                pSrc, src1.getStep(),                                                           \</span>
<a name="l00120"></a>00120 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                              \</span>
<a name="l00121"></a>00121 <span class="preprocessor">                                IMAGE_ROISIZE(dest));                                                           \</span>
<a name="l00122"></a>00122 <span class="preprocessor">        }</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span>
<a name="l00124"></a>00124 <span class="comment">// Una imagen de tres canales de entrada, y tres imagenes de un canal de entrada, todas del mismo tipo.</span>
<a name="l00125"></a>00125 <span class="comment">// Para operaciones de separación de los planos de una imagen en tres imágenes de un solo canal.</span>
<a name="l00126"></a>00126 <span class="comment">// Ejemplos: ippiCopy_8u_P3C3R</span>
<a name="l00127"></a>00127 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_C1_DESTIMAGE_Ti_C1_DESTIMAGE_Ti_C1_ROIOFFSET(NAME, TYPE, C, SUBFIX)                     \</span>
<a name="l00128"></a>00128 <span class="preprocessor">void NAME(const QVImage&lt;TYPE, C&gt; &amp;src, QVImage&lt;TYPE, 1&gt; &amp;dest1, QVImage&lt;TYPE, 1&gt; &amp;dest2, QVImage&lt;TYPE, 1&gt; &amp;dest3, const QPoint &amp;destROIOffset)  \</span>
<a name="l00129"></a>00129 <span class="preprocessor">        {                                                                                                                                       \</span>
<a name="l00130"></a>00130 <span class="preprocessor">        CHECK_SAME_STEP(dest1, dest2);                                                                  \</span>
<a name="l00131"></a>00131 <span class="preprocessor">        CHECK_SAME_STEP(dest2, dest3);                                                                  \</span>
<a name="l00132"></a>00132 <span class="preprocessor">                                                                                                        \</span>
<a name="l00133"></a>00133 <span class="preprocessor">        COMPOSE_ROI(dest1, src, destROIOffset, 0, 0);                                                   \</span>
<a name="l00134"></a>00134 <span class="preprocessor">        COMPOSE_ROI(dest2, src, destROIOffset, 0, 0);                                                   \</span>
<a name="l00135"></a>00135 <span class="preprocessor">        COMPOSE_ROI(dest3, src, destROIOffset, 0, 0);                                                   \</span>
<a name="l00136"></a>00136 <span class="preprocessor">                                                                                                        \</span>
<a name="l00137"></a>00137 <span class="preprocessor">        TYPE    * pDest[3] =    { PDATA_WRITE(dest1), PDATA_WRITE(dest2), PDATA_WRITE(dest3) };         \</span>
<a name="l00138"></a>00138 <span class="preprocessor">                                                                                                        \</span>
<a name="l00139"></a>00139 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                 \</span>
<a name="l00140"></a>00140 <span class="preprocessor">                                PDATA_READ(src), src.getStep(),                                         \</span>
<a name="l00141"></a>00141 <span class="preprocessor">                                pDest, dest1.getStep(),                                                 \</span>
<a name="l00142"></a>00142 <span class="preprocessor">                                IMAGE_ROISIZE(dest3));                                                  \</span>
<a name="l00143"></a>00143 <span class="preprocessor">        }</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>
<a name="l00145"></a>00145 <span class="comment">// Imagen de entrada y de salida de distinto numero de canales, y mismo tipo,</span>
<a name="l00146"></a>00146 <span class="comment">// con selector de canal para la de entrada. Para funciones que extraigan un canal de una imagen de 3 canales.</span>
<a name="l00147"></a>00147 <span class="comment">// Ejemplos: ippiCopy_8u_C3C1R</span>
<a name="l00148"></a>00148 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_Ck_CHANNELNUM_ROIOFFSET(NAME, TYPE, C1, C2, SUBFIX)             \</span>
<a name="l00149"></a>00149 <span class="preprocessor">void NAME(const QVImage&lt;TYPE, C1&gt; &amp;src, const uChar channel, QVImage&lt;TYPE, C2&gt; &amp;dest, const QPoint &amp;destROIOffset)      \</span>
<a name="l00150"></a>00150 <span class="preprocessor">        {                                                                                                               \</span>
<a name="l00151"></a>00151 <span class="preprocessor">        COMPOSE_ROI(dest, src, destROIOffset, 0, 0);                                                                    \</span>
<a name="l00152"></a>00152 <span class="preprocessor">                                                                                                                        \</span>
<a name="l00153"></a>00153 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                                 \</span>
<a name="l00154"></a>00154 <span class="preprocessor">                                PDATA_READ(src) + channel, src.getStep(),                                               \</span>
<a name="l00155"></a>00155 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                                      \</span>
<a name="l00156"></a>00156 <span class="preprocessor">                                IMAGE_ROISIZE(dest));                                                                   \</span>
<a name="l00157"></a>00157 <span class="preprocessor">        }</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00159"></a>00159 <span class="comment">// Dos imagenes de entrada, de mismo tipo y canales, y una de salida, de tipo char y un canal. Con método de comparación.</span>
<a name="l00160"></a>00160 <span class="comment">// Para funciones de comparación.</span>
<a name="l00161"></a>00161 <span class="comment">// Ejemplos: ippiCompare_8u_C3R</span>
<a name="l00162"></a>00162 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_SRCIMAGE_Ti_Cj_DESTIMAGE_C1_Tuchar_IPPCMPOP_ROIOFFSET(NAME, TYPE, C, SUBFIX)                         \</span>
<a name="l00163"></a>00163 <span class="preprocessor">void NAME(const QVImage&lt;TYPE,C&gt; &amp;src1, const QVImage&lt;TYPE,C&gt; &amp;src2, QVImage&lt;uChar&gt; &amp;dest, const IppCmpOp ippCmpOp, const QPoint &amp;destROIOffset) \</span>
<a name="l00164"></a>00164 <span class="preprocessor">        {                                                                                                                                       \</span>
<a name="l00165"></a>00165 <span class="preprocessor">        CHECK_SAME_ROISIZE(src1, src2);                                                                                                         \</span>
<a name="l00166"></a>00166 <span class="preprocessor">                                                                                                                                                \</span>
<a name="l00167"></a>00167 <span class="preprocessor">        COMPOSE_ROI(dest, src1, destROIOffset, 0, 0);                                                                                           \</span>
<a name="l00168"></a>00168 <span class="preprocessor">                                                                                                                                                \</span>
<a name="l00169"></a>00169 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                                                         \</span>
<a name="l00170"></a>00170 <span class="preprocessor">                                PDATA_READ(src1), src1.getStep(),                                                                               \</span>
<a name="l00171"></a>00171 <span class="preprocessor">                                PDATA_READ(src2), src2.getStep(),                                                                               \</span>
<a name="l00172"></a>00172 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                                                              \</span>
<a name="l00173"></a>00173 <span class="preprocessor">                                IMAGE_ROISIZE(dest),                                                                                            \</span>
<a name="l00174"></a>00174 <span class="preprocessor">                                ippCmpOp);                                                                                                      \</span>
<a name="l00175"></a>00175 <span class="preprocessor">        }</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>
<a name="l00177"></a>00177 <span class="comment">// Imagen de entrada y de salida con mismo tipo y canales. IPP_SIZE para tamaño de filtro.</span>
<a name="l00178"></a>00178 <span class="comment">// Por ejemplo, todas las funciones de filtrado, que pueden usar tamaños variables de filtro.</span>
<a name="l00179"></a>00179 <span class="comment">// Ejemplos: ippiFilterMax_8u_C1R, ippiFilterMin_8u_C1R</span>
<a name="l00180"></a>00180 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_Cj_MASKDIMENSION_ROIOFFSET(NAME, TYPE, C, SUBFIX)                                       \</span>
<a name="l00181"></a>00181 <span class="preprocessor">void NAME(const QVImage&lt;TYPE,C&gt; &amp;src, QVImage&lt;TYPE,C&gt; &amp;dest, const QSize &amp;maskSize, const QPoint &amp;maskAnchor, const QPoint &amp;destROIOffset)      \</span>
<a name="l00182"></a>00182 <span class="preprocessor">        {                                                                                                                                       \</span>
<a name="l00183"></a>00183 <span class="preprocessor">        const uInt colMaskRadius = maskSize.width(), rowMaskRadius = maskSize.height();                                                         \</span>
<a name="l00184"></a>00184 <span class="preprocessor">                                                                                                                                                \</span>
<a name="l00185"></a>00185 <span class="preprocessor">        COMPOSE_ROI(dest, src, destROIOffset, colMaskRadius-1, rowMaskRadius-1);                                                                \</span>
<a name="l00186"></a>00186 <span class="preprocessor">                                                                                                                                                \</span>
<a name="l00187"></a>00187 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                                                         \</span>
<a name="l00188"></a>00188 <span class="preprocessor">                                PDATA_READ(src), src.getStep(),                                                                                 \</span>
<a name="l00189"></a>00189 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                                                              \</span>
<a name="l00190"></a>00190 <span class="preprocessor">                                IMAGE_ROISIZE(dest),                                                                                            \</span>
<a name="l00191"></a>00191 <span class="preprocessor">                                IPP_SIZE(colMaskRadius, rowMaskRadius),                                                                         \</span>
<a name="l00192"></a>00192 <span class="preprocessor">                                IPP_POINT(maskAnchor.x(), maskAnchor.y()));                                                                     \</span>
<a name="l00193"></a>00193 <span class="preprocessor">        }</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00195"></a>00195 <span class="comment">// Imagen de entrada y de salida con mismo tipo y canales. IPP_MASK_SIZE para tamaño de filtro.</span>
<a name="l00196"></a>00196 <span class="comment">// Por ejemplo, todas las funciones de filtrado, que pueden usar tamaños fijos de filtro (3x3 o 5x5).</span>
<a name="l00197"></a>00197 <span class="comment">// Ejemplos: ippiFilterGauss_8u_C1R</span>
<a name="l00198"></a>00198 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_Cj_IPPMASKSIZE_ROIOFFSET(NAME, TYPE, C, SUBFIX)                         \</span>
<a name="l00199"></a>00199 <span class="preprocessor">void NAME(const QVImage&lt;TYPE, C&gt; &amp;src, QVImage&lt;TYPE, C&gt; &amp;dest, const IppiMaskSize maskSize, const QPoint &amp;destROIOffset)        \</span>
<a name="l00200"></a>00200 <span class="preprocessor">        {                                                                                                                       \</span>
<a name="l00201"></a>00201 <span class="preprocessor">        const int maskCols = IPP_MASK_SIZE_COLS(maskSize), maskRows = IPP_MASK_SIZE_ROWS(maskSize);             \</span>
<a name="l00202"></a>00202 <span class="preprocessor">                                                                                                                \</span>
<a name="l00203"></a>00203 <span class="preprocessor">        COMPOSE_ROI(dest, src, destROIOffset, maskCols-1, maskRows-1);                                          \</span>
<a name="l00204"></a>00204 <span class="preprocessor">                                                                                                                \</span>
<a name="l00205"></a>00205 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                         \</span>
<a name="l00206"></a>00206 <span class="preprocessor">                                PDATA_READ_MARGIN(src, (maskCols - 1)/2, (maskRows -1)/2), src.getStep(),       \</span>
<a name="l00207"></a>00207 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                              \</span>
<a name="l00208"></a>00208 <span class="preprocessor">                                IMAGE_ROISIZE(dest), maskSize                                                   \</span>
<a name="l00209"></a>00209 <span class="preprocessor">                                );                                                                              \</span>
<a name="l00210"></a>00210 <span class="preprocessor">        }</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>
<a name="l00212"></a>00212 <span class="comment">// Imagen de entrada y de salida con mismo tipo y canales. IPP_MASK_SIZE para tamaño de filtro. Uso de buffer de datos.</span>
<a name="l00213"></a>00213 <span class="comment">// Por ejemplo, todas las funciones de filtrado, que pueden usar tamaños fijos de filtro (3x3 o 5x5), que usan buffer de datos.</span>
<a name="l00214"></a>00214 <span class="comment">// Ejemplos: ippiFilterSobelNegVertBorder_8u16s_C1R</span>
<a name="l00215"></a>00215 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCIMAGE_Ti_Cj_DESTIMAGE_Ti_Cj_BUFFERIMAGE_Ti_Cj_IPPMASKSIZE__ROIOFFSET(NAME, TYPE1, TYPE2, C, SUBFIX)      \</span>
<a name="l00216"></a>00216 <span class="preprocessor">void NAME(const QVImage&lt;TYPE1,C&gt; &amp;src, QVImage&lt;TYPE2,C&gt; &amp;dest, const IppiMaskSize maskSize,                                             \</span>
<a name="l00217"></a>00217 <span class="preprocessor">        const IppiBorderType borderType, const TYPE1 borderValue, QVImage&lt;uChar,C&gt; &amp;buffer, const QPoint &amp;destROIOffset)                \</span>
<a name="l00218"></a>00218 <span class="preprocessor">        {                                                                                                                               \</span>
<a name="l00219"></a>00219 <span class="preprocessor">        const int maskCols = IPP_MASK_SIZE_COLS(maskSize), maskRows = IPP_MASK_SIZE_ROWS(maskSize);                                     \</span>
<a name="l00220"></a>00220 <span class="preprocessor">                                                                                                                                        \</span>
<a name="l00221"></a>00221 <span class="preprocessor">        COMPOSE_ROI(dest, src, destROIOffset, maskCols-1, maskRows-1);                                                                  \</span>
<a name="l00222"></a>00222 <span class="preprocessor">                                                                                                                                        \</span>
<a name="l00223"></a>00223 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX,                                                                                 \</span>
<a name="l00224"></a>00224 <span class="preprocessor">                                PDATA_READ_MARGIN(src, (maskCols - 1)/2, (maskRows -1)/2), src.getStep(),                               \</span>
<a name="l00225"></a>00225 <span class="preprocessor">                                PDATA_WRITE(dest), dest.getStep(),                                                                      \</span>
<a name="l00226"></a>00226 <span class="preprocessor">                                IMAGE_ROISIZE(dest), maskSize,                                                                          \</span>
<a name="l00227"></a>00227 <span class="preprocessor">                                borderType, borderValue, buffer.getWriteData());                                                        \</span>
<a name="l00228"></a>00228 <span class="preprocessor">        }</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>
<a name="l00230"></a>00230 <span class="comment">// Imagen genérica de entrada, y de salida de tipo y canales dado. Tamaño de máscara (5 ó 3)</span>
<a name="l00231"></a>00231 <span class="comment">// Para funciones que obtienen el buffer de trabajo de funciones de filtro que usan búfferes.</span>
<a name="l00232"></a>00232 <span class="comment">// Ejemplo: ippiFilterSobelNegVertGetBufferSize_8u16s_C1R</span>
<a name="l00233"></a>00233 <span class="preprocessor">#define DEFINE_IPP_FUNCTION_SRCGENERICIMAGE_DESTBUFFERIMAGE_Ti_Cj_IPPMASKSIZE__ROIOFFSET(NAME, TYPE1, TYPE2, C, SUBFIX)         \</span>
<a name="l00234"></a>00234 <span class="preprocessor">void NAME(const QVGenericImage &amp;src, const IppiMaskSize maskSize, QVImage&lt;TYPE1, C&gt; &amp;buffer)                                    \</span>
<a name="l00235"></a>00235 <span class="preprocessor">        {                                                                                                                       \</span>
<a name="l00236"></a>00236 <span class="preprocessor">        int bufferSize;                                                                                                         \</span>
<a name="l00237"></a>00237 <span class="preprocessor">                                                                                                                                \</span>
<a name="l00238"></a>00238 <span class="preprocessor">        IPP_DEBUG(NAME,         ippi ## NAME ## SUBFIX, IMAGE_ROISIZE(src),                                                     \</span>
<a name="l00239"></a>00239 <span class="preprocessor">                                maskSize, &amp;bufferSize);                                                                         \</span>
<a name="l00240"></a>00240 <span class="preprocessor">        buffer = QVImage&lt;uChar&gt;(bufferSize,1);                                                                                  \</span>
<a name="l00241"></a>00241 <span class="preprocessor">        }</span>
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
