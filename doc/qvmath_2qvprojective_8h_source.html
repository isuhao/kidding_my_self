<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvmath/qvprojective.h</h1><a href="qvmath_2qvprojective_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#ifndef QVPROJECTIVE_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#define QVPROJECTIVE_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;qvmath.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;QVMatrix&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;QHash&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;QVEuclideanMapping3&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;QV3DPointF&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;QVCameraPose&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#ifdef QVIPP</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;QVImage&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;qvipp.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#endif // QVIPP</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;qvmath/qvepipolar.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="qvreprojectionerror_8h.html" title="File from the QVision library.">qvmath/qvreprojectionerror.h</a>&gt;</span>
<a name="l00038"></a>00038 
<a name="l00042"></a>00042 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keywordtype">void</span> homogenizePoints(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings,
<a name="l00047"></a>00047         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;premult, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;postmult,
<a name="l00048"></a>00048         QList&lt; QPair&lt;QPointF, QPointF&gt; &gt; &amp;homogeneizedPairs);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">/*</span>
<a name="l00051"></a>00051 <span class="comment">@brief Obtains an homography from two lists of corresponding points.</span>
<a name="l00052"></a>00052 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">This function returns the homography that maps the points from a source position to a</span>
<a name="l00055"></a>00055 <span class="comment">destination position, according to a projective transformation.</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">@deprecated Use @ref ComputeProjectiveHomography instead</span>
<a name="l00058"></a>00058 <span class="comment">@param sourcePoints list of source points.</span>
<a name="l00059"></a>00059 <span class="comment">@param destinationPoints list of destination points.</span>
<a name="l00060"></a>00060 <span class="comment">*/</span>
<a name="l00061"></a>00061 <span class="comment">//QVMatrix ComputeHomography(const QList&lt;QPointF&gt; &amp;sourcePoints, const QList&lt;QPointF&gt; &amp;destPoints);</span>
<a name="l00062"></a>00062 
<a name="l00106"></a>00106 <span class="keywordtype">bool</span> <a class="code" href="group__qvprojectivegeometry.html#ga72b520d418b7835458269a7d803c6668" title="Obtains a planar homography from a list of point correspondences.">computeProjectiveHomography</a>(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="keywordtype">bool</span> computeProjectiveHomography2(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H);
<a name="l00110"></a>00110 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>
<a name="l00120"></a>00120 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#ga72b520d418b7835458269a7d803c6668" title="Obtains a planar homography from a list of point correspondences.">computeProjectiveHomography</a>(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00121"></a>00121 
<a name="l00154"></a>00154 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#gae622eb1823659bb0d8dd9528f22e2f1c" title="Obtains an affine homography from a list of point correspondences.">computeAffineHomography</a>(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00155"></a>00155 
<a name="l00177"></a>00177 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#ga06a3ff264f0821da24ee07ce73c86bd6" title="Obtains a similar homography from a set of inter-image point matchings.">computeSimilarHomography</a>(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="comment">/*</span>
<a name="l00180"></a>00180 <span class="comment">@brief Obtains the fundamental matrix between two images using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Eight-point_algorithm&quot;&gt;8-point algorithm&lt;/a&gt;.</span>
<a name="l00181"></a>00181 <span class="comment"></span>
<a name="l00182"></a>00182 <span class="comment">This function obtains the fundamental matrix that models the epipolar geometry between two images from a set of point correspondences.</span>
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">This function performs a prior normalization of the point projections, to obtain valid and better fundamental matrices.</span>
<a name="l00185"></a>00185 <span class="comment">This normalization includes a correction to move the mean of the point projections to the origin of coordinates, and a posterior whitening.</span>
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment">The code for this function is based on the 8-point algorithm implementation contained in the function &lt;i&gt;cvFindfundamentalMat&lt;/i&gt; from the OpenCV.</span>
<a name="l00188"></a>00188 <span class="comment"></span>
<a name="l00189"></a>00189 <span class="comment">@param matchings list of 8 or more point matchings</span>
<a name="l00190"></a>00190 <span class="comment">@param normalize perform normalization of the coefficient matrix rows independently</span>
<a name="l00191"></a>00191 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00192"></a>00192 <span class="comment">*/</span>
<a name="l00193"></a>00193 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#ga721c81d3a9e9c7c2e09f5867241c7021" title="Obtains the fundamental matrix between two images using the 8-point algorithm.">computeFundamentalMatrix</a>(<span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings, <span class="keyword">const</span> <span class="keywordtype">bool</span> normalize = <span class="keyword">false</span>);
<a name="l00195"></a>00195 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>
<a name="l00209"></a>00209 <span class="preprocessor">#ifdef QVOPENCV</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#ga61fbad744f81531ae01df55e48909a5b" title="Obtains the fundamental matrix between two images, using the 8 point algorithm.">cvFindFundamentalMat</a>(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00211"></a>00211 <span class="preprocessor">#endif // QVOPENCV</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>
<a name="l00230"></a>00230 QPointF <a class="code" href="group__qvprojectivegeometry.html#ga305b04da4d0035c3b4de07ff381b9e1c" title="Maps a point using an homography.">applyHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> QPointF &amp;point);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 
<a name="l00247"></a>00247 QList&lt;QPointF&gt; <a class="code" href="group__qvprojectivegeometry.html#ga305b04da4d0035c3b4de07ff381b9e1c" title="Maps a point using an homography.">applyHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> QList&lt;QPointF&gt; &amp;sourcePoints);
<a name="l00248"></a>00248 
<a name="l00274"></a>00274 <span class="preprocessor">#ifdef QVIPP</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span><a class="code" href="classQVImage.html">QVImage&lt;uChar, 1&gt;</a> <a class="code" href="group__qvprojectivegeometry.html#ga305b04da4d0035c3b4de07ff381b9e1c" title="Maps a point using an homography.">applyHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar, 1&gt;</a> &amp;image, <span class="keyword">const</span> <span class="keywordtype">int</span> interpolation = IPPI_INTER_CUBIC);
<a name="l00276"></a>00276 <span class="preprocessor">#endif // QVIPP</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>
<a name="l00302"></a>00302 <span class="preprocessor">#ifdef QVIPP</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span><a class="code" href="classQVImage.html">QVImage&lt;uChar, 3&gt;</a> <a class="code" href="group__qvprojectivegeometry.html#ga305b04da4d0035c3b4de07ff381b9e1c" title="Maps a point using an homography.">applyHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar, 3&gt;</a> &amp;image, <span class="keyword">const</span> <span class="keywordtype">int</span> interpolation = IPPI_INTER_CUBIC);
<a name="l00304"></a>00304 <span class="preprocessor">#endif // QVIPP</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>
<a name="l00306"></a>00306 <span class="comment">/*</span>
<a name="l00307"></a>00307 <span class="comment">@brief Function to test if a 3x3 matrix corresponds to an homography.</span>
<a name="l00308"></a>00308 <span class="comment"></span>
<a name="l00309"></a>00309 <span class="comment">Every homography matrix corresponding to a perspective deformation from one plane to another should satisfy some constrains. The most important is that its two first columns</span>
<a name="l00310"></a>00310 <span class="comment">should be perpendicular, and with a similar size, because for the matrix to correspond to an homography, they should be contained in a base of a rotated coordinate system.</span>
<a name="l00311"></a>00311 <span class="comment">Given the following homography matrix:</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">\f$ H = \left[ R_1 R_2 -CR^t \right] \f$</span>
<a name="l00314"></a>00314 <span class="comment"></span>
<a name="l00315"></a>00315 <span class="comment">The error value returned by this function for it will be:</span>
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment">\f$ error = \left| \frac{ \|R_1\| - \|R_2\| }{ \|R_1\| + \|R_2\| } \right| + \left| \frac{ R_1 \cdot R_2}{ \|R_1\| \|R_2\| } \right| \f$</span>
<a name="l00318"></a>00318 <span class="comment"></span>
<a name="l00319"></a>00319 <span class="comment">That error is a measure of the difference of sizes between the norm of the two column vectors of the homography, corresponding to the two first columns of the rotation matrix, and their dot product. When both values are close to zero, the matrix corresponds to an homography, and it won&#39;t otherwise.</span>
<a name="l00320"></a>00320 <span class="comment"></span>
<a name="l00321"></a>00321 <span class="comment">A good method to prove that a matrix corresponds to an homography using this function, can be done testing the return value with a threshold of approximately 0.3. If the return value of this function for a matrix is lower than this threshold, that matrix is likely to correspond to an homography, and is not likely to correspond otherwise.</span>
<a name="l00322"></a>00322 <span class="comment"></span>
<a name="l00323"></a>00323 <span class="comment">@param homography a possible homography matrix.</span>
<a name="l00324"></a>00324 <span class="comment">@return a value close to 1 when the matrix does not corresponds to an homography, and close to 0 when it is close to be an homography.</span>
<a name="l00325"></a>00325 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00326"></a>00326 <span class="comment">*/</span>
<a name="l00327"></a>00327 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="keywordtype">double</span> HomographyTestError(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography);
<a name="l00329"></a>00329 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>
<a name="l00331"></a>00331 <span class="comment">/*</span>
<a name="l00332"></a>00332 <span class="comment">@todo write documentation for this function</span>
<a name="l00333"></a>00333 <span class="comment"></span>
<a name="l00334"></a>00334 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00335"></a>00335 <span class="comment">*/</span>
<a name="l00336"></a>00336 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span><span class="keywordtype">void</span> GetExtrinsicCameraMatrixFromHomography(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;K, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M4x4);
<a name="l00338"></a>00338 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span>
<a name="l00340"></a>00340 <span class="comment">/*</span>
<a name="l00341"></a>00341 <span class="comment">@brief Diagonal intrinsic camera matrix calibration</span>
<a name="l00342"></a>00342 <span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment"></span>
<a name="l00344"></a>00344 <span class="comment">This function obtains a diagonal intrinsic camera matrix, consisting on the focal distance only. This matrix is such that</span>
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">\f$ H = K \left[ R | t\right]   \f$</span>
<a name="l00347"></a>00347 <span class="comment"></span>
<a name="l00348"></a>00348 <span class="comment">Where \f$ R \f$ is a rotation matrix. This function returns a direct approximation for the \f$ K \f$ matrix.</span>
<a name="l00349"></a>00349 <span class="comment"></span>
<a name="l00350"></a>00350 <span class="comment">@todo rename to GetDirectCameraIntrinsicsFromPlanarHomography</span>
<a name="l00351"></a>00351 <span class="comment">@see GetIntrinsicCameraMatrixFromHomography</span>
<a name="l00352"></a>00352 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00353"></a>00353 <span class="comment">*/</span>
<a name="l00354"></a>00354 <span class="comment">//void GetDirectIntrinsicCameraMatrixFromHomography(const QVMatrix &amp;H, QVMatrix &amp;K);</span>
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">/*</span>
<a name="l00357"></a>00357 <span class="comment">@brief Diagonal intrinsic camera matrix calibration</span>
<a name="l00358"></a>00358 <span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">This function obtains a diagonal intrinsic camera matrix, consisting on the focal distance only. This matrix is such that</span>
<a name="l00360"></a>00360 <span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">\f$ H = K \left[ R | t\right]   \f$</span>
<a name="l00362"></a>00362 <span class="comment"></span>
<a name="l00363"></a>00363 <span class="comment">Where \f$ R \f$ is a rotation matrix. This matrix is obtained with a minimization process, so its result is more precise than that obtained with @ref GetDirectIntrinsicCameraMatrixFromHomography function.</span>
<a name="l00364"></a>00364 <span class="comment"></span>
<a name="l00365"></a>00365 <span class="comment">@see GetDirectIntrinsicCameraMatrixFromHomography</span>
<a name="l00366"></a>00366 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00367"></a>00367 <span class="comment">*/</span>
<a name="l00368"></a>00368 <span class="comment">//void GetIntrinsicCameraMatrixFromHomography(const QVMatrix &amp;H, QVMatrix &amp;K,</span>
<a name="l00369"></a>00369 <span class="comment">//      double focal = 3, const double maxFocal = 50, const int maxIterations = 100, const double maxError = 0.00001);</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="comment">/*</span>
<a name="l00372"></a>00372 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00373"></a>00373 <span class="comment">@todo write documentation for this function</span>
<a name="l00374"></a>00374 <span class="comment">*/</span>
<a name="l00375"></a>00375 <span class="comment">//void CalibrateCameraFromPlanarHomography(const QVMatrix &amp;H, QVMatrix &amp;K, QVMatrix &amp;Rt);</span>
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">/*</span>
<a name="l00378"></a>00378 <span class="comment">@brief Obtains the intrinsic camera matrix from a planar homography</span>
<a name="l00379"></a>00379 <span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">This functions obtains the intrinsic calibration matrix \f$ K \f$ corresponding to a simple pinhole camera model. The intrinsic camera matrix has only one free parameter, related to the focal distance of the camera:</span>
<a name="l00381"></a>00381 <span class="comment"></span>
<a name="l00382"></a>00382 <span class="comment">\f$</span>
<a name="l00383"></a>00383 <span class="comment">K = \left(\begin{array}{ccc}</span>
<a name="l00384"></a>00384 <span class="comment">f       &amp; 0     &amp; 0     \\</span>
<a name="l00385"></a>00385 <span class="comment">0       &amp; f     &amp; 0     \\</span>
<a name="l00386"></a>00386 <span class="comment">0       &amp; 0     &amp; 1     \\</span>
<a name="l00387"></a>00387 <span class="comment">\end{array}\right)</span>
<a name="l00388"></a>00388 <span class="comment">\f$</span>
<a name="l00389"></a>00389 <span class="comment"></span>
<a name="l00390"></a>00390 <span class="comment">This function should receive a planar homography corresponding to the mapping of a set of know template points, to an image frame captured with the camera containing a view of that template.</span>
<a name="l00391"></a>00391 <span class="comment"></span>
<a name="l00392"></a>00392 <span class="comment">The following is an example of a full intrinsic camera calibration, knowing a set of point matchings between the template image and the input image read from the camera:</span>
<a name="l00393"></a>00393 <span class="comment"></span>
<a name="l00394"></a>00394 <span class="comment">@code</span>
<a name="l00395"></a>00395 <span class="comment">[...]</span>
<a name="l00396"></a>00396 <span class="comment">QList&lt; QPointFMatching &gt; matchings;</span>
<a name="l00397"></a>00397 <span class="comment">matchings.append(QPointFMatching(QPointF(-171,109),     QPointF(-100,+100)));</span>
<a name="l00398"></a>00398 <span class="comment">matchings.append(QPointFMatching(QPointF(-120,31),      QPointF(-100,-100)));</span>
<a name="l00399"></a>00399 <span class="comment">matchings.append(QPointFMatching(QPointF(117,53),       QPointF(+100,-100)));</span>
<a name="l00400"></a>00400 <span class="comment">matchings.append(QPointFMatching(QPointF(11,115),       QPointF(+100,+100)));</span>
<a name="l00401"></a>00401 <span class="comment"></span>
<a name="l00402"></a>00402 <span class="comment">QVMatrix H, K;</span>
<a name="l00403"></a>00403 <span class="comment">H = ComputeProjectiveHomography(matchings);</span>
<a name="l00404"></a>00404 <span class="comment">GetPinholeCameraIntrinsicsFromPlanarHomography(H, K);</span>
<a name="l00405"></a>00405 <span class="comment">[...]</span>
<a name="l00406"></a>00406 <span class="comment">@endcode</span>
<a name="l00407"></a>00407 <span class="comment"></span>
<a name="l00408"></a>00408 <span class="comment">For further understanding of the planar homography calibration process, see @ref ComputeProjectiveHomography function documentation.</span>
<a name="l00409"></a>00409 <span class="comment"></span>
<a name="l00410"></a>00410 <span class="comment">@param H                        Input planar homography.</span>
<a name="l00411"></a>00411 <span class="comment">@param K                        Matrix to store the intrinsic camera matrix</span>
<a name="l00412"></a>00412 <span class="comment">@param iterations               Cumber of iterations to perform camera calibration</span>
<a name="l00413"></a>00413 <span class="comment">@param maxGradientNorm          Minimal value of the gradient size (norm 2) to stop the minimization when reached.</span>
<a name="l00414"></a>00414 <span class="comment">@param step                     Corresponds to parameter &lt;i&gt;step&lt;/i&gt; for the &lt;i&gt;gsl_multimin_fdfminimizer_set&lt;/i&gt; function.</span>
<a name="l00415"></a>00415 <span class="comment">@param tol                      Corresponds to parameter &lt;i&gt;tol&lt;/i&gt; for the &lt;i&gt;gsl_multimin_fdfminimizer_set&lt;/i&gt; function.</span>
<a name="l00416"></a>00416 <span class="comment"></span>
<a name="l00417"></a>00417 <span class="comment">@return a value close to 1 when the matrix does not correspond to an homography, and close to 0 when it is close to be an homography.</span>
<a name="l00418"></a>00418 <span class="comment">@see ComputeProjectiveHomography</span>
<a name="l00419"></a>00419 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00420"></a>00420 <span class="comment">*/</span>
<a name="l00421"></a>00421 <span class="comment">//void GetPinholeCameraIntrinsicsFromPlanarHomography(  const QVMatrix &amp;H, QVMatrix &amp;K, const int iterations = 100,</span>
<a name="l00422"></a>00422 <span class="comment">//                                                      const double maxGradientNorm = 1e-3, const double step = 0.01, const double tol = 1e-4);</span>
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="comment">/*</span>
<a name="l00425"></a>00425 <span class="comment">@brief Obtains the canonical matrices corresponding to an essential matrix</span>
<a name="l00426"></a>00426 <span class="comment"></span>
<a name="l00427"></a>00427 <span class="comment">See section 9.6.2 from &lt;i&gt;Multiple View Geometry in Computer Vision&lt;/i&gt;.</span>
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment">@param E The input essential matrix.</span>
<a name="l00430"></a>00430 <span class="comment">@return A list containing the possible canonical camera matrices.</span>
<a name="l00431"></a>00431 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00432"></a>00432 <span class="comment"></span>
<a name="l00433"></a>00433 <span class="comment">@deprecated Use @ref getCameraPosesFromEssentialMatrix instead.</span>
<a name="l00434"></a>00434 <span class="comment">*/</span>
<a name="l00435"></a>00435 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>QList&lt;QVMatrix&gt; getCanonicalCameraMatricesFromEssentialMatrix(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;E);
<a name="l00437"></a>00437 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>
<a name="l00439"></a>00439 <span class="comment">// TODO: document this function.</span>
<a name="l00440"></a>00440 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="keywordtype">bool</span> getCorrectCameraPoseTestingCheirality(<span class="keyword">const</span> <a class="code" href="group__qvmath.html#ga818fe0c689af956cd14431148c879718">QPointFMatching</a> matching, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R2, <span class="keyword">const</span> <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> t, <span class="keywordtype">bool</span> &amp;R1IsCorrect, <span class="keywordtype">bool</span> &amp;tIsPossitive);
<a name="l00442"></a>00442 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span>
<a name="l00471"></a>00471 <span class="keywordtype">void</span> <a class="code" href="group__qvprojectivegeometry.html#ga017edd807b040c198a02733e4b81e1df" title="Decomposes an essential matrix and obtains the corresponding pair of camera poses...">getCameraPosesFromEssentialMatrix</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;E, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R1, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R2, <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> &amp;t);
<a name="l00472"></a>00472 
<a name="l00490"></a>00490 <span class="keywordtype">bool</span> <a class="code" href="group__qvprojectivegeometry.html#ga5b7c05c6c12bb5c005f00cd838fd436b" title="Tests if two camera poses satisfy the cheirality condition for the reconstruction...">testCheiralityForCameraPoses</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;sourceRt, <span class="keyword">const</span> QPointF &amp;sourceProjection, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;destRt, <span class="keyword">const</span> QPointF &amp;destProjection);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="comment">/*</span>
<a name="l00493"></a>00493 <span class="comment">@brief Obtains the essential matrix corresponding to a canonical camera matrix</span>
<a name="l00494"></a>00494 <span class="comment"></span>
<a name="l00495"></a>00495 <span class="comment">This method estimates the essential matrix of a two view scenario, provided the second camera matrix \f$ P_2 \f$, considering the first camera matrix as the identity: \f$ P_1 = \left[ I | 0 \right] \f$</span>
<a name="l00496"></a>00496 <span class="comment">See section 9.6.1 from &lt;i&gt;Multiple View Geometry in Computer Vision&lt;/i&gt;.</span>
<a name="l00497"></a>00497 <span class="comment"></span>
<a name="l00498"></a>00498 <span class="comment">@param P The input canonical matrix.</span>
<a name="l00499"></a>00499 <span class="comment">@return The essential matrix corresponding to P.</span>
<a name="l00500"></a>00500 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00501"></a>00501 <span class="comment">*/</span>
<a name="l00502"></a>00502 <span class="comment">//QVMatrix getEssentialMatrixFromCanonicalCameraMatrix(const QVMatrix &amp;P);</span>
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span><a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> getCameraMatrixFrom2D3DPointCorrespondences(<span class="keyword">const</span> QList&lt;QPointF&gt; &amp;points2d, <span class="keyword">const</span> QList&lt;QV3DPointF&gt; &amp;points3d);
<a name="l00506"></a>00506 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span>
<a name="l00508"></a>00508 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span><a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> triangulate3DPointFromNViews(<span class="keyword">const</span> QList&lt;QPointF&gt; &amp;points, <span class="keyword">const</span> QList&lt;QVMatrix&gt; &amp;Plist);
<a name="l00510"></a>00510 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00511"></a>00511 <span class="preprocessor"></span>
<a name="l00512"></a>00512 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00513"></a>00513 <span class="preprocessor"></span><a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> triangulate3DPointFrom2Views(<span class="keyword">const</span> QPointF &amp;point1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P1, <span class="keyword">const</span> QPointF &amp;point2, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P2);
<a name="l00514"></a>00514 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span>
<a name="l00516"></a>00516 <span class="comment">/*</span>
<a name="l00517"></a>00517 <span class="comment">@brief Eliminates errors in the rotation component of a canonical camera matrix using a QR decomposition</span>
<a name="l00518"></a>00518 <span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">Function @ref refineExtrinsicCameraMatrixWithPolarDecomposition(const QVMatrix &amp;) obtains a valid canonical camera</span>
<a name="l00520"></a>00520 <span class="comment">matrix &lt;i&gt;P = [R|t]&lt;/i&gt; from a given initial approximation &lt;i&gt;P* = [R*|t*]&lt;/i&gt;, using the Polar decomposition.</span>
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">This function obtains a computationally more efficient approximation of the &lt;i&gt;P&lt;/i&gt; matrix using a QR decomposition.</span>
<a name="l00523"></a>00523 <span class="comment">The rotation matrix &lt;i&gt;R&lt;/i&gt; of the resulting &lt;i&gt;P&lt;/i&gt; is not the closest rotation matrix to the initial &lt;i&gt;R*&lt;/i&gt;</span>
<a name="l00524"></a>00524 <span class="comment">regarding the Frobenius norm \f$ ||R-R*||_F \f$.</span>
<a name="l00525"></a>00525 <span class="comment"></span>
<a name="l00526"></a>00526 <span class="comment">Despite of that, this function can be used when a faster and slightly less accurate version of the best &lt;i&gt;P&lt;/i&gt; is wanted.</span>
<a name="l00527"></a>00527 <span class="comment"></span>
<a name="l00528"></a>00528 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00529"></a>00529 <span class="comment">*/</span>
<a name="l00530"></a>00530 <span class="comment">//QVMatrix refineExtrinsicCameraMatrixWithQRDecomposition(const QVMatrix &amp;P);</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="comment">/*</span>
<a name="l00533"></a>00533 <span class="comment">@brief Eliminates errors in the rotation component of a canonical camera matrix using a Polar decomposition</span>
<a name="l00534"></a>00534 <span class="comment"></span>
<a name="l00535"></a>00535 <span class="comment">Given a matrix &lt;i&gt;P* = [R*|t*]&lt;/i&gt; which approximates a canonical camera matrix, this function obtains the closest</span>
<a name="l00536"></a>00536 <span class="comment">valid canonical matrix \f$ P = [R|t]\f$. The rotation matrix of this valid canonical matrix must be an orthogonal matrix.</span>
<a name="l00537"></a>00537 <span class="comment">Thus it must fulfill:</span>
<a name="l00538"></a>00538 <span class="comment"></span>
<a name="l00539"></a>00539 <span class="comment">        \f$ R^T R = I \f$</span>
<a name="l00540"></a>00540 <span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment">This function uses a correcting square 3x3 matrix &lt;i&gt;E&lt;sup&gt;-1&lt;/sup&gt;&lt;/i&gt; that satisfies the following equation:</span>
<a name="l00542"></a>00542 <span class="comment"></span>
<a name="l00543"></a>00543 <span class="comment">        \f$ E^-1 P* = P (1) \f$</span>
<a name="l00544"></a>00544 <span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment">This matrix &lt;i&gt;E&lt;sup&gt;-1&lt;/sup&gt;&lt;/i&gt; also satisfies that the matrix &lt;i&gt;R&lt;/i&gt; is the rotation matrix closest to &lt;i&gt;R*&lt;/i&gt;</span>
<a name="l00546"></a>00546 <span class="comment">in a certain sense. Using the polar decomposition of &lt;i&gt;R*&lt;/i&gt;, the function obtains the &lt;i&gt;E&lt;/i&gt; which corrects it</span>
<a name="l00547"></a>00547 <span class="comment">to the closest valid rotation matrix &lt;i&gt;R&lt;/i&gt; regarding the Frobenius norm \f$ ||R-R*||_F \f$.</span>
<a name="l00548"></a>00548 <span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">The polar decomposition of the transpose of matrix &lt;i&gt;R*&lt;/i&gt; is the following:</span>
<a name="l00550"></a>00550 <span class="comment"></span>
<a name="l00551"></a>00551 <span class="comment">        \f$ R* = D^T U^T \f$</span>
<a name="l00552"></a>00552 <span class="comment"></span>
<a name="l00553"></a>00553 <span class="comment">Where &lt;i&gt;U&lt;/i&gt; is a rotation matrix and &lt;i&gt;D&lt;/i&gt; is a positive-semidefinite Hermitian matrix. The matrix</span>
<a name="l00554"></a>00554 <span class="comment">&lt;i&gt;D&lt;sup&gt;T&lt;/sup&gt;&lt;/i&gt; is used as the matrix &lt;i&gt;E&lt;/i&gt;.</span>
<a name="l00555"></a>00555 <span class="comment"></span>
<a name="l00556"></a>00556 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00557"></a>00557 <span class="comment">*/</span>
<a name="l00558"></a>00558 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span><a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> refineExtrinsicCameraMatrixWithPolarDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P);
<a name="l00560"></a>00560 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>
<a name="l00562"></a>00562 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00563"></a>00563 
<a name="l00580"></a>00580 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvprojectivegeometry.html#gae1435ef34731a4088d1c45deab3d3ba5" title="Obtains the camera matrix from a set of correspondences between 3D points and their...">linearCameraResection</a>(<span class="keyword">const</span> QList&lt;QPointF&gt; &amp;points2d, <span class="keyword">const</span> QList&lt;QV3DPointF&gt; &amp;points3d);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 <span class="comment">/*</span>
<a name="l00583"></a>00583 <span class="comment">@brief Obtains the center of the camera from its rotation and a set of correspondences between 3D points and their respective image projections</span>
<a name="l00584"></a>00584 <span class="comment"></span>
<a name="l00585"></a>00585 <span class="comment">This method provides a full camera resection by estimating the camera center, provided its as a rotation matrix \f$ R \f$. </span>
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">@param R Rotation matrix for the camera orientation.</span>
<a name="l00588"></a>00588 <span class="comment">@param points2d List containing the points from the image.</span>
<a name="l00589"></a>00589 <span class="comment">@param points3d List containing the 3D points.</span>
<a name="l00590"></a>00590 <span class="comment">@return The camera center.</span>
<a name="l00591"></a>00591 <span class="comment">@ingroup qvprojectivegeometry</span>
<a name="l00592"></a>00592 <span class="comment">*/</span>
<a name="l00593"></a>00593 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span><a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> <a class="code" href="qvprojective_8cpp.html#aefe2c68264497da296129eb3c0cc8ed4">linearCameraCenterResection</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> QList&lt;QPointF&gt; &amp;points2D, <span class="keyword">const</span> QList&lt;QV3DPointF&gt; &amp;points3D);
<a name="l00595"></a>00595 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span>
<a name="l00608"></a>00608 <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> <a class="code" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef" title="Recovers the location of a 3D point from its projection on several views, and their...">linear3DPointTriangulation</a>(<span class="keyword">const</span> QVector&lt;QVMatrix&gt; &amp;cameraMatrices, <span class="keyword">const</span> QHash&lt;int, QPointF&gt; &amp;projectionsOfAPoint, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00609"></a>00609 
<a name="l00627"></a>00627 <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> <a class="code" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef" title="Recovers the location of a 3D point from its projection on several views, and their...">linear3DPointTriangulation</a>(<span class="keyword">const</span> QList&lt;QVMatrix&gt; &amp;cameraMatrices, <span class="keyword">const</span> QList&lt;QPointF&gt; &amp;projectionsOfAPoint, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00628"></a>00628 
<a name="l00649"></a>00649 <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> <a class="code" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef" title="Recovers the location of a 3D point from its projection on several views, and their...">linear3DPointTriangulation</a>(<span class="keyword">const</span> QPointF &amp;point1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P1, <span class="keyword">const</span> QPointF &amp;point2, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P2, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00650"></a>00650 
<a name="l00669"></a>00669 <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> <a class="code" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef" title="Recovers the location of a 3D point from its projection on several views, and their...">linear3DPointTriangulation</a>(<span class="keyword">const</span> <a class="code" href="group__qvmath.html#ga818fe0c689af956cd14431148c879718">QPointFMatching</a> &amp;matching, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P2, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00670"></a>00670 
<a name="l00689"></a>00689 <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> <a class="code" href="group__qvprojectivegeometry.html#ga1d52c9946346c83aea79f1f2311b44ef" title="Recovers the location of a 3D point from its projection on several views, and their...">linear3DPointTriangulation</a>(<span class="keyword">const</span> <a class="code" href="group__qvmath.html#ga818fe0c689af956cd14431148c879718">QPointFMatching</a> &amp;matching, <span class="keyword">const</span> <a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a> &amp;pose1, <span class="keyword">const</span> <a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a> &amp;pose2, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00690"></a>00690 
<a name="l00703"></a>00703 QList&lt;QV3DPointF&gt; <a class="code" href="group__qvprojectivegeometry.html#ga145fc6ee66fb884fa959a00400744570" title="Recovers the location of several 3D points from their projections on different views...">linear3DPointsTriangulation</a>(<span class="keyword">const</span> QList&lt;QVEuclideanMapping3&gt; &amp;cameras, <span class="keyword">const</span> QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointProjections, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00704"></a>00704 
<a name="l00717"></a>00717 QList&lt;QV3DPointF&gt; <a class="code" href="group__qvprojectivegeometry.html#ga145fc6ee66fb884fa959a00400744570" title="Recovers the location of several 3D points from their projections on different views...">linear3DPointsTriangulation</a>(<span class="keyword">const</span> QList&lt;QVEuclideanMapping3&gt; &amp;cameras, <span class="keyword">const</span> QVector&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointProjections, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00718"></a>00718 
<a name="l00731"></a>00731 QList&lt;QV3DPointF&gt; <a class="code" href="group__qvprojectivegeometry.html#ga145fc6ee66fb884fa959a00400744570" title="Recovers the location of several 3D points from their projections on different views...">linear3DPointsTriangulation</a>(<span class="keyword">const</span> QList&lt;QVCameraPose&gt; &amp;cameras, <span class="keyword">const</span> QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointProjections, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00732"></a>00732 
<a name="l00745"></a>00745 QList&lt;QV3DPointF&gt; <a class="code" href="group__qvprojectivegeometry.html#ga145fc6ee66fb884fa959a00400744570" title="Recovers the location of several 3D points from their projections on different views...">linear3DPointsTriangulation</a>(<span class="keyword">const</span> QList&lt;QVCameraPose&gt; &amp;cameras, <span class="keyword">const</span> QVector&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointProjections, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method = DEFAULT_TQVSVD_METHOD);
<a name="l00746"></a>00746 
<a name="l00790"></a>00790 <span class="preprocessor">#include &lt;qvnumericalanalysis.h&gt;</span>
<a name="l00791"></a>00791 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span><span class="keywordtype">bool</span> <a class="code" href="group__qvprojectivegeometry.html#gabb623dbd849917dc8f20dbcbf775ff22" title="Estimates the focal lengths for two cameras,.">getCameraFocals</a>(   <span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings,
<a name="l00793"></a>00793                         <span class="keywordtype">double</span> &amp;focal1, <span class="keywordtype">double</span> &amp;focal2,
<a name="l00794"></a>00794                         <span class="keyword">const</span> QPointF principalPoint1 = QPointF(0.0, 0.0),
<a name="l00795"></a>00795                         <span class="keyword">const</span> QPointF principalPoint2 = QPointF(0.0, 0.0),
<a name="l00796"></a>00796                         <span class="keyword">const</span> <a class="code" href="group__qvnumericalanalysis.html#gad24495d3074466956a7da56fabf2d0e7" title="GSL multidimensional minimization algorithms using gradient information.">GSLMultiminFDFMinimizerType</a> gslMinimizerAlgorithm = <a class="code" href="group__qvnumericalanalysis.html#ggad24495d3074466956a7da56fabf2d0e7a1af5c2e022b228fc7e5b331e6d335c4b" title="Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm.">VectorBFGS</a>,
<a name="l00797"></a>00797                         <span class="keyword">const</span> <span class="keywordtype">int</span> optimizationIterations = 50);
<a name="l00798"></a>00798 <span class="preprocessor">#endif // GSL_AVAILABLE</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span>
<a name="l00800"></a>00800 
<a name="l00834"></a>00834 <span class="keywordtype">double</span> <a class="code" href="group__qvprojectivegeometry.html#gafebb00bc1698d22fdb6875a6a5d70c24" title="Compute camera focal from a planar homography.">computeCameraFocalFromPlanarHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">bool</span> byzero = <span class="keyword">false</span>);
<a name="l00835"></a>00835 
<a name="l00844"></a>00844 <a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a> <a class="code" href="group__qvprojectivegeometry.html#ga53841f2498e0f94b889bac1134135e43" title="Estimates the camera pose form the intrinsic calibration and a planar homography...">getCameraPoseFromCalibratedHomography</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp; K, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp; H);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00847"></a>00847 <span class="preprocessor"></span>
<a name="l00848"></a>00848 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00849"></a>00849         GEA_DO_NOT_DECOMPOSE,           
<a name="l00850"></a>00850         GEA_CHOLESKY_DECOMPOSITION,     
<a name="l00851"></a>00851         GEA_EIGEN_DECOMPOSITION         
<a name="l00852"></a>00852         } TGEA_decomposition_method;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> get8PointsCoefficientMatrix(<span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings, <span class="keyword">const</span> <span class="keywordtype">bool</span> normalize = <span class="keyword">true</span>);
<a name="l00855"></a>00855 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> getTransposeProductOf8PointsCoefficientMatrix(<span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings, <span class="keyword">const</span> <span class="keywordtype">bool</span> normalize = <span class="keyword">true</span>);
<a name="l00856"></a>00856 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> getReduced8PointsCoefficientsMatrix(   <span class="comment">// Input matching list.</span>
<a name="l00857"></a>00857                                                 <span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchingsList,
<a name="l00858"></a>00858                                                 <span class="comment">// Method for decomposition.</span>
<a name="l00859"></a>00859                                                 <span class="keyword">const</span> TGEA_decomposition_method decomposition_method = GEA_CHOLESKY_DECOMPOSITION,
<a name="l00860"></a>00860                                                 <span class="comment">// Perform pre-normalization of the point matchings</span>
<a name="l00861"></a>00861                                                 <span class="keyword">const</span> <span class="keywordtype">bool</span> normalize = <span class="keyword">true</span>,
<a name="l00862"></a>00862                                                 <span class="comment">// GSL should be faster, but more prone to errors.</span>
<a name="l00863"></a>00863                                                 <span class="keyword">const</span> <span class="keywordtype">bool</span> gsl= <span class="keyword">true</span>,
<a name="l00864"></a>00864                                                 <span class="comment">// Value to increase diagonal elements prior to Cholesky decomposition.</span>
<a name="l00865"></a>00865                                                 <span class="comment">// Important to avoid non-positive definite matrix errors.</span>
<a name="l00866"></a>00866                                                 <span class="keyword">const</span> <span class="keywordtype">double</span> choleskyLambda = 0.0);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 QList&lt;QPointFMatching&gt; applyHomographies(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;H2, <span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings);
<a name="l00869"></a>00869 QList&lt;QPointFMatching&gt; correctIntrinsics(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;K1, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;K2, <span class="keyword">const</span> QList&lt;QPointFMatching&gt; &amp;matchings);
<a name="l00870"></a>00870 QList&lt; QHash&lt; int, QPointF&gt; &gt; correctIntrinsics(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;K, <span class="keyword">const</span> QList&lt; QHash&lt; int, QPointF&gt; &gt; &amp;pointsProjections);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="keyword">class </span>QVCalibrationErrorFunction: <span class="keyword">public</span> <a class="code" href="classQVFunction.html" title="Base class for function objects.">QVFunction</a>&lt;QVVector, double&gt;
<a name="l00873"></a>00873         {
<a name="l00874"></a>00874         <span class="keyword">private</span>:
<a name="l00875"></a>00875                 <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> F;
<a name="l00876"></a>00876                 <span class="keywordtype">double</span> <a class="code" href="classQVFunction.html#a547d70580fc6ca0c97cb299958f8c85d" title="Virtual method implementing the code for the function evaluation.">evaluate</a>(<span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878         <span class="keyword">public</span>:
<a name="l00879"></a>00879                 QVCalibrationErrorFunction(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;F);
<a name="l00880"></a>00880         };
<a name="l00881"></a>00881 <span class="preprocessor">#endif // DOXYGEN_IGNORE_THIS</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>
<a name="l00883"></a>00883 <span class="comment">// Deprecated functions</span>
<a name="l00884"></a>00884 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>QPointF ApplyHomography(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> QPointF &amp;point);
<a name="l00886"></a>00886 QList&lt;QPointF&gt; ApplyHomography(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> QList&lt;QPointF&gt; &amp;sourcePoints);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="preprocessor">#ifdef QVIPP</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span><a class="code" href="classQVImage.html">QVImage&lt;uChar, 1&gt;</a> ApplyHomography(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar, 1&gt;</a> &amp;image, <span class="keyword">const</span> <span class="keywordtype">int</span> interpolation = IPPI_INTER_CUBIC);
<a name="l00890"></a>00890 <a class="code" href="classQVImage.html">QVImage&lt;uChar, 3&gt;</a> ApplyHomography(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;homography, <span class="keyword">const</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar, 3&gt;</a> &amp;image, <span class="keyword">const</span> <span class="keywordtype">int</span> interpolation = IPPI_INTER_CUBIC);
<a name="l00891"></a>00891 <span class="preprocessor">#endif</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span>
<a name="l00893"></a>00893 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> ComputeSimilarHomography(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00894"></a>00894 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> ComputeAffineHomography(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00895"></a>00895 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> ComputeProjectiveHomography(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00896"></a>00896 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> ComputeEuclideanHomography(<span class="keyword">const</span> QList&lt; QPointFMatching &gt; &amp;matchings);
<a name="l00897"></a>00897 <span class="preprocessor">#endif // QVIPP</span>
<a name="l00898"></a>00898 <span class="preprocessor"></span>
<a name="l00899"></a>00899 <span class="preprocessor">#endif //  QVPROJECTIVE_H</span>
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
