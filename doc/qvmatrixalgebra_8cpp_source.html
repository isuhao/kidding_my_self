<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvmath/qvmatrixalgebra.cpp</h1><a href="qvmatrixalgebra_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;qvmath.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="qvdefines_8h.html" title="File from the QVision library.">qvdefines.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="qvmath_2qvmatrixalgebra_8h.html" title="File from the QVision library.">qvmath/qvmatrixalgebra.h</a>&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">/*#define dgesvd dgesvd</span>
<a name="l00033"></a>00033 <span class="comment">#define dgesdd dgesdd</span>
<a name="l00034"></a>00034 <span class="comment">#define dpotrf dpotrf</span>
<a name="l00035"></a>00035 <span class="comment">#define dgeqrf cblas_dgeqrf</span>
<a name="l00036"></a>00036 <span class="comment">#define dgetrf cblas_dgetrf</span>
<a name="l00037"></a>00037 <span class="comment">#define dorgqr cblas_dorgqr</span>
<a name="l00038"></a>00038 <span class="comment">#define dsyev  dsyev*/</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef MKL_AVAILABLE</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="comment">// #include &lt;mkl_lapack.h&gt;</span>
<a name="l00042"></a>00042 <span class="comment">// #include &lt;mkl_blas.h&gt;</span>
<a name="l00043"></a>00043 <span class="comment">// #include &lt;mkl_dss.h&gt;</span>
<a name="l00044"></a>00044 <span class="comment">// #include &lt;mkl_rci.h&gt;</span>
<a name="l00045"></a>00045 <span class="comment">// #include &lt;mkl_spblas.h&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#define CHECK_MKL_DSS_ERROR \</span>
<a name="l00048"></a>00048 <span class="preprocessor">    if (error != MKL_DSS_SUCCESS) { \</span>
<a name="l00049"></a>00049 <span class="preprocessor">        std::cout &lt;&lt; &quot;Solver returned error code &quot; &lt;&lt; error &lt;&lt; std::endl; \</span>
<a name="l00050"></a>00050 <span class="preprocessor">        exit(1); \</span>
<a name="l00051"></a>00051 <span class="preprocessor">    }</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="preprocessor">#elif LAPACK_AVAILABLE  // Only with non-MKL LAPACK</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor"> #define dgesvd dgesvd_</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor"> #define dgesdd dgesdd_</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor"> #define dpotrf dpotrf_</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor"> #define dgeqrf dgeqrf_</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor"> #define dgetrf dgetrf_</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor"> #define dorgqr dorgqr_</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor"> #define dsyev  dsyev_</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00062"></a>00062    <span class="keywordtype">void</span> dgesvd(<span class="keywordtype">char</span> *jobu,<span class="keywordtype">char</span> *jobvt, <span class="keywordtype">int</span> *m, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">double</span> *s, <span class="keywordtype">double</span> *u, <span class="keywordtype">int</span> *ldu,
<a name="l00063"></a>00063                <span class="keywordtype">double</span> *vt, <span class="keywordtype">int</span> *ldvt, <span class="keywordtype">double</span> *work, <span class="keywordtype">int</span> *lwork, <span class="keywordtype">int</span> *info );
<a name="l00064"></a>00064    <span class="keywordtype">void</span> dgesdd(<span class="keywordtype">char</span> *jobz, <span class="keywordtype">int</span> *m, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">double</span> *s, <span class="keywordtype">double</span> *u, <span class="keywordtype">int</span> *ldu, <span class="keywordtype">double</span> *vt,
<a name="l00065"></a>00065                <span class="keywordtype">int</span> *ldvt, <span class="keywordtype">double</span> *work, <span class="keywordtype">int</span> *lwork, <span class="keywordtype">int</span> *iwork, <span class="keywordtype">int</span> *info );
<a name="l00066"></a>00066    <span class="keywordtype">void</span> dpotrf(<span class="keywordtype">char</span> *uplo, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">int</span> *info );
<a name="l00067"></a>00067    <span class="keywordtype">void</span> dgeqrf(<span class="keywordtype">int</span> *m, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">double</span> *tau, <span class="keywordtype">double</span> *work, <span class="keywordtype">int</span> *lwork, <span class="keywordtype">int</span> *info );
<a name="l00068"></a>00068    <span class="keywordtype">void</span> dgetrf(<span class="keywordtype">int</span> *m, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">int</span> *ipiv, <span class="keywordtype">int</span> *info );
<a name="l00069"></a>00069    <span class="keywordtype">void</span> dorgqr(<span class="keywordtype">int</span> *m, <span class="keywordtype">int</span> *n, <span class="keywordtype">int</span> *k, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">double</span> *tau, <span class="keywordtype">double</span> *work, <span class="keywordtype">int</span> *lwork, <span class="keywordtype">int</span> *info );
<a name="l00070"></a>00070    <span class="keywordtype">void</span> dsyev(<span class="keywordtype">char</span> *jobz, <span class="keywordtype">char</span> *uplo, <span class="keywordtype">int</span> *n, <span class="keywordtype">double</span> *a, <span class="keywordtype">int</span> *lda, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *work, <span class="keywordtype">int</span> *lwork, <span class="keywordtype">int</span> *info );
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 <span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>
<a name="l00074"></a>00074 <span class="preprocessor">#ifdef QVCHOLMOD</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#include &lt;QVCholmodSolver&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#endif</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#include &lt;QVPermutation&gt;</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keywordtype">void</span> singularValueDecomposition_internal(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V,
<a name="l00081"></a>00081                                          <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method, <span class="keywordtype">bool</span> only_singular_values = <span class="keyword">false</span>)
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083     <span class="keywordtype">int</span> m = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00084"></a>00084     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b">GSL_THIN_DECOMP_MOD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f">GSL_THIN_DECOMP</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a43eb44439df1e8e6797917e721016774">GSL_THIN_DECOMP_JACOBI</a>) {
<a name="l00085"></a>00085 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>        <span class="keywordtype">bool</span> transposed = FALSE;
<a name="l00087"></a>00087         gsl_matrix *u, *v;
<a name="l00088"></a>00088         gsl_vector *ss;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         <span class="keywordflow">if</span>(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() &gt; M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>())
<a name="l00091"></a>00091             transposed = TRUE;
<a name="l00092"></a>00092         <span class="keyword">const</span> <span class="keywordtype">int</span> dim2 = (transposed ? M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>():M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>());
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         <span class="comment">// First, we must decompose M, using GSL structures.</span>
<a name="l00095"></a>00095         u = (transposed ? M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() : M);
<a name="l00096"></a>00096         ss = gsl_vector_alloc (dim2);
<a name="l00097"></a>00097         v = gsl_matrix_alloc (dim2, dim2);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b">GSL_THIN_DECOMP_MOD</a>) {
<a name="l00100"></a>00100             gsl_vector *work = gsl_vector_alloc (dim2);
<a name="l00101"></a>00101             gsl_matrix *XX = gsl_matrix_alloc (dim2,dim2);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103             gsl_linalg_SV_decomp_mod(u, XX, v, ss, work);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105             gsl_vector_free(work);
<a name="l00106"></a>00106             gsl_matrix_free(XX);
<a name="l00107"></a>00107         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f">GSL_THIN_DECOMP</a>) {
<a name="l00108"></a>00108             gsl_vector *work = gsl_vector_alloc (dim2);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110             gsl_linalg_SV_decomp(u, v, ss, work);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112             gsl_vector_free(work);
<a name="l00113"></a>00113         } <span class="keywordflow">else</span> { <span class="comment">// method == GSL_THIN_DECOMP_JACOBI)</span>
<a name="l00114"></a>00114             gsl_linalg_SV_decomp_jacobi(u, v, ss);
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="comment">// We must assign GSL structures to output s vector and U, V matrices:</span>
<a name="l00118"></a>00118         <span class="keywordflow">if</span> (not only_singular_values) U = u;
<a name="l00119"></a>00119         s = ss;
<a name="l00120"></a>00120         <span class="keywordflow">if</span> (not only_singular_values) V = v;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="keywordflow">if</span>(not only_singular_values and transposed) {
<a name="l00123"></a>00123             <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> inter = U;
<a name="l00124"></a>00124             U = V;
<a name="l00125"></a>00125             V = inter;
<a name="l00126"></a>00126         }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="comment">// Finally, we free u, s and v GSL structures:</span>
<a name="l00129"></a>00129         gsl_matrix_free(u);
<a name="l00130"></a>00130         gsl_vector_free(ss);
<a name="l00131"></a>00131         gsl_matrix_free(v);
<a name="l00132"></a>00132 <span class="preprocessor">#else</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;SVD decomposition: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l00134"></a>00134 <span class="preprocessor">#endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c">LAPACK_FULL_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e">LAPACK_FULL_DGESDD</a> or
<a name="l00136"></a>00136                method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>) {
<a name="l00137"></a>00137 <span class="preprocessor">#ifdef LAPACK_AVAILABLE</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>        <span class="comment">// First, we must decompose M, using LAPACK structures.</span>
<a name="l00139"></a>00139         <span class="keyword">const</span> <span class="keywordtype">char</span> *jobu = <span class="stringliteral">&quot;A&quot;</span>,*jobvt = <span class="stringliteral">&quot;A&quot;</span>;
<a name="l00140"></a>00140         <span class="comment">// Copy M matrix, because LAPACK routines destroy original matrix, and</span>
<a name="l00141"></a>00141         <span class="comment">// transpose it, because of FORTRAN way of store matrices in memory.</span>
<a name="l00142"></a>00142         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> MM = M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00143"></a>00143         <span class="keywordtype">int</span> ldu, ldvt, lwork, res;
<a name="l00144"></a>00144         QVector&lt;int&gt; iwork(8*qMin(m,n));
<a name="l00145"></a>00145         <span class="keywordtype">double</span> *mptr = MM.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00146"></a>00146         <span class="keywordtype">int</span> *iworkptr = iwork.data();
<a name="l00147"></a>00147 
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (only_singular_values) {
<a name="l00149"></a>00149              jobu = <span class="stringliteral">&quot;N&quot;</span>;
<a name="l00150"></a>00150              jobvt = <span class="stringliteral">&quot;N&quot;</span>;
<a name="l00151"></a>00151              U = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(1,1);
<a name="l00152"></a>00152              V = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(1,1);
<a name="l00153"></a>00153              ldu = 1;
<a name="l00154"></a>00154              ldvt = 1;
<a name="l00155"></a>00155         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c">LAPACK_FULL_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e">LAPACK_FULL_DGESDD</a>) {
<a name="l00156"></a>00156             jobu = <span class="stringliteral">&quot;A&quot;</span>;
<a name="l00157"></a>00157             jobvt = <span class="stringliteral">&quot;A&quot;</span>;
<a name="l00158"></a>00158             U = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m,m);
<a name="l00159"></a>00159             V = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(n,n);
<a name="l00160"></a>00160             ldu = m;
<a name="l00161"></a>00161             ldvt = n;
<a name="l00162"></a>00162         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>) {
<a name="l00163"></a>00163             jobu = <span class="stringliteral">&quot;S&quot;</span>;
<a name="l00164"></a>00164             jobvt = <span class="stringliteral">&quot;S&quot;</span>;
<a name="l00165"></a>00165             <span class="comment">// Because of FORTRAN transposition:</span>
<a name="l00166"></a>00166             U = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(qMin(m,n),m);
<a name="l00167"></a>00167             V = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(n,qMin(m,n));
<a name="l00168"></a>00168             ldu = m ;
<a name="l00169"></a>00169             ldvt = qMin(m,n);
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         s = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(qMin(m,n));
<a name="l00173"></a>00173         <span class="keywordtype">double</span> *sptr=s.data(), *uptr=U.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(), *vptr=V.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(), *workptr, ans;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="comment">// Ask for optimal lwork:</span>
<a name="l00176"></a>00176         lwork = -1;
<a name="l00177"></a>00177         <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c">LAPACK_FULL_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a>)
<a name="l00178"></a>00178             dgesvd(const_cast&lt;char*&gt;(jobu),const_cast&lt;char*&gt;(jobvt),
<a name="l00179"></a>00179                    &amp;m,&amp;n,mptr,&amp;m,sptr,uptr,&amp;ldu,vptr,&amp;ldvt,&amp;ans,&amp;lwork,&amp;res);
<a name="l00180"></a>00180         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e">LAPACK_FULL_DGESDD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>)
<a name="l00181"></a>00181             dgesdd(const_cast&lt;char*&gt;(jobu),
<a name="l00182"></a>00182                    &amp;m,&amp;n,mptr,&amp;m,sptr,uptr,&amp;ldu,vptr,&amp;ldvt,&amp;ans,&amp;lwork,iworkptr,&amp;res);
<a name="l00183"></a>00183         lwork = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(ans));
<a name="l00184"></a>00184         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> work(lwork);
<a name="l00185"></a>00185         workptr = work.data();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="comment">// Compute SVD:</span>
<a name="l00188"></a>00188         <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a777aea4370fc3929a00ac3e224508f4c">LAPACK_FULL_DGESVD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a>)
<a name="l00189"></a>00189             dgesvd(const_cast&lt;char*&gt;(jobu),const_cast&lt;char*&gt;(jobvt),
<a name="l00190"></a>00190                    &amp;m,&amp;n,mptr,&amp;m,sptr,uptr,&amp;ldu,vptr,&amp;ldvt,workptr,&amp;lwork,&amp;res);
<a name="l00191"></a>00191         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1686a8461eac2faae7a21c744ac2d05e">LAPACK_FULL_DGESDD</a> or method == <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>)
<a name="l00192"></a>00192             dgesdd(const_cast&lt;char*&gt;(jobu),
<a name="l00193"></a>00193                    &amp;m,&amp;n,mptr,&amp;m,sptr,uptr,&amp;ldu,vptr,&amp;ldvt,workptr,&amp;lwork,iworkptr,&amp;res);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         <span class="comment">// Finally, we transpose U (but not V):</span>
<a name="l00196"></a>00196         <span class="keywordflow">if</span>(not only_singular_values)
<a name="l00197"></a>00197             U = U.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00198"></a>00198 <span class="preprocessor">#else</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;SVD decomposition: cannot use LAPACK methods if MKL, ATLAS or LAPACK BASE are not available.&quot;</span>);
<a name="l00200"></a>00200 <span class="preprocessor">#endif</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    }
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb">00204</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     singularValueDecomposition_internal(M, U, s, V, method);
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keywordtype">void</span> SingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;S, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> s;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SingularValueDecomposition&#39; DEPRECATED, use &#39;singularValueDecomposition&#39; instead\n&quot;</span>;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     singularValueDecomposition_internal(M, U, s, V, method);
<a name="l00216"></a>00216     S = <a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(s);
<a name="l00217"></a>00217     <span class="keyword">const</span> <span class="keywordtype">int</span> m = U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(), n = V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00218"></a>00218     <span class="keywordflow">if</span> (m&gt;n)
<a name="l00219"></a>00219         S = S &amp; <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m-n,n,0.0);
<a name="l00220"></a>00220     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m&lt;n)
<a name="l00221"></a>00221         S = S | <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m,n-m,0.0);
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a><a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351">00224</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226     X = U.<a class="code" href="classQVMatrix.html#a5470e61c2827d5485596c3901690154c" title="Matrix-matrix product.">dotProduct</a>(B,<span class="keyword">true</span>,<span class="keyword">false</span>);
<a name="l00227"></a>00227     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;s.size();i++)
<a name="l00228"></a>00228         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;X.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();j++)
<a name="l00229"></a>00229             X(i,j) /= s[i];
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="keyword">const</span> <span class="keywordtype">int</span> m = U.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = V.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (U.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() and U.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>()) <span class="comment">// Full decomposition.</span>
<a name="l00233"></a>00233         <span class="keywordflow">if</span> (m&gt;n)
<a name="l00234"></a>00234             X = V.<a class="code" href="classQVMatrix.html#a5470e61c2827d5485596c3901690154c" title="Matrix-matrix product.">dotProduct</a>(X.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,n-1),<span class="keyword">false</span>,<span class="keyword">false</span>);
<a name="l00235"></a>00235         <span class="keywordflow">else</span>
<a name="l00236"></a>00236             X = V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(0,m-1).dotProduct(X,<span class="keyword">false</span>,<span class="keyword">false</span>);
<a name="l00237"></a>00237     <span class="keywordflow">else</span> <span class="comment">// Thin decomposition.</span>
<a name="l00238"></a>00238         X = V.<a class="code" href="classQVMatrix.html#a5470e61c2827d5485596c3901690154c" title="Matrix-matrix product.">dotProduct</a>(X,<span class="keyword">false</span>,<span class="keyword">false</span>);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="group__qvmatrixalgebra.html#gad74c5a3f06b0c9c72148b44e31264c1c">00241</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X <span class="comment">/*= x.toColumnMatrix()*/</span>, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U, s, V, X, B);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     x = X;
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00250"></a><a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada">00250</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U_dummy, V_dummy, X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00253"></a>00253     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> s_dummy;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     singularValueDecomposition_internal(M, U_dummy, s_dummy, V_dummy, method);
<a name="l00256"></a>00256     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U_dummy, s_dummy, V_dummy, X, B);
<a name="l00257"></a>00257     x = X;
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a><a class="code" href="group__qvmatrixalgebra.html#ga8ee6615a4f3e6751e0eedf6128267af8">00260</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U_dummy, V_dummy;
<a name="l00263"></a>00263     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> s_dummy;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     singularValueDecomposition_internal(M, U_dummy, s_dummy, V_dummy, method);
<a name="l00266"></a>00266     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U_dummy, s_dummy, V_dummy, X, B);
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00269"></a><a class="code" href="group__qvmatrixalgebra.html#gaeb13fad2bc51086f94ac91464d29a0ea">00269</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b,
<a name="l00270"></a>00270                                        <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     singularValueDecomposition_internal(M, U, s, V, method);
<a name="l00275"></a>00275     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U, s, V, X, B);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     x = X;
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a><a class="code" href="group__qvmatrixalgebra.html#ga5209fc0ff91662f73a505f094689dfa6">00280</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B,
<a name="l00281"></a>00281                                        <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283     singularValueDecomposition_internal(M, U, s, V, method);
<a name="l00284"></a>00284     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U, s, V, X, B);
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 
<a name="l00287"></a><a class="code" href="group__qvmatrixalgebra.html#ga78792d4a8a6337b8b92a86a07ede57ac">00287</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga78792d4a8a6337b8b92a86a07ede57ac" title="Checks for correctness of the SVD of a matrix.">singularValueDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V)
<a name="l00288"></a>00288 {
<a name="l00289"></a>00289     <span class="comment">// Create diagonal matrix from singular values (adding rows or columns of additional zeros if needed):</span>
<a name="l00290"></a>00290     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> S = <a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(s);
<a name="l00291"></a>00291     <span class="keywordtype">int</span> m = U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(), n = V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00292"></a>00292     <span class="keywordflow">if</span> (m&gt;n)
<a name="l00293"></a>00293         S = S &amp; <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m-n,n,0.0);
<a name="l00294"></a>00294     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m&lt;n)
<a name="l00295"></a>00295         S = S | QVMatrix(m,n-m,0.0);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordtype">double</span> res1 = (U*S*V.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()-M).norm2();
<a name="l00298"></a>00298     <span class="keywordtype">double</span> res2 = (U.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()*U - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>())).norm2();
<a name="l00299"></a>00299     <span class="keywordtype">double</span> res3 = (V.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()*V - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>())).norm2();
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="keywordflow">return</span> res1 + res2 + res3;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a><a class="code" href="group__qvmatrixalgebra.html#ga5d6aa6239753252830669883619f5da7">00304</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga5d6aa6239753252830669883619f5da7" title="Gets the singular values of a matrix.">singularValues</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0" title="Available methods for Singular Values only computation (SV).">TQVSV_Method</a> method)
<a name="l00305"></a>00305 {
<a name="l00306"></a>00306     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U_dummy, V_dummy;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aec23f378cb62ec5c9647fe24d8b4ab37">GSL_ONLY_DECOMP_MOD</a>)
<a name="l00309"></a>00309         singularValueDecomposition_internal(M, U_dummy, s, V_dummy,
<a name="l00310"></a>00310                                             <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a1f02b2cbeb2e75cb9309c6f66ff83e8b">GSL_THIN_DECOMP_MOD</a>, <span class="keyword">true</span>);
<a name="l00311"></a>00311     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0af7facc299fdba1379bd6ba8acd863125">GSL_ONLY_DECOMP</a>)
<a name="l00312"></a>00312         singularValueDecomposition_internal(M, U_dummy, s, V_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575af5312552984123e0a709bc75f52c008f">GSL_THIN_DECOMP</a>, <span class="keyword">true</span>);
<a name="l00313"></a>00313     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aae6dd5f0dbab3b0f4d55ad5fb711b6cd">GSL_ONLY_DECOMP_JACOBI</a>)
<a name="l00314"></a>00314         singularValueDecomposition_internal(M, U_dummy, s, V_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a43eb44439df1e8e6797917e721016774">GSL_THIN_DECOMP_JACOBI</a>, <span class="keyword">true</span>);
<a name="l00315"></a>00315     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0a07c014f720d296deab282e63cf84897d">LAPACK_ONLY_DGESVD</a>)
<a name="l00316"></a>00316         singularValueDecomposition_internal(M, U_dummy, s, V_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575ab3bda2bf5279aa36fbc167a0cb434b85">LAPACK_THIN_DGESVD</a>, <span class="keyword">true</span>);
<a name="l00317"></a>00317     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae838fb93502416d5876dd38769e3c5a0aa99ca829614308fcefd46e2d828dff67">LAPACK_ONLY_DGESDD</a>)
<a name="l00318"></a>00318         singularValueDecomposition_internal(M, U_dummy, s, V_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggad753ba41cd08df7e8d4173d8c2ac2575a846c64f2016e7d97bda4ceb14b545372">LAPACK_THIN_DGESDD</a>, <span class="keyword">true</span>);
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a><a class="code" href="group__qvmatrixalgebra.html#ga7e4b10036a1a456b58ffcb0ad0e30d52">00321</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga7e4b10036a1a456b58ffcb0ad0e30d52" title="Checks for correctness of the singular values of a matrix.">singularValuesResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323     <span class="keywordtype">double</span> acum1 = 0.0, acum2 = 0.0;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment">// Squared Frobenius norm of matrix should be equal to sum of squared singular values:</span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();i++)
<a name="l00328"></a>00328         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();j++)
<a name="l00329"></a>00329         acum1 += M(i,j)*M(i,j);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;s.size();i++)
<a name="l00332"></a>00332         acum2 += s[i]*s[i];
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <span class="keywordflow">return</span> qAbs(acum1-acum2);
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keywordtype">void</span> CholeskyDecomposition_internal(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggac52aa1a4772c42c68e53baf5a22e15c8ad805bb0106a0bbf7eea0549f4a5525d1">GSL_CHOLESKY</a>) {
<a name="l00343"></a>00343 <span class="preprocessor">    #ifdef GSL_AVAILABLE</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         gsl_matrix *a = M;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348         gsl_linalg_cholesky_decomp(a);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         L = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(n,n);
<a name="l00351"></a>00351         <span class="keywordtype">double</span>  *dataL = L.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00354"></a>00354             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00355"></a>00355                 <span class="keywordflow">if</span> (j &lt;= i)
<a name="l00356"></a>00356                     dataL[i*n+j] = a-&gt;data[i*n+j];
<a name="l00357"></a>00357                 <span class="keywordflow">else</span>
<a name="l00358"></a>00358                     dataL[i*n+j] = 0;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         gsl_matrix_free(a);
<a name="l00361"></a>00361 <span class="preprocessor">    #else</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>            qFatal(<span class="stringliteral">&quot;Cholesky decomposition: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l00363"></a>00363 <span class="preprocessor">    #endif</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggac52aa1a4772c42c68e53baf5a22e15c8a80e13036cfa7096deb292e1b197459bf">LAPACK_CHOLESKY_DPOTRF</a>) {
<a name="l00365"></a>00365 <span class="preprocessor">    #ifdef LAPACK_AVAILABLE</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span> *uplo = <span class="stringliteral">&quot;L&quot;</span>;
<a name="l00367"></a>00367         <span class="keywordtype">int</span> n = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), lda = n, res;
<a name="l00368"></a>00368         L = M;
<a name="l00369"></a>00369         <span class="keywordtype">double</span> *lptr = L.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00370"></a>00370         dpotrf(const_cast&lt;char*&gt;(uplo),&amp;n,lptr,&amp;lda,&amp;res);
<a name="l00371"></a>00371         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;n;i++)
<a name="l00372"></a>00372             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;i;j++)
<a name="l00373"></a>00373                 L(i,j) = 0.0;
<a name="l00374"></a>00374         L = L.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00375"></a>00375 <span class="preprocessor">    #else</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>            qFatal(<span class="stringliteral">&quot;Cholesky decomposition: cannot use LAPACK methods if MKL, ATLAS of LAPACK BASE not available.&quot;</span>);
<a name="l00377"></a>00377 <span class="preprocessor">    #endif</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>    }
<a name="l00379"></a>00379     L.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999ab550fa0060215d15361dfc059a2c19db" title="Lower triangular matrix.">QVMatrix::LowerTriangular</a>);
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a><a class="code" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932">00382</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gab845aa50ce874199ad7676904829b932" title="Obtains the Cholesky decomposition of a symmetric and positive definite matrix.">CholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00383"></a>00383 {
<a name="l00384"></a>00384     CholeskyDecomposition_internal(M, L, method);
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76">00387</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X_inter;
<a name="l00390"></a>00390     L.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(B,X_inter,<span class="keyword">false</span>);
<a name="l00391"></a>00391     L.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter,X,<span class="keyword">true</span>);
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a><a class="code" href="group__qvmatrixalgebra.html#gaed3915fd119f48853adcb72010e6cd09">00394</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X <span class="comment">/*= x.toColumnMatrix()*/</span>, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L, X, B);
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     x = X;
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a><a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de">00403</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> L_dummy;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     CholeskyDecomposition_internal(M, L_dummy, method);
<a name="l00408"></a>00408     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L_dummy, X, B);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a><a class="code" href="group__qvmatrixalgebra.html#ga067556526a2c186f723d887a30658402">00412</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> L_dummy, X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     CholeskyDecomposition_internal(M, L_dummy, method);
<a name="l00417"></a>00417     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L_dummy, X, B);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     x = X;
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a><a class="code" href="group__qvmatrixalgebra.html#ga0092ee2d02048fb7eb478af02bc6b9ff">00422</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B,
<a name="l00423"></a>00423                                 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425     CholeskyDecomposition_internal(M, L, method);
<a name="l00426"></a>00426     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L, X, B);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a><a class="code" href="group__qvmatrixalgebra.html#ga806c89d90cce22d877df1f18fa9689f5">00430</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b,
<a name="l00431"></a>00431                                 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     CholeskyDecomposition_internal(M, L, method);
<a name="l00436"></a>00436     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L, X, B);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     x = X;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a><a class="code" href="group__qvmatrixalgebra.html#gab24bc732bdada660cceccecd98a4a5f2">00441</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#gab24bc732bdada660cceccecd98a4a5f2" title="Checks for correctness of the Cholesky decomposition of a matrix.">CholeskyDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00444"></a>00444     Q_ASSERT(L.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == L.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00445"></a>00445     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == L.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     <span class="keywordflow">return</span> (L * L.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() - M).norm2();
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keywordtype">void</span> LUDecomposition_internal(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453     <span class="keywordtype">int</span> m = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga3b29cddbb2d5f75b1278f8a6d4abd736ac377c182c3ec3cc88190908e82e05aef">GSL_LU</a>) {
<a name="l00456"></a>00456 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(m != n)
<a name="l00458"></a>00458             qFatal(<span class="stringliteral">&quot;LU decomposition: GSL_LU method works only on square matrices.&quot;</span>);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460         gsl_matrix *a = M;
<a name="l00461"></a>00461         gsl_permutation *p = gsl_permutation_alloc(m);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <span class="keywordtype">int</span> signum;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         gsl_linalg_LU_decomp(a, p, &amp;signum);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         P = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m, m, 0.0);
<a name="l00468"></a>00468         L = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m, m);
<a name="l00469"></a>00469         U = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m, m);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keywordtype">double</span>  *dataL = L.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(),
<a name="l00472"></a>00472                 *dataU = U.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(),
<a name="l00473"></a>00473                 *dataP = P.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; i++)
<a name="l00476"></a>00476             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++)
<a name="l00477"></a>00477                 <span class="keywordflow">if</span> (j &gt; i) {
<a name="l00478"></a>00478                     dataU[i*m + j] = a-&gt;data[i*m+j];
<a name="l00479"></a>00479                     dataL[i*m + j] = 0;
<a name="l00480"></a>00480                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j &lt; i) {
<a name="l00481"></a>00481                     dataU[i*m + j] = 0;
<a name="l00482"></a>00482                     dataL[i*m + j] = a-&gt;data[i*m+j];
<a name="l00483"></a>00483                 } <span class="keywordflow">else</span> { <span class="comment">// Diagonal:</span>
<a name="l00484"></a>00484                     dataU[i*m + j] = a-&gt;data[i*m+j];
<a name="l00485"></a>00485                     dataL[i*m + j] = 1;
<a name="l00486"></a>00486                 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++)
<a name="l00489"></a>00489                 dataP[(p-&gt;data[j])*m + j] = 1;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         gsl_matrix_free(a);
<a name="l00492"></a>00492         gsl_permutation_free(p);
<a name="l00493"></a>00493 <span class="preprocessor">#else</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span>    qFatal(<span class="stringliteral">&quot;LU decomposition: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l00495"></a>00495 <span class="preprocessor">#endif</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga3b29cddbb2d5f75b1278f8a6d4abd736a6ced16c7e295a05f04ae431e76530e43">LAPACK_DGETRF</a>) {
<a name="l00497"></a>00497 <span class="preprocessor">#ifdef LAPACK_AVAILABLE</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lda = m, res;
<a name="l00499"></a>00499         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> MT = M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>(); <span class="comment">// Because of FORTRAN transposition.</span>
<a name="l00500"></a>00500         <span class="keywordtype">double</span> *mtptr = MT.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00501"></a>00501         QVector&lt;int&gt; ipiv(m);
<a name="l00502"></a>00502         <span class="keywordtype">int</span> *ipivptr = ipiv.data();
<a name="l00503"></a>00503 
<a name="l00504"></a>00504         dgetrf(&amp;m,&amp;n,mtptr,&amp;lda,ipivptr,&amp;res);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         P = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m, m, 0.0);
<a name="l00507"></a>00507         L = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m, m&gt;n?n:m, 0.0);
<a name="l00508"></a>00508         U = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m&gt;n?n:m, n, 0.0);
<a name="l00509"></a>00509         <span class="keyword">const</span> <span class="keywordtype">int</span> lm = L.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), ln = L.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(), um = U.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), un=U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00510"></a>00510 
<a name="l00511"></a>00511         <span class="keywordtype">double</span>  *dataL = L.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(),
<a name="l00512"></a>00512                 *dataU = U.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         <span class="comment">// Extraction of L matrix from (overwritten) result:</span>
<a name="l00515"></a>00515         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; lm; i++)
<a name="l00516"></a>00516             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ln; j++)
<a name="l00517"></a>00517                 <span class="keywordflow">if</span> (j &lt; i)
<a name="l00518"></a>00518                     dataL[i*ln + j] = mtptr[j*m+i];
<a name="l00519"></a>00519                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j==i) <span class="comment">// Diagonal:</span>
<a name="l00520"></a>00520                     dataL[i*ln + j] = 1;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         <span class="comment">// Extraction of U matrix:</span>
<a name="l00523"></a>00523         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; um; i++)
<a name="l00524"></a>00524             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; un; j++)
<a name="l00525"></a>00525                 <span class="keywordflow">if</span> (j &gt; i)
<a name="l00526"></a>00526                     dataU[i*un + j] = mtptr[j*m+i];
<a name="l00527"></a>00527                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j==i) <span class="comment">// Diagonal:</span>
<a name="l00528"></a>00528                     dataU[i*un + j] = mtptr[j*m+i];
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="comment">// Permutation, as returned by LAPACK:</span>
<a name="l00531"></a>00531         QVector&lt;int&gt; perm(m);
<a name="l00532"></a>00532         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; i++)
<a name="l00533"></a>00533             perm[i] = i;
<a name="l00534"></a>00534         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; i++)
<a name="l00535"></a>00535             <span class="keywordflow">if</span>(ipivptr[i] != 0) {
<a name="l00536"></a>00536                 <span class="keywordtype">int</span> inter = perm[i];
<a name="l00537"></a>00537                 perm[i] = perm[ipivptr[i]-1]; <span class="comment">// FORTRAN indexes arrays from 1..n, not 0..n-1</span>
<a name="l00538"></a>00538                 perm[ipivptr[i]-1] = inter;
<a name="l00539"></a>00539             }
<a name="l00540"></a>00540         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; i++)
<a name="l00541"></a>00541             P(perm[i],i) = 1;
<a name="l00542"></a>00542 <span class="preprocessor">#else</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;LU decomposition: cannot use LAPACK methods if MKL, ATLAS of LAPACK BASE not available.&quot;</span>);
<a name="l00544"></a>00544 <span class="preprocessor">#endif</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span>        }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         L.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999ab550fa0060215d15361dfc059a2c19db" title="Lower triangular matrix.">QVMatrix::LowerTriangular</a>);
<a name="l00548"></a>00548         U.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00549"></a>00549         P.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a68fb1d9ef0f816e806f50414659deb80" title="Permutation matrix.">QVMatrix::PermutationMatrix</a>);
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf">00552</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf" title="Obtains the LU decomposition of a rectangular  matrix.">LUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554     LUDecomposition_internal(M, P, L, U, method);
<a name="l00555"></a>00555 }
<a name="l00556"></a>00556 
<a name="l00557"></a><a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076">00557</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559     <span class="keyword">const</span> <span class="keywordtype">int</span> m = L.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00560"></a>00560     <span class="keywordflow">if</span>(m&gt;n)
<a name="l00561"></a>00561         qFatal(<span class="stringliteral">&quot;LU decomposition: cannot be used to solve overdetermined (m&gt;n) systems of equations.&quot;</span>);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X_inter, B_inter;
<a name="l00564"></a>00564     B_inter = P.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() * B;
<a name="l00565"></a>00565     L.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(B_inter,X_inter,<span class="keyword">false</span>,<span class="keyword">true</span>);
<a name="l00566"></a>00566     <span class="comment">// Also works: L.triangularSolve(B_inter,X_inter,false,true);</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">if</span>(m==n) {
<a name="l00569"></a>00569         U.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter,X,<span class="keyword">false</span>);
<a name="l00570"></a>00570     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m &lt; n) {
<a name="l00571"></a>00571         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U_inter = U.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(0,m-1);
<a name="l00572"></a>00572         U_inter.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00573"></a>00573         U_inter.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter,X,<span class="keyword">false</span>);
<a name="l00574"></a>00574         X = X &amp; <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(n-m,X.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(),0.0); <span class="comment">// Adds rows of zeros in unused variables.</span>
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a><a class="code" href="group__qvmatrixalgebra.html#gad8bfbb08c8abc180fc75d1c95cd384b2">00578</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l00579"></a>00579 {
<a name="l00580"></a>00580     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X <span class="comment">/*= x.toColumnMatrix()*/</span>, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P, L, U, X, B);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     x = X;
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a><a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c">00587</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00588"></a>00588 {
<a name="l00589"></a>00589     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> P_dummy, L_dummy, U_dummy;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     LUDecomposition_internal(M, P_dummy, L_dummy, U_dummy, method);
<a name="l00592"></a>00592     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P_dummy, L_dummy, U_dummy, X, B);
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a><a class="code" href="group__qvmatrixalgebra.html#gab8d289ba74af9334d85562f62f51ebf9">00595</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00596"></a>00596 {
<a name="l00597"></a>00597     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> P_dummy, L_dummy, U_dummy, X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     LUDecomposition_internal(M, P_dummy, L_dummy, U_dummy, method);
<a name="l00600"></a>00600     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P_dummy, L_dummy, U_dummy, X, B);
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     x = X;
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a><a class="code" href="group__qvmatrixalgebra.html#ga8f32485d24aa4e57caeb3d441c74413c">00605</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B,
<a name="l00606"></a>00606                                 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608     LUDecomposition_internal(M, P, L, U, method);
<a name="l00609"></a>00609     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P, L, U, X, B);
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 
<a name="l00613"></a><a class="code" href="group__qvmatrixalgebra.html#ga4b46c4e87f6ed2d6864770250d4975ea">00613</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b,
<a name="l00614"></a>00614                                 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l00615"></a>00615 {
<a name="l00616"></a>00616     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     LUDecomposition_internal(M, P, L, U, method);
<a name="l00619"></a>00619     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P, L, U, X, B);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     x = X;
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a><a class="code" href="group__qvmatrixalgebra.html#ga88586226df85602c9e139b6d4ee1fbcb">00624</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga88586226df85602c9e139b6d4ee1fbcb" title="Checks for correctness of the LU decomposition of a matrix.">LUDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U)
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626     <span class="keywordflow">return</span> (P*L*U - M).norm2();
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keywordtype">void</span> QRDecomposition_internal(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632     <span class="keywordtype">int</span> m = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a17474e8b41843fa89de4b33a88cf3ed4">GSL_HOUSEHOLDER_THIN_QR</a> or method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532">GSL_HOUSEHOLDER_FULL_QR</a>) {
<a name="l00635"></a>00635 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l00636"></a>00636 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> min = (m&lt;n ? m:n);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         gsl_matrix *a = M;
<a name="l00639"></a>00639         gsl_matrix *q, *r;
<a name="l00640"></a>00640         <span class="keywordflow">if</span>(m&lt;n or method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532">GSL_HOUSEHOLDER_FULL_QR</a>) {
<a name="l00641"></a>00641             q = gsl_matrix_alloc(m, m);
<a name="l00642"></a>00642             r = gsl_matrix_alloc(m, n);
<a name="l00643"></a>00643         } <span class="keywordflow">else</span> { <span class="comment">// m&gt;=n and method == GSL_HOUSEHOLDER_THIN_QR</span>
<a name="l00644"></a>00644             q = gsl_matrix_alloc(m, n);
<a name="l00645"></a>00645             r = gsl_matrix_alloc(n, n);
<a name="l00646"></a>00646         }
<a name="l00647"></a>00647         gsl_vector *tau = gsl_vector_alloc(min);
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         gsl_linalg_QR_decomp(a, tau);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         <span class="keywordflow">if</span>(m&lt;n or method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a052f682a71e7b5e52ae3767b8ccf1532">GSL_HOUSEHOLDER_FULL_QR</a>) {
<a name="l00652"></a>00652             gsl_linalg_QR_unpack (a, tau, q, r);
<a name="l00653"></a>00653         } <span class="keywordflow">else</span> { <span class="comment">// m&gt;=n and method == GSL_HOUSEHOLDER_THIN_QR</span>
<a name="l00654"></a>00654             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;m; i++)
<a name="l00655"></a>00655                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
<a name="l00656"></a>00656                     <span class="keywordflow">if</span>(i == j)
<a name="l00657"></a>00657                         q-&gt;data[i*n+j] = 1.0; <span class="comment">//gsl_matrix_set(q, i, j, 1.0);</span>
<a name="l00658"></a>00658                     <span class="keywordflow">else</span>
<a name="l00659"></a>00659                         q-&gt;data[i*n+j] = 0.0; <span class="comment">//gsl_matrix_set(q, i, j, 0.0);</span>
<a name="l00660"></a>00660             gsl_vector *v = gsl_vector_alloc(m);
<a name="l00661"></a>00661             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) {
<a name="l00662"></a>00662                 gsl_matrix_get_col(v, q, j);
<a name="l00663"></a>00663                 gsl_linalg_QR_Qvec(a, tau, v);
<a name="l00664"></a>00664                 gsl_matrix_set_col(q, j, v);
<a name="l00665"></a>00665             }
<a name="l00666"></a>00666             gsl_vector_free(v);
<a name="l00667"></a>00667             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l00668"></a>00668                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
<a name="l00669"></a>00669                     <span class="keywordflow">if</span>(j&gt;=i)
<a name="l00670"></a>00670                         r-&gt;data[i*n+j] = gsl_matrix_get(a, i, j); <span class="comment">//gsl_matrix_set(r, i, j, gsl_matrix_get(a, i, j));</span>
<a name="l00671"></a>00671                     <span class="keywordflow">else</span>
<a name="l00672"></a>00672                         r-&gt;data[i*n+j] = 0.0; <span class="comment">//gsl_matrix_set(r, i, j, 0.0);</span>
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         Q = q;
<a name="l00676"></a>00676         R = r;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         gsl_matrix_free(a);
<a name="l00679"></a>00679         gsl_matrix_free(q);
<a name="l00680"></a>00680         gsl_matrix_free(r);
<a name="l00681"></a>00681         gsl_vector_free(tau);
<a name="l00682"></a>00682 <span class="preprocessor">#else</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;QR decomposition: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l00684"></a>00684 <span class="preprocessor">#endif</span>
<a name="l00685"></a>00685 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8">LAPACK_THIN_DGEQR2</a> or method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>) {
<a name="l00686"></a>00686 <span class="preprocessor">#ifdef LAPACK_AVAILABLE</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>        <span class="keywordtype">int</span> lda = m, res, lwork = -1;
<a name="l00688"></a>00688         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> MT = M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>(); <span class="comment">// Because of FORTRAN transposition.</span>
<a name="l00689"></a>00689         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> tau(qMax(m,n));
<a name="l00690"></a>00690         <span class="keywordtype">double</span> *mtptr = MT.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(), *workptr, *tauptr = tau.data(), ans;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="comment">//dgeqr2(&amp;m,&amp;n,mtptr,&amp;lda,tauptr,workptr,&amp;res); // Deprecated, we use now dgeqrf.</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         <span class="comment">// Ask for workspace:</span>
<a name="l00695"></a>00695         <span class="keywordflow">if</span>(m&gt;=n and method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>)
<a name="l00696"></a>00696             dgeqrf(&amp;m,&amp;m,mtptr,&amp;lda,tauptr,&amp;ans,&amp;lwork,&amp;res);
<a name="l00697"></a>00697         <span class="keywordflow">else</span>
<a name="l00698"></a>00698             dgeqrf(&amp;m,&amp;n,mtptr,&amp;lda,tauptr,&amp;ans,&amp;lwork,&amp;res);
<a name="l00699"></a>00699         lwork = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(ans));
<a name="l00700"></a>00700         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> work(lwork);
<a name="l00701"></a>00701         workptr = work.data();
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="comment">// Decomposition:</span>
<a name="l00704"></a>00704         dgeqrf(&amp;m,&amp;n,mtptr,&amp;lda,tauptr,workptr,&amp;lwork,&amp;res);
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         <span class="comment">// Undoing FORTRAN transposition:</span>
<a name="l00707"></a>00707         <span class="keywordflow">if</span>(m&lt;n or method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>)
<a name="l00708"></a>00708             R = MT.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00709"></a>00709         <span class="keywordflow">else</span>
<a name="l00710"></a>00710             R = MT.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,n-1);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         <span class="comment">// We overwrite v vectors on R with 0&#39;s, to create lower triangular matrix.</span>
<a name="l00713"></a>00713         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;R.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();i++)
<a name="l00714"></a>00714             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;qMin(i,R.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>());j++)
<a name="l00715"></a>00715                 R(i,j) = 0.0;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="comment">// The matrix Q is now represented as a product of elementary reflectors</span>
<a name="l00718"></a>00718         <span class="comment">//       Q = H(1) H(2) . . . H(k), where k = min(m,n).</span>
<a name="l00719"></a>00719         <span class="comment">// Each H(i) has the form</span>
<a name="l00720"></a>00720         <span class="comment">//       H(i) = I - tau * v * v&#39;</span>
<a name="l00721"></a>00721         <span class="comment">// where tau is a real scalar, and v is a real vector with v(1:i-1) = 0</span>
<a name="l00722"></a>00722         <span class="comment">// and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i), and tau in TAU(i).</span>
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="comment">/* OLD:</span>
<a name="l00725"></a>00725 <span class="comment">        QVMatrix I = QVMatrix::identity(m);</span>
<a name="l00726"></a>00726 <span class="comment">        Q = I;</span>
<a name="l00727"></a>00727 <span class="comment">        for(int i=0;i&lt;m;i++) {</span>
<a name="l00728"></a>00728 <span class="comment">            QVVector v(m);</span>
<a name="l00729"></a>00729 <span class="comment">            for(int j=0;j&lt;i;j++)</span>
<a name="l00730"></a>00730 <span class="comment">                v(j) = 0.0;</span>
<a name="l00731"></a>00731 <span class="comment">            v(i) = 1.0;</span>
<a name="l00732"></a>00732 <span class="comment">            for(int j=i+1;j&lt;m;j++)</span>
<a name="l00733"></a>00733 <span class="comment">                v(j) = R(j,i);</span>
<a name="l00734"></a>00734 <span class="comment">            Q = Q*(I-tau(i)*(v.toColumnMatrix()*v.toRowMatrix()));</span>
<a name="l00735"></a>00735 <span class="comment">        }*/</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         <span class="comment">// Reconstruction of Q matrix:</span>
<a name="l00738"></a>00738         <span class="keywordflow">if</span>(m&lt;n and method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>) {
<a name="l00739"></a>00739             dorgqr(&amp;m,&amp;m,&amp;m,mtptr,&amp;lda,tauptr,workptr,&amp;lwork,&amp;res);
<a name="l00740"></a>00740             MT = MT.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,m-1);
<a name="l00741"></a>00741         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m&lt;n and method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8">LAPACK_THIN_DGEQR2</a>) {
<a name="l00742"></a>00742             dorgqr(&amp;m,&amp;m,&amp;m,mtptr,&amp;lda,tauptr,workptr,&amp;lwork,&amp;res);
<a name="l00743"></a>00743             MT = MT.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,m-1);
<a name="l00744"></a>00744         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m&gt;=n and method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a5c91dd50e5272c56c5d9a1545ae74919">LAPACK_FULL_DGEQR2</a>) {
<a name="l00745"></a>00745             MT = MT &amp; <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(m-n,m,0.0);
<a name="l00746"></a>00746             mtptr = MT.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l00747"></a>00747             dorgqr(&amp;m,&amp;m,&amp;n,mtptr,&amp;lda,tauptr,workptr,&amp;lwork,&amp;res);
<a name="l00748"></a>00748         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m&gt;=n and method == <a class="code" href="group__qvmatrixalgebra.html#gga34489f7f981fd3ad10dcd6e287644c21a4102acc0d67031755466ca0d736b3dd8">LAPACK_THIN_DGEQR2</a>) {
<a name="l00749"></a>00749             dorgqr(&amp;m,&amp;n,&amp;n,mtptr,&amp;lda,tauptr,workptr,&amp;lwork,&amp;res);
<a name="l00750"></a>00750         }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         Q = MT.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00753"></a>00753 <span class="preprocessor">#else</span>
<a name="l00754"></a>00754 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;QR decomposition: cannot use LAPACK methods if MKL, ATLAS of LAPACK BASE not available.&quot;</span>);
<a name="l00755"></a>00755 <span class="preprocessor">#endif</span>
<a name="l00756"></a>00756 <span class="preprocessor"></span>    }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     R.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a><a class="code" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0">00761</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gadabb7917a1bf7e229a4c7a9b8037b5f0" title="Obtains the QR decomposition of a rectangular  matrix.">QRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00762"></a>00762 {
<a name="l00763"></a>00763     QRDecomposition_internal(M, Q, R, method);
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a><a class="code" href="group__qvmatrixalgebra.html#ga00e06784b460e9b3c4a1377b50b2ccb5">00766</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga00e06784b460e9b3c4a1377b50b2ccb5" title="Checks for correctness of the QR decomposition of a matrix.">QRDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R)
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768     <span class="keywordflow">return</span> (Q*R - M).norm2() + (Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()*Q - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(Q.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>())).norm2();
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a><a class="code" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b">00771</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga2a46051b1a07328de88e5e73710b7f0b" title="Obtains the QL decomposition of a rectangular  matrix.">QLDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00772"></a>00772 {
<a name="l00773"></a>00773     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> M_inter,Q_inter,R_inter;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     M_inter = M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>().<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     QRDecomposition_internal(M_inter, Q_inter, R_inter, method);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     Q = Q_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>().<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00780"></a>00780     L = R_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>().<a class="code" href="classQVMatrix.html#a9987d3595383ca057eeaad815845f00a" title="Gets a matrix with reversed columns (right to left).">reversedCols</a>().<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00781"></a>00781     L.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999ab550fa0060215d15361dfc059a2c19db" title="Lower triangular matrix.">QVMatrix::LowerTriangular</a>);
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a><a class="code" href="group__qvmatrixalgebra.html#ga42e745f3d76515e05ab8c16c24e0056a">00784</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga42e745f3d76515e05ab8c16c24e0056a" title="Checks for correctness of the QL decomposition of a matrix.">QLDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L)
<a name="l00785"></a>00785 {
<a name="l00786"></a>00786     <span class="keywordflow">return</span> (Q*L - M).norm2() + (Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()*Q - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(Q.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>())).norm2();
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00789"></a><a class="code" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718">00789</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gaa825c3d75d892d43c6f20fa3ae909718" title="Obtains the RQ decomposition of a rectangular  matrix.">RQDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00790"></a>00790 {
<a name="l00791"></a>00791     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> M_inter,Q_inter,R_inter;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     M_inter = M.<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>().<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00794"></a>00794 
<a name="l00795"></a>00795     QRDecomposition_internal(M_inter, Q_inter, R_inter, method);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797     Q = Q_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>();
<a name="l00798"></a>00798     R = R_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>().<a class="code" href="classQVMatrix.html#a8c360feaaf1382f1afeae554ca1af5b7" title="Gets a matrix with reversed rows (bottom to top).">reversedRows</a>().<a class="code" href="classQVMatrix.html#a9987d3595383ca057eeaad815845f00a" title="Gets a matrix with reversed columns (right to left).">reversedCols</a>();
<a name="l00799"></a>00799     R.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 
<a name="l00802"></a><a class="code" href="group__qvmatrixalgebra.html#gaa37783c86d91abd724a2eab2cd609ddd">00802</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#gaa37783c86d91abd724a2eab2cd609ddd" title="Checks for correctness of the RQ decomposition of a matrix.">RQDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q)
<a name="l00803"></a>00803 {
<a name="l00804"></a>00804     <span class="keywordflow">return</span> (R*Q - M).norm2() + (Q*Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(Q.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>())).norm2();
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a><a class="code" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392">00807</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gaac2e3437531d9acfec99b6b7ee300392" title="Obtains the LQ decomposition of a rectangular  matrix.">LQDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00808"></a>00808 {
<a name="l00809"></a>00809     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> M_inter,Q_inter,R_inter;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811     M_inter = M.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     QRDecomposition_internal(M_inter, Q_inter, R_inter, method);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     Q = Q_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00816"></a>00816     L = R_inter.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00817"></a>00817     L.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999ab550fa0060215d15361dfc059a2c19db" title="Lower triangular matrix.">QVMatrix::LowerTriangular</a>);
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a><a class="code" href="group__qvmatrixalgebra.html#gabcf3725f2738f4fb4e823d5a7175ecb9">00820</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#gabcf3725f2738f4fb4e823d5a7175ecb9" title="Checks for correctness of the LQ decomposition of a matrix.">LQDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q)
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822     <span class="keywordflow">return</span> (L*Q - M).norm2() + (Q*Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(Q.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>())).norm2();
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a><a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c">00825</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l00826"></a>00826 {
<a name="l00827"></a>00827     <span class="keyword">const</span> <span class="keywordtype">int</span> m = Q.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = R.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X_inter = Q.<a class="code" href="classQVMatrix.html#a5470e61c2827d5485596c3901690154c" title="Matrix-matrix product.">dotProduct</a>(B,<span class="keyword">true</span>,<span class="keyword">false</span>);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831     <span class="keywordflow">if</span>(m == n)
<a name="l00832"></a>00832         R.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter,X,<span class="keyword">false</span>);
<a name="l00833"></a>00833     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m &gt; n) {
<a name="l00834"></a>00834         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R_inter = R.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,n-1);
<a name="l00835"></a>00835         R_inter.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00836"></a>00836         R_inter.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(0,n-1),X,<span class="keyword">false</span>);
<a name="l00837"></a>00837         <span class="comment">//X = X &amp; QVMatrix(n-m,X.getCols(),0.0); // Adds rows of zeros in unused variables.</span>
<a name="l00838"></a>00838     } <span class="keywordflow">else</span> { <span class="comment">// m &lt; n</span>
<a name="l00839"></a>00839         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R_inter = R.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(0,m-1);
<a name="l00840"></a>00840         R_inter.<a class="code" href="classQVMatrix.html#a5ff2ac8ea4e316fc793d32ce09671e8c" title="Set type of the matrix.">setType</a>(<a class="code" href="classQVMatrix.html#a8f4414e6cfd14fe164a164ab20379999a266e723ddafba230f9e674cb61c1a86d" title="Upper triangular matrix.">QVMatrix::UpperTriangular</a>);
<a name="l00841"></a>00841         R_inter.<a class="code" href="classQVMatrix.html#a051fa63dfff104d2705b793b4eb39213" title="Triangular system solving (vector of RHS).">triangularSolve</a>(X_inter,X,<span class="keyword">false</span>);
<a name="l00842"></a>00842         X = X &amp; <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(n-m,X.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(),0.0); <span class="comment">// Adds rows of zeros in unused variables.</span>
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844 }
<a name="l00845"></a>00845 
<a name="l00846"></a><a class="code" href="group__qvmatrixalgebra.html#ga228fdd20d46605f6177054634126320c">00846</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l00847"></a>00847 {
<a name="l00848"></a>00848     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X <span class="comment">/*= x.toColumnMatrix()*/</span>, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00849"></a>00849 
<a name="l00850"></a>00850     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q, R, X, B);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     x = X;
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 
<a name="l00855"></a><a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3">00855</a>  <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> Q_dummy, R_dummy, X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     QRDecomposition_internal(M, Q_dummy, R_dummy, method);
<a name="l00860"></a>00860     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q_dummy, R_dummy, X, B);
<a name="l00861"></a>00861     x = X;
<a name="l00862"></a>00862 }
<a name="l00863"></a>00863 
<a name="l00864"></a><a class="code" href="group__qvmatrixalgebra.html#ga0a31c23838ccb1a35229cda96266c640">00864</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00865"></a>00865 {
<a name="l00866"></a>00866     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> Q_dummy, R_dummy;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868     QRDecomposition_internal(M, Q_dummy, R_dummy, method);
<a name="l00869"></a>00869     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q_dummy, R_dummy, X, B);
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a><a class="code" href="group__qvmatrixalgebra.html#gade60b82ebf24951f074f43c211fd67a3">00872</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00873"></a>00873 {
<a name="l00874"></a>00874     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> X, B = b.<a class="code" href="classQVVector.html#a57387ffc7c1b3ee7de38adb5155d3707" title="Returns this vector in the form of a column matrix.">toColumnMatrix</a>();
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     QRDecomposition_internal(M, Q, R, method);
<a name="l00877"></a>00877     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q, R, X, B);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     x = X;
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 
<a name="l00882"></a><a class="code" href="group__qvmatrixalgebra.html#ga7ec9b2e2693b1e700892e6a4aa6398c3">00882</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l00883"></a>00883 {
<a name="l00884"></a>00884     QRDecomposition_internal(M, Q, R, method);
<a name="l00885"></a>00885     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q, R, X, B);
<a name="l00886"></a>00886 }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keywordtype">void</span> eigenDecomposition_internal(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;eigVals, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;eigVecs, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8" title="Available methods for EigenDecomposition.">TQVEigenDecomposition_Method</a> method, <span class="keywordtype">bool</span> only_ev = <span class="keyword">false</span>)
<a name="l00890"></a>00890                                  <span class="comment">// bool solve, QVMatrix &amp;X, const QVMatrix &amp;B)</span>
<a name="l00891"></a>00891 {
<a name="l00892"></a>00892     <span class="comment">// Check matrix M is symmetric</span>
<a name="l00893"></a>00893     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a26b778a18b5ed84f1c9dea5d8419981e">GSL_EIGENSYMM</a>) {
<a name="l00896"></a>00896 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l00897"></a>00897 <span class="preprocessor"></span>    <span class="comment">//std::cout &lt;&lt; &quot;----------- B --------------&quot; &lt;&lt; std::endl;</span>
<a name="l00898"></a>00898         <span class="keyword">const</span> <span class="keywordtype">int</span> n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l00899"></a>00899         gsl_matrix *m = M;
<a name="l00900"></a>00900         gsl_vector *eval = gsl_vector_alloc (n);
<a name="l00901"></a>00901         gsl_matrix *evec = gsl_matrix_alloc (n, n);
<a name="l00902"></a>00902 
<a name="l00903"></a>00903         <span class="keywordflow">if</span>(only_ev) {
<a name="l00904"></a>00904             gsl_eigen_symm_workspace *w = gsl_eigen_symm_alloc (n);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906             gsl_eigen_symm (m, eval, w);
<a name="l00907"></a>00907             <span class="comment">// evec does not contain here anything useful, but there GSL does not provide a &quot;gsl_eigen_symm_sort&quot; function:</span>
<a name="l00908"></a>00908             gsl_eigen_symmv_sort (eval, evec, GSL_EIGEN_SORT_VAL_DESC);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910             gsl_eigen_symm_free (w);
<a name="l00911"></a>00911         } <span class="keywordflow">else</span> { <span class="comment">// method == GSL_EIGENSYMM_ONLY</span>
<a name="l00912"></a>00912             gsl_eigen_symmv_workspace *w = gsl_eigen_symmv_alloc (n);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914             gsl_eigen_symmv (m, eval, evec, w);
<a name="l00915"></a>00915             gsl_eigen_symmv_sort (eval, evec, GSL_EIGEN_SORT_VAL_DESC);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917             eigVecs = evec;
<a name="l00918"></a>00918             <span class="comment">//eigVecs = eigVecs.transpose();</span>
<a name="l00919"></a>00919 
<a name="l00920"></a>00920             gsl_eigen_symmv_free (w);
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922         eigVals = eval;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         gsl_matrix_free (m);
<a name="l00925"></a>00925         gsl_vector_free (eval);
<a name="l00926"></a>00926         gsl_matrix_free (evec);
<a name="l00927"></a>00927 <span class="preprocessor">#else</span>
<a name="l00928"></a>00928 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;EigenDecomposition: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l00929"></a>00929 <span class="preprocessor">#endif</span>
<a name="l00930"></a>00930 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a7f4f96ab3bd135f5842b0d25bb5d86a1">LAPACK_DSYEV</a>) {
<a name="l00931"></a>00931 <span class="preprocessor">#ifdef LAPACK_AVAILABLE</span>
<a name="l00932"></a>00932 <span class="preprocessor"></span>    <span class="comment">//std::cout &lt;&lt; &quot;----------- A --------------&quot; &lt;&lt; std::endl;</span>
<a name="l00933"></a>00933         <span class="keywordtype">int</span> n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(), lda = n, lwork = -1, res;
<a name="l00934"></a>00934         <span class="keyword">const</span> <span class="keywordtype">char</span> *jobz, *uplo = <span class="stringliteral">&quot;L&quot;</span>;
<a name="l00935"></a>00935         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> oldEigVecs;
<a name="l00936"></a>00936         <span class="keywordflow">if</span>(only_ev) {
<a name="l00937"></a>00937             jobz = <span class="stringliteral">&quot;N&quot;</span>;
<a name="l00938"></a>00938             oldEigVecs = eigVecs;
<a name="l00939"></a>00939         } <span class="keywordflow">else</span> {
<a name="l00940"></a>00940             jobz = <span class="stringliteral">&quot;V&quot;</span>;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         eigVecs = M;
<a name="l00944"></a>00944         eigVals = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(n, 0.0);
<a name="l00945"></a>00945         <span class="keywordtype">double</span> *eigvecsptr = eigVecs.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>(), *w = eigVals.data(), *workptr, ans;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947         <span class="comment">// Ask for adequate quantity of space:</span>
<a name="l00948"></a>00948         dsyev(const_cast&lt;char*&gt;(jobz),const_cast&lt;char*&gt;(uplo),
<a name="l00949"></a>00949               &amp;n, eigvecsptr, &amp;lda, w, &amp;ans, &amp;lwork, &amp;res);
<a name="l00950"></a>00950         lwork = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(ans));
<a name="l00951"></a>00951         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> work(lwork, 0.0);
<a name="l00952"></a>00952         workptr = work.data();
<a name="l00953"></a>00953         <span class="comment">// Compute:</span>
<a name="l00954"></a>00954         dsyev(const_cast&lt;char*&gt;(jobz),const_cast&lt;char*&gt;(uplo),
<a name="l00955"></a>00955               &amp;n, eigvecsptr, &amp;lda, w, workptr, &amp;lwork, &amp;res);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <span class="comment">// Eigenvalues (and corresponding eigenvectors) in decreasing order:</span>
<a name="l00958"></a>00958         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;n/2;i++) {
<a name="l00959"></a>00959             <span class="keywordtype">double</span> inter;
<a name="l00960"></a>00960             inter = eigVals[i];
<a name="l00961"></a>00961             eigVals[i] = eigVals[n-i-1];
<a name="l00962"></a>00962             eigVals[n-i-1] = inter;
<a name="l00963"></a>00963             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;n;j++) {
<a name="l00964"></a>00964                 inter = eigVecs(i,j);
<a name="l00965"></a>00965                 eigVecs(i,j) = eigVecs(n-i-1,j);
<a name="l00966"></a>00966                 eigVecs(n-i-1,j) = inter;
<a name="l00967"></a>00967             }
<a name="l00968"></a>00968         }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         <span class="comment">// We restore &quot;unused&quot; input eigenvectors (if only eigenvalues were asked for)...</span>
<a name="l00971"></a>00971         <span class="keywordflow">if</span>(only_ev)
<a name="l00972"></a>00972             eigVecs = oldEigVecs;
<a name="l00973"></a>00973         <span class="keywordflow">else</span>
<a name="l00974"></a>00974             <span class="comment">// ... or we transpose result to give eigenvectors as rows (undo FORTRAN storing):</span>
<a name="l00975"></a>00975             eigVecs = eigVecs.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>();
<a name="l00976"></a>00976 <span class="preprocessor">#else</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span>    qFatal(<span class="stringliteral">&quot;EigenDecomposition: cannot use LAPACK methods if LAPACK, ATLAS or MKL libraries are not available.&quot;</span>);
<a name="l00978"></a>00978 <span class="preprocessor">#endif</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>    }
<a name="l00980"></a>00980     <span class="comment">/* if(solve) {</span>
<a name="l00981"></a>00981 <span class="comment">        X = eigVecs.dotProduct(B,true,false);</span>
<a name="l00982"></a>00982 <span class="comment">        for(int i=0;i&lt;M.getCols();i++)</span>
<a name="l00983"></a>00983 <span class="comment">            for(int j=0;j&lt;X.getCols();j++)</span>
<a name="l00984"></a>00984 <span class="comment">                X(i,j) /= eigVals[i];</span>
<a name="l00985"></a>00985 <span class="comment"></span>
<a name="l00986"></a>00986 <span class="comment">        X = eigVecs.dotProduct(X,false,false);</span>
<a name="l00987"></a>00987 <span class="comment">    }*/</span>
<a name="l00988"></a>00988 }
<a name="l00989"></a>00989 
<a name="l00990"></a><a class="code" href="group__qvmatrixalgebra.html#gae95e6a42f2cce467f30a55289a0f9824">00990</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gae95e6a42f2cce467f30a55289a0f9824" title="Obtains the eigen-decomposition of a symmetric matrix.">eigenDecomposition</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8" title="Available methods for EigenDecomposition.">TQVEigenDecomposition_Method</a> method)
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992     eigenDecomposition_internal(M, lambda, Q, method);
<a name="l00993"></a>00993 }
<a name="l00994"></a>00994 
<a name="l00995"></a><a class="code" href="group__qvmatrixalgebra.html#ga5ccc97075c8c8d5340dd6b8b2ace3190">00995</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga5ccc97075c8c8d5340dd6b8b2ace3190" title="Checks for correctness of the eigendecomposition of a matrix.">eigenDecompositionResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q)
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l00998"></a>00998     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == lambda.size());
<a name="l00999"></a>00999     Q_ASSERT(Q.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == Q.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01000"></a>01000     Q_ASSERT(Q.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == lambda.size());
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="keywordtype">double</span> res1 = (Q*<a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(lambda)*Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()-M).norm2();
<a name="l01003"></a>01003     <span class="keywordtype">double</span> res2 = (Q.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()*Q - <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(Q.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>())).norm2();
<a name="l01004"></a>01004 
<a name="l01005"></a>01005     <span class="keywordflow">return</span> res1 + res2;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a><a class="code" href="group__qvmatrixalgebra.html#gabbfe32bf1d0c4def6ecb805bca65d03c">01008</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gabbfe32bf1d0c4def6ecb805bca65d03c" title="Gets the eigenvalues of a matrix.">eigenValues</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2" title="Available methods for EigenValues only computation.">TQVEigenValues_Method</a> method)
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> Q_dummy;
<a name="l01011"></a>01011 
<a name="l01012"></a>01012     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01013"></a>01013 
<a name="l01014"></a>01014     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga4d0b532a36bb590714b98f651a87f9d2a6deda0800fef3c39404fa629cc5d00b9">GSL_EIGENSYMM_ONLY</a>)
<a name="l01015"></a>01015         eigenDecomposition_internal(M, lambda, Q_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a26b778a18b5ed84f1c9dea5d8419981e">GSL_EIGENSYMM</a>, <span class="keyword">true</span>);
<a name="l01016"></a>01016     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#gga4d0b532a36bb590714b98f651a87f9d2a135e946a582e39b85260fa48d418ed9e">LAPACK_DSYEV_ONLY</a>)
<a name="l01017"></a>01017         eigenDecomposition_internal(M, lambda, Q_dummy, <a class="code" href="group__qvmatrixalgebra.html#ggae21e0895ad3ca32f8fdc58b4bf22bec8a7f4f96ab3bd135f5842b0d25bb5d86a1">LAPACK_DSYEV</a>, <span class="keyword">true</span>);
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 
<a name="l01020"></a><a class="code" href="group__qvmatrixalgebra.html#ga124008527c22895b3dc8b828eb867306">01020</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga124008527c22895b3dc8b828eb867306" title="Checks for correctness of the eigenvalues of a symmetric matrix.">eigenValuesResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda)
<a name="l01021"></a>01021 {
<a name="l01022"></a>01022     <span class="keywordtype">double</span> acum = 0.0;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01025"></a>01025     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == lambda.size());
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     <span class="comment">// Sum of diagonal elements of matrix (trace) should be equal to sum of eigenvalues:</span>
<a name="l01028"></a>01028     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();i++)
<a name="l01029"></a>01029         acum += M(i,i);
<a name="l01030"></a>01030     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;lambda.size();i++)
<a name="l01031"></a>01031         acum -= lambda[i];
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordflow">return</span> qAbs(acum);
<a name="l01034"></a>01034 }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 
<a name="l01037"></a><a class="code" href="group__qvmatrixalgebra.html#gadf6472ec782375d465ff1e87b3ae2557">01037</a> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> <a class="code" href="group__qvmatrixalgebra.html#gadf6472ec782375d465ff1e87b3ae2557" title="Obtains the Moore–Penrose pseudoinverse of a matrix.">pseudoInverse</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method, <span class="keywordtype">double</span> epsilon)
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U, V;
<a name="l01040"></a>01040     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> s;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042     <a class="code" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a>(M, U, s, V, method);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044     <span class="comment">// Pseudo-inverse by sum of outer product of corresponding left and right singular vectors, weighted with corresponding</span>
<a name="l01045"></a>01045     <span class="comment">// reciprocals of singular values:</span>
<a name="l01046"></a>01046     <span class="keyword">const</span> <span class="keywordtype">int</span> m = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(), n = M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l01047"></a>01047     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> result(n,m,0.0);
<a name="l01048"></a>01048     <span class="keywordflow">if</span>(s[0] &gt; 0.0)
<a name="l01049"></a>01049         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;s.size();i++)
<a name="l01050"></a>01050             <span class="keywordflow">if</span>(s[i]/s[0] &gt; epsilon)
<a name="l01051"></a>01051                 result += (1/s[i]) * (V.<a class="code" href="classQVMatrix.html#a476e9d1714f98c1ae1b7c1d396fcdbaa" title="Gets a column of the matrix.">getCol</a>(i).<a class="code" href="classQVVector.html#a6c796d6ed02dd3b04db75e97e92b7fcb" title="Outer product with another vector (to obtain a matrix).">outerProduct</a>(U.<a class="code" href="classQVMatrix.html#a476e9d1714f98c1ae1b7c1d396fcdbaa" title="Gets a column of the matrix.">getCol</a>(i)));
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     <span class="keywordflow">return</span> result;
<a name="l01054"></a>01054 }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 
<a name="l01057"></a><a class="code" href="group__qvmatrixalgebra.html#ga18cb128a894fa599a42b85e403049416">01057</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga18cb128a894fa599a42b85e403049416" title="Obtains the determinant of a square matrix.">determinant</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l01058"></a>01058 {
<a name="l01059"></a>01059     Q_ASSERT(M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == M.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>());
<a name="l01060"></a>01060     <span class="keyword">const</span> <span class="keywordtype">int</span> n = M.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l01061"></a>01061 
<a name="l01062"></a>01062     <span class="comment">/* gsl_matrix *m = M;</span>
<a name="l01063"></a>01063 <span class="comment"></span>
<a name="l01064"></a>01064 <span class="comment">    int sign;</span>
<a name="l01065"></a>01065 <span class="comment"></span>
<a name="l01066"></a>01066 <span class="comment">    gsl_permutation *p = gsl_permutation_alloc(3);</span>
<a name="l01067"></a>01067 <span class="comment">    gsl_linalg_LU_decomp (m, p, &amp;sign);</span>
<a name="l01068"></a>01068 <span class="comment">    const double det = gsl_linalg_LU_det (m, sign);</span>
<a name="l01069"></a>01069 <span class="comment"></span>
<a name="l01070"></a>01070 <span class="comment">    gsl_matrix_free(m);</span>
<a name="l01071"></a>01071 <span class="comment">    gsl_permutation_free (p); */</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     <span class="keywordflow">if</span>(n == 1)
<a name="l01074"></a>01074         <span class="keywordflow">return</span> M(0,0);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076     <span class="keywordtype">double</span> det=1.0;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> P,L,U;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <a class="code" href="group__qvmatrixalgebra.html#gae5f89f5ce3f124ded687ebdcb4d621bf" title="Obtains the LU decomposition of a rectangular  matrix.">LUDecomposition</a>(M,P,L,U,method);
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;n;i++)
<a name="l01083"></a>01083         det *= U(i,i);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     <a class="code" href="classQVPermutation.html" title="Implementation of permutations.">QVPermutation</a> perm = <a class="code" href="classQVPermutation.html#a8df4d9f49027ce1ab5b0349f6e05febc" title="Conversion from QVMatrix.">QVPermutation::fromMatrix</a>(P);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087     det *= perm.<a class="code" href="classQVPermutation.html#a270bd86cab5d13026a2ceb1967e83c25" title="Signature of a permutation.">signature</a>();
<a name="l01088"></a>01088 
<a name="l01089"></a>01089     <span class="keywordflow">return</span> det;
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a><a class="code" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4">01092</a> <span class="keywordtype">void</span> <a class="code" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4" title="Solves an homogeneous linear system of equations.">solveHomogeneous</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, QVector&lt;double&gt; &amp;x, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U, V;
<a name="l01095"></a>01095         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> s;
<a name="l01096"></a>01096         <a class="code" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a>(A, U, s, V, method);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098         x = V.<a class="code" href="classQVMatrix.html#a476e9d1714f98c1ae1b7c1d396fcdbaa" title="Gets a column of the matrix.">getCol</a>(V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>()-1);
<a name="l01099"></a>01099 }
<a name="l01100"></a>01100 
<a name="l01101"></a><a class="code" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572">01101</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572" title="Returns the residual of the solution to a linear matrix equation.">solveResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103     <span class="keywordtype">double</span> res = (M*X-B).norm2();
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     <span class="keywordflow">return</span> res;
<a name="l01106"></a>01106 }
<a name="l01107"></a>01107 
<a name="l01108"></a><a class="code" href="group__qvmatrixalgebra.html#gaf2e939fc01193d7854e855684b87d7ed">01108</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572" title="Returns the residual of the solution to a linear matrix equation.">solveResidual</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110     <span class="keywordtype">double</span> res = (M*x-b).norm2();
<a name="l01111"></a>01111 
<a name="l01112"></a>01112     <span class="keywordflow">return</span> res;
<a name="l01113"></a>01113 }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l01116"></a>01116 <span class="preprocessor"></span><span class="keywordtype">double</span> solveConjugateGradient(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <span class="keywordtype">int</span> maxIters, <span class="keyword">const</span> <span class="keywordtype">int</span> minIters, <span class="keyword">const</span> <span class="keywordtype">double</span> minAbsoluteError)
<a name="l01117"></a>01117     {                           
<a name="l01118"></a>01118     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>    r = b - A.<a class="code" href="classQVSparseBlockMatrix.html#a36a11e4a75005686b522407e67136b0c" title="Dot product for sparse block matrices.">dotProduct</a>(x),
<a name="l01119"></a>01119                                 p = r;
<a name="l01120"></a>01120     <span class="keywordtype">double</span> rsold = r.<a class="code" href="classQVVector.html#a9f5e5261bace97f7f315444be9992790" title="Vector dot product.">dotProduct</a>(r);
<a name="l01121"></a>01121 
<a name="l01122"></a>01122         <span class="keywordtype">int</span> i;
<a name="l01123"></a>01123     <span class="keywordflow">for</span> (i = 0; i &lt; maxIters; i++)
<a name="l01124"></a>01124         {
<a name="l01125"></a>01125                 <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> Ap = A * p;
<a name="l01126"></a>01126         <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = rsold / p.<a class="code" href="classQVSparseBlockMatrix.html#a36a11e4a75005686b522407e67136b0c" title="Dot product for sparse block matrices.">dotProduct</a>(Ap);
<a name="l01127"></a>01127         x = x + alpha * p;
<a name="l01128"></a>01128         r = r - alpha * Ap;
<a name="l01129"></a>01129 
<a name="l01130"></a>01130                 <span class="comment">// -----------------------------------------------------------</span>
<a name="l01131"></a>01131                 <span class="comment">//std::cout &lt;&lt; &quot;Conjugate gradient! &quot; &lt;&lt; (A.dotProduct(x) - b).norm2() &lt;&lt; std::endl;</span>
<a name="l01132"></a>01132                 <span class="comment">// -----------------------------------------------------------</span>
<a name="l01133"></a>01133                 <span class="keyword">const</span> <span class="keywordtype">double</span> rsnew = r.<a class="code" href="classQVVector.html#a9f5e5261bace97f7f315444be9992790" title="Vector dot product.">dotProduct</a>(r);
<a name="l01134"></a>01134                 <span class="keywordflow">if</span> ( (rsnew &lt; minAbsoluteError) and (i &gt; minIters) )
<a name="l01135"></a>01135                         <span class="keywordflow">break</span>;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137                 p = r + (rsnew / rsold )* p;
<a name="l01138"></a>01138                 rsold = rsnew;
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140         <span class="comment">//std::cout &lt;&lt; &quot;********************************* max iters = &quot; &lt;&lt; i &lt;&lt; std::endl;</span>
<a name="l01141"></a>01141 
<a name="l01142"></a>01142     <span class="keywordflow">return</span> sqrt(rsold);
<a name="l01143"></a>01143     }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="keywordtype">double</span> solvePreconditionedConjugateGradient(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;invM, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <span class="keywordtype">int</span> maxIters, <span class="keyword">const</span> <span class="keywordtype">int</span> minIters, <span class="keyword">const</span> <span class="keywordtype">double</span> minAbsoluteError)
<a name="l01147"></a>01147     {                           
<a name="l01148"></a>01148     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>    r = b - A.<a class="code" href="classQVSparseBlockMatrix.html#a36a11e4a75005686b522407e67136b0c" title="Dot product for sparse block matrices.">dotProduct</a>(x),
<a name="l01149"></a>01149                                 z = invM*r,
<a name="l01150"></a>01150                                 p = z;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         <span class="keywordtype">int</span> i;
<a name="l01153"></a>01153     <span class="keywordflow">for</span> (i = 0; i &lt; maxIters; i++)
<a name="l01154"></a>01154         {
<a name="l01155"></a>01155                 <span class="keyword">const</span> <span class="keywordtype">double</span> rk_zk = r.<a class="code" href="classQVVector.html#a9f5e5261bace97f7f315444be9992790" title="Vector dot product.">dotProduct</a>(z);
<a name="l01156"></a>01156                 Q_ASSERT(rk_zk == z.dotProduct(r));
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = rk_zk / (p.dotProduct(A*p));
<a name="l01159"></a>01159         x = x + alpha * p;
<a name="l01160"></a>01160         r = r - alpha * A*p;
<a name="l01161"></a>01161                 z = invM * r;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163                 <span class="keyword">const</span> <span class="keywordtype">double</span> rsnew = r.<a class="code" href="classQVSparseBlockMatrix.html#a36a11e4a75005686b522407e67136b0c" title="Dot product for sparse block matrices.">dotProduct</a>(r);
<a name="l01164"></a>01164                 <span class="keywordflow">if</span> ( (rsnew &lt; minAbsoluteError) and (i &gt; minIters) )
<a name="l01165"></a>01165                         <span class="keywordflow">break</span>;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167                 <span class="comment">// -----------------------------------------------------------</span>
<a name="l01168"></a>01168                 <span class="comment">//std::cout &lt;&lt; &quot;Conjugate gradient! &quot; &lt;&lt; (A.dotProduct(x) - b).norm2() &lt;&lt; std::endl;</span>
<a name="l01169"></a>01169                 <span class="comment">// -----------------------------------------------------------</span>
<a name="l01170"></a>01170 
<a name="l01171"></a>01171                 <span class="keyword">const</span> <span class="keywordtype">double</span> beta = r.<a class="code" href="classQVSparseBlockMatrix.html#a36a11e4a75005686b522407e67136b0c" title="Dot product for sparse block matrices.">dotProduct</a>(z) / rk_zk;
<a name="l01172"></a>01172                 p = z + beta * p;
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174         <span class="comment">//std::cout &lt;&lt; &quot;********************************* max iters = &quot; &lt;&lt; i &lt;&lt; std::endl;</span>
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     <span class="keywordflow">return</span> 1.0;
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 <span class="preprocessor">#endif</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span>
<a name="l01180"></a>01180 <span class="keywordtype">bool</span> blockJacobiPreconditionMatrix(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;invM)
<a name="l01181"></a>01181         {
<a name="l01182"></a>01182         <span class="keyword">const</span> <span class="keywordtype">int</span>       majorRows = A.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>(),   majorCols = A.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>(),
<a name="l01183"></a>01183                                 minorRows = A.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>(),   minorCols = A.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>();
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         <span class="keywordflow">if</span> ( (majorRows != majorCols) or (minorRows != minorCols) )
<a name="l01186"></a>01186                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188         invM = <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a>(majorRows, majorRows, minorRows, minorRows);
<a name="l01189"></a>01189 
<a name="l01190"></a>01190         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; majorRows; i++)
<a name="l01191"></a>01191                 invM.<a class="code" href="classQVSparseBlockMatrix.html#a0cb729d3480d161417812d5ddbc2b378" title="Set a data block.">setBlock</a>(i, i, A[i][i].inverse());
<a name="l01192"></a>01192 
<a name="l01193"></a>01193         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="keywordtype">bool</span> blockJacobiPreconditioning(<a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l01197"></a>01197         {
<a name="l01198"></a>01198         <span class="keyword">const</span> <span class="keywordtype">int</span>       majorRows = A.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>(),   majorCols = A.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>(),
<a name="l01199"></a>01199                                 minorRows = A.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>(),   minorCols = A.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>();
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         <span class="keywordflow">if</span> ( (majorRows != majorCols) or (minorRows != minorCols) )
<a name="l01202"></a>01202                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> precond(majorRows, majorRows, minorRows, minorRows);
<a name="l01205"></a>01205         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; majorRows; i++)
<a name="l01206"></a>01206                 precond.setBlock(i, i, A[i][i].inverse());
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         A = precond * A;
<a name="l01209"></a>01209         b = precond * b;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="keywordtype">int</span> dummy;
<a name="l01215"></a>01215 
<a name="l01216"></a><a class="code" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158">01216</a> <span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158" title="Solves a sparse system of linear equations, taking advantage of sparseness to accelerate...">sparseSolve</a>(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;qvspmatrixPre, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;bPre,
<a name="l01217"></a>01217                  <span class="keyword">const</span> <span class="keywordtype">bool</span> isSymmetric, <span class="keyword">const</span> <span class="keywordtype">bool</span> isPosDefinite, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42" title="Available methods for sparse linear system solving.">TQVSparseSolve_Method</a> method,
<a name="l01218"></a>01218                  <span class="keyword">const</span> <span class="keywordtype">bool</span> start_from_x, <span class="keyword">const</span> <span class="keywordtype">bool</span> iters_or_resid,
<a name="l01219"></a>01219                  <span class="keyword">const</span> <span class="keywordtype">int</span> iters, <span class="keyword">const</span> <span class="keywordtype">double</span> resid, <span class="keywordtype">int</span> &amp;final_iter_count)
<a name="l01220"></a>01220     {
<a name="l01221"></a>01221         <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> qvspmatrix = qvspmatrixPre;
<a name="l01222"></a>01222         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> b = bPre;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="keywordflow">if</span> (b.size() != qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>())
<a name="l01225"></a>01225         {
<a name="l01226"></a>01226         std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] Error: tried to solve sparse linear system with incompatible sizes of rhs vector and &quot;</span>
<a name="l01227"></a>01227         &lt;&lt; <span class="stringliteral">&quot;coefficient matrix.&quot;</span> &lt;&lt; std::endl
<a name="l01228"></a>01228         &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01229"></a>01229         &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>() &lt;&lt; std::endl
<a name="l01230"></a>01230         &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block:\t&quot;</span>
<a name="l01231"></a>01231         &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>() &lt;&lt; std::endl
<a name="l01232"></a>01232         &lt;&lt; <span class="stringliteral">&quot;\tRight hand side vector size:\t&quot;</span> &lt;&lt; b.size() &lt;&lt; std::endl;
<a name="l01233"></a>01233         exit(1);
<a name="l01234"></a>01234         }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     <span class="keyword">const</span> <span class="keywordtype">bool</span> isSquare =       (qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>() == qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()) and
<a name="l01237"></a>01237                                         (qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>() == qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>());
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="keywordflow">switch</span> (method)
<a name="l01240"></a>01240         {
<a name="l01241"></a>01241         <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a46209f9833cca62b5a9227d173c6d9a5" title="CHOLMOD direct sparse solver.">QVCHOLMOD_DSS</a>:
<a name="l01242"></a>01242             {
<a name="l01243"></a>01243 <span class="preprocessor">            #ifdef QVCHOLMOD</span>
<a name="l01244"></a>01244 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( not isSymmetric )
<a name="l01245"></a>01245                 qFatal(<span class="stringliteral">&quot;[sparseSolve] Cannot use CHOLMOD method to solve a non-symmetric matrix.&quot;</span>);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247             <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> mutableB = b;
<a name="l01248"></a>01248             QVCholmodSolver solver(qvspmatrix);
<a name="l01249"></a>01249             solver.init();
<a name="l01250"></a>01250             solver.solve(x, mutableB);
<a name="l01251"></a>01251 <span class="preprocessor">            #else</span>
<a name="l01252"></a>01252 <span class="preprocessor"></span>            qFatal(<span class="stringliteral">&quot;[sparseSolve] Cannot use CHOLMOD methods if CHOLMOD is not available.&quot;</span>);
<a name="l01253"></a>01253 <span class="preprocessor">            #endif</span>
<a name="l01254"></a>01254 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
<a name="l01255"></a>01255             }
<a name="l01256"></a>01256 
<a name="l01257"></a>01257         <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd" title="Intel MKL direct sparse solver.">QVMKL_DSS</a>:
<a name="l01258"></a>01258             {
<a name="l01259"></a>01259 <span class="preprocessor">            #ifdef MKL_AVAILABLE</span>
<a name="l01260"></a>01260 <span class="preprocessor"></span>            <span class="comment">// Set size for solution vector X:</span>
<a name="l01261"></a>01261             x = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>());
<a name="l01262"></a>01262 
<a name="l01263"></a>01263             <span class="comment">// Convert sparse matrix to PARDISO format:</span>
<a name="l01264"></a>01264             MKLPardisoSparseFormat pardisomatrix;
<a name="l01265"></a>01265             <span class="keywordflow">if</span> (isSquare and isSymmetric)
<a name="l01266"></a>01266                 squareSymmetricSparseMatrixToPardisoFormat(qvspmatrix, pardisomatrix);
<a name="l01267"></a>01267             <span class="keywordflow">else</span>
<a name="l01268"></a>01268                 pardisomatrix = MKLPardisoSparseFormat(qvspmatrix,isSymmetric);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270             <span class="comment">// Allocate space for handle and associated variables (see MKL examples/solver/source/dss_sym_c.c):</span>
<a name="l01271"></a>01271             _MKL_DSS_HANDLE_t handle;
<a name="l01272"></a>01272             _INTEGER_t error;
<a name="l01273"></a>01273             <span class="keywordtype">int</span> opt = MKL_DSS_DEFAULTS;
<a name="l01274"></a>01274             <span class="keywordtype">int</span> sym = isSymmetric ? MKL_DSS_SYMMETRIC : MKL_DSS_NON_SYMMETRIC;
<a name="l01275"></a>01275             <span class="keywordtype">int</span> type = isPosDefinite ? MKL_DSS_POSITIVE_DEFINITE : MKL_DSS_INDEFINITE;
<a name="l01276"></a>01276 
<a name="l01277"></a>01277             <span class="comment">// Initialize solver:</span>
<a name="l01278"></a>01278             error = dss_create(handle,opt);
<a name="l01279"></a>01279             CHECK_MKL_DSS_ERROR
<a name="l01280"></a>01280 
<a name="l01281"></a>01281             <span class="comment">// Define the non-zero structure of the matrix:</span>
<a name="l01282"></a>01282             error = dss_define_structure(handle,sym,pardisomatrix.rowIndex,pardisomatrix.nRows,pardisomatrix.nCols, pardisomatrix.columns,pardisomatrix.nNonZeros);
<a name="l01283"></a>01283             CHECK_MKL_DSS_ERROR
<a name="l01284"></a>01284 
<a name="l01285"></a>01285             <span class="comment">// Reorder the matrix:</span>
<a name="l01286"></a>01286             error = dss_reorder(handle,opt,0);
<a name="l01287"></a>01287             CHECK_MKL_DSS_ERROR
<a name="l01288"></a>01288 
<a name="l01289"></a>01289             <span class="comment">// Factor the matrix:</span>
<a name="l01290"></a>01290             error = dss_factor_real(handle,type,pardisomatrix.values);
<a name="l01291"></a>01291             CHECK_MKL_DSS_ERROR
<a name="l01292"></a>01292 
<a name="l01293"></a>01293             <span class="comment">// Get the solution vector:</span>
<a name="l01294"></a>01294             <span class="keywordtype">int</span> nrhs = 1;
<a name="l01295"></a>01295             error = dss_solve_real(handle,opt,b.data(),nrhs,x.data());
<a name="l01296"></a>01296             CHECK_MKL_DSS_ERROR
<a name="l01297"></a>01297 
<a name="l01298"></a>01298             <span class="comment">// Deallocate solver storage:</span>
<a name="l01299"></a>01299             error = dss_delete(handle,opt);
<a name="l01300"></a>01300             CHECK_MKL_DSS_ERROR
<a name="l01301"></a>01301 
<a name="l01302"></a>01302             <span class="comment">// Always returns zero:</span>
<a name="l01303"></a>01303             <span class="keywordflow">return</span> 0.0;
<a name="l01304"></a>01304 <span class="preprocessor">            #else</span>
<a name="l01305"></a>01305 <span class="preprocessor"></span>            qFatal(<span class="stringliteral">&quot;[sparseSolve] Cannot use MKL methods if MKL is not available.&quot;</span>);
<a name="l01306"></a>01306 <span class="preprocessor">            #endif</span>
<a name="l01307"></a>01307 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
<a name="l01308"></a>01308             }
<a name="l01309"></a>01309 
<a name="l01310"></a>01310         <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a4e5ab535616a47622854edcf1d96684f" title="Intel MKL iterative sparse solver.">QVMKL_ISS</a>:
<a name="l01311"></a>01311             {
<a name="l01312"></a>01312 <span class="preprocessor">            #ifdef MKL_AVAILABLE</span>
<a name="l01313"></a>01313 <span class="preprocessor"></span>            <span class="comment">// Only for solving symmetric positive definite system of equations, simplest case:</span>
<a name="l01314"></a>01314             <span class="comment">// no preconditioning and no user-defined stopping tests.</span>
<a name="l01315"></a>01315             <span class="keywordflow">if</span>(not isSymmetric or not isPosDefinite)
<a name="l01316"></a>01316                 qFatal(<span class="stringliteral">&quot;[sparseSolve] QVMKL_ISS method only admits a symmetric and positive definite coefficient matrix.&quot;</span>);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318             <span class="comment">// MKL ISS parameters:</span>
<a name="l01319"></a>01319             MKL_INT n=b.size(), rci_request, itercount, i;
<a name="l01320"></a>01320             MKL_INT ipar[128];
<a name="l01321"></a>01321             <span class="keywordtype">double</span> dpar[128],*tmp;
<a name="l01322"></a>01322             <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> temp(4*n);
<a name="l01323"></a>01323             tmp = temp.data();
<a name="l01324"></a>01324             <span class="keywordtype">char</span> tr=<span class="charliteral">&#39;u&#39;</span>;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326             <span class="comment">// Convert sparse matrix to PARDISO format:</span>
<a name="l01327"></a>01327             MKLPardisoSparseFormat pardisomatrix;
<a name="l01328"></a>01328             <span class="keywordflow">if</span> (isSquare and isSymmetric)
<a name="l01329"></a>01329                 squareSymmetricSparseMatrixToPardisoFormat(qvspmatrix, pardisomatrix);
<a name="l01330"></a>01330             <span class="keywordflow">else</span>
<a name="l01331"></a>01331                 pardisomatrix = MKLPardisoSparseFormat(qvspmatrix,isSymmetric);
<a name="l01332"></a>01332             <span class="comment">//MKLPardisoSparseFormat pardisomatrix(qvspmatrix,isSymmetric);</span>
<a name="l01333"></a>01333 
<a name="l01334"></a>01334             <span class="comment">// Initial solution guess (vector of ones, if completely unknown, previous value of x otherwise):</span>
<a name="l01335"></a>01335             <span class="keywordflow">if</span>(start_from_x)
<a name="l01336"></a>01336                 {
<a name="l01337"></a>01337                 <span class="keywordflow">if</span>(x.size() != qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>())
<a name="l01338"></a>01338                     {
<a name="l01339"></a>01339                     std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] (QVMKL_ISS): error, tried to reuse unknowns x vector with incompatible size with &quot;</span>
<a name="l01340"></a>01340                     &lt;&lt; <span class="stringliteral">&quot;coefficient matrix.&quot;</span> &lt;&lt; std::endl
<a name="l01341"></a>01341                     &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01342"></a>01342                     &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>() &lt;&lt; std::endl
<a name="l01343"></a>01343                     &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block:\t&quot;</span>
<a name="l01344"></a>01344                     &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>() &lt;&lt; std::endl
<a name="l01345"></a>01345                     &lt;&lt; <span class="stringliteral">&quot;\tunknowns x vector size:\t&quot;</span> &lt;&lt; x.size() &lt;&lt; std::endl;
<a name="l01346"></a>01346                     exit(1);
<a name="l01347"></a>01347                     }
<a name="l01348"></a>01348                 }
<a name="l01349"></a>01349             <span class="keywordflow">else</span> {
<a name="l01350"></a>01350                 <span class="comment">// Set size for solution vector x, and initialize with ones (for example):</span>
<a name="l01351"></a>01351                 x = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>());
<a name="l01352"></a>01352                 <span class="keywordflow">for</span>(i=0;i&lt;n;i++) x[i]=1.E0;
<a name="l01353"></a>01353                 }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355             <span class="comment">// Initialize the solver:</span>
<a name="l01356"></a>01356             dcg_init(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01357"></a>01357             <span class="keywordflow">if</span> (rci_request!=0) <span class="keywordflow">goto</span> failure;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359             <span class="comment">// Set the desired parameters:</span>
<a name="l01360"></a>01360             <span class="keywordflow">if</span>(iters_or_resid)
<a name="l01361"></a>01361                 {
<a name="l01362"></a>01362                 <span class="comment">// Set maximum number of iterations:</span>
<a name="l01363"></a>01363                 <span class="keywordflow">if</span>(iters &gt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>())
<a name="l01364"></a>01364                     {
<a name="l01365"></a>01365                     std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] (QVMKL_ISS): error, iters must be less than or equal to the dimension of the problem.\n&quot;</span>
<a name="l01366"></a>01366                     &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01367"></a>01367                     &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a202dae52dc2ec0501ceddc53ffc31aac" title="Get majorRows from a sparse block matrix.">getMajorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>() &lt;&lt; std::endl
<a name="l01368"></a>01368                     &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block: &quot;</span>
<a name="l01369"></a>01369                     &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#af6637b61809a2d386d8d6ea3078a96b6" title="Get minorRows from a sparse block matrix.">getMinorRows</a>() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>() &lt;&lt; std::endl
<a name="l01370"></a>01370                     &lt;&lt; <span class="stringliteral">&quot;\tdimension: &quot;</span> &lt;&lt; qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>()*qvspmatrix.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>() &lt;&lt; std::endl
<a name="l01371"></a>01371                     &lt;&lt; <span class="stringliteral">&quot;\titers requested: &quot;</span> &lt;&lt; iters &lt;&lt; std::endl;
<a name="l01372"></a>01372                     exit(1);
<a name="l01373"></a>01373                     }
<a name="l01374"></a>01374 
<a name="l01375"></a>01375                 ipar[4]=iters;
<a name="l01376"></a>01376                 ipar[7]=1;
<a name="l01377"></a>01377                 ipar[8]=0;
<a name="l01378"></a>01378                 ipar[9]=0;
<a name="l01379"></a>01379                 }
<a name="l01380"></a>01380             <span class="keywordflow">else</span>        {
<a name="l01381"></a>01381                 <span class="comment">// Absolute norm of residual:</span>
<a name="l01382"></a>01382                 ipar[8]=1;
<a name="l01383"></a>01383                 ipar[9]=0;
<a name="l01384"></a>01384                 dpar[0]=0.0;
<a name="l01385"></a>01385                 dpar[1]=resid;
<a name="l01386"></a>01386                 }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388             <span class="comment">// Check the correctness and consistency of the newly set parameters.</span>
<a name="l01389"></a>01389             dcg_check(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01390"></a>01390             <span class="keywordflow">if</span> (rci_request!=0) <span class="keywordflow">goto</span> failure;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392             <span class="comment">// Compute the solution by RCI (P)CG solver without preconditioning</span>
<a name="l01393"></a>01393             <span class="comment">// (Reverse Communications starts here).</span>
<a name="l01394"></a>01394             rci:
<a name="l01395"></a>01395             dcg(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01396"></a>01396             <span class="comment">// If rci_request=0, then the solution was found with the required precision.</span>
<a name="l01397"></a>01397             <span class="keywordflow">if</span> (rci_request==0) <span class="keywordflow">goto</span> getsln;
<a name="l01398"></a>01398             <span class="comment">// If rci_request=1, then compute the vector A*tmp[0] and put the result in vector tmp[n]:</span>
<a name="l01399"></a>01399             <span class="keywordflow">if</span> (rci_request==1)
<a name="l01400"></a>01400                 {
<a name="l01401"></a>01401                 mkl_dcsrsymv(&amp;tr, &amp;n, pardisomatrix.values, pardisomatrix.rowIndex, pardisomatrix.columns, tmp, &amp;tmp[n]);
<a name="l01402"></a>01402                 <span class="keywordflow">goto</span> rci;
<a name="l01403"></a>01403                 }
<a name="l01404"></a>01404             <span class="comment">// If rci_request=anything else, then dcg subroutine failed to compute the solution vector: solution[n]</span>
<a name="l01405"></a>01405             <span class="comment">// goto failure;</span>
<a name="l01406"></a>01406             std::cerr &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] WARNING: failed to complete requested convergence\n&quot;</span>;
<a name="l01407"></a>01407             <span class="comment">// (Reverse Communication ends here).</span>
<a name="l01408"></a>01408 
<a name="l01409"></a>01409             <span class="comment">// Get the current iteration number into itercount.</span>
<a name="l01410"></a>01410             getsln:
<a name="l01411"></a>01411             dcg_get(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp,&amp;itercount);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413             final_iter_count = itercount;
<a name="l01414"></a>01414             <span class="comment">//printf(&quot;ISS: Number of iterations: %d\n&quot;,itercount);</span>
<a name="l01415"></a>01415             <span class="keywordflow">goto</span> end;
<a name="l01416"></a>01416             failure:
<a name="l01417"></a>01417             std::cout &lt;&lt; <span class="stringliteral">&quot;RCI CG solver failed to complete computations. Error code &quot;</span> &lt;&lt; rci_request &lt;&lt; std::endl;
<a name="l01418"></a>01418             qFatal(<span class="stringliteral">&quot;[sparseSolve] QVMKL_ISS method failed.&quot;</span>);
<a name="l01419"></a>01419             end:
<a name="l01420"></a>01420             <span class="keywordflow">return</span> dpar[4];
<a name="l01421"></a>01421 <span class="preprocessor">            #else</span>
<a name="l01422"></a>01422 <span class="preprocessor"></span>            qFatal(<span class="stringliteral">&quot;[sparseSolve] cannot use MKL methods if MKL not available.&quot;</span>);
<a name="l01423"></a>01423 <span class="preprocessor">            #endif</span>
<a name="l01424"></a>01424 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
<a name="l01425"></a>01425             }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427                 <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a5c07aa6579256ac88d6949c8238c08f4" title="Block Jacobian preconditioned conjugate gradient.">QV_BJPCG</a>:
<a name="l01428"></a>01428                         {
<a name="l01429"></a>01429                         <span class="keywordflow">if</span> ( not isSymmetric )
<a name="l01430"></a>01430                                 qFatal(<span class="stringliteral">&quot;[sparseSolve] Cannot use block Jacobi preconditioner on a non-symmetric coefficient matrix.&quot;</span>);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432                         <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> invM;
<a name="l01433"></a>01433                         <span class="keywordflow">if</span> (not blockJacobiPreconditionMatrix(qvspmatrix, b, invM))
<a name="l01434"></a>01434                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436                         <span class="keywordflow">return</span> solvePreconditionedConjugateGradient(qvspmatrix, invM, x, b, iters, 0, resid);
<a name="l01437"></a>01437                         <span class="keywordflow">break</span>;
<a name="l01438"></a>01438                         }
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1cfab50cd282632e71c4a7fe885705b1" title="Iterative sparse conjugate gradient.">QV_SCG</a>:
<a name="l01441"></a>01441             {
<a name="l01442"></a>01442                         <span class="keywordflow">foreach</span>(<span class="keywordtype">int</span> ib, qvspmatrix.keys())
<a name="l01443"></a>01443                                 {
<a name="l01444"></a>01444                                 <span class="keyword">const</span> QMap&lt;int, QVMatrix&gt; &amp;majorRow = qvspmatrix[ib];
<a name="l01445"></a>01445                                 <span class="keywordflow">foreach</span>(<span class="keywordtype">int</span> jb, majorRow.keys())
<a name="l01446"></a>01446                                         <span class="keywordflow">if</span> (ib != jb)
<a name="l01447"></a>01447                                                 qvspmatrix[jb][ib] = majorRow[jb].transpose();
<a name="l01448"></a>01448                                 }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450             <span class="keywordflow">return</span> solveConjugateGradient(qvspmatrix, x, b, iters, 0, resid);
<a name="l01451"></a>01451             <span class="keywordflow">break</span>;
<a name="l01452"></a>01452             }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454         <span class="keywordflow">case</span> <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a15407dbc0a00f2cf16f73f5b4ec74b67" title="Direct dense method.">QV_DENSE</a>:
<a name="l01455"></a>01455             {
<a name="l01456"></a>01456             <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(<a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(qvspmatrix), x, b);
<a name="l01457"></a>01457             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01458"></a>01458             <span class="keywordflow">break</span>;
<a name="l01459"></a>01459             }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461         <span class="keywordflow">default</span>:
<a name="l01462"></a>01462             {
<a name="l01463"></a>01463             <span class="keywordflow">return</span> 0.0;
<a name="l01464"></a>01464             <span class="keywordflow">break</span>;
<a name="l01465"></a>01465             }
<a name="l01466"></a>01466         }
<a name="l01467"></a>01467     <span class="keywordflow">return</span> -1.0;
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 <span class="comment">// -----------------------------------------------------------------------------------------------------------------------------------</span>
<a name="l01471"></a>01471 <span class="preprocessor">#ifdef MKL_AVAILABLE</span>
<a name="l01472"></a>01472 <span class="preprocessor"></span><span class="keywordtype">double</span> <a class="code" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158" title="Solves a sparse system of linear equations, taking advantage of sparseness to accelerate...">sparseSolve</a>(<span class="keyword">const</span> MKLPardisoSparseFormat &amp;pardisomatrix, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b,
<a name="l01473"></a>01473                  <span class="keyword">const</span> <span class="keywordtype">bool</span> isSymmetric, <span class="keyword">const</span> <span class="keywordtype">bool</span> isPosDefinite, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42" title="Available methods for sparse linear system solving.">TQVSparseSolve_Method</a> method,
<a name="l01474"></a>01474                  <span class="keyword">const</span> <span class="keywordtype">bool</span> start_from_x, <span class="keyword">const</span> <span class="keywordtype">bool</span> iters_or_resid,
<a name="l01475"></a>01475                  <span class="keyword">const</span> <span class="keywordtype">int</span> iters, <span class="keyword">const</span> <span class="keywordtype">double</span> resid, <span class="keywordtype">int</span> &amp;final_iter_count)
<a name="l01476"></a>01476 {
<a name="l01477"></a>01477 
<a name="l01478"></a>01478     <span class="comment">// Check correctness of input:</span>
<a name="l01479"></a>01479     <span class="keywordflow">if</span>(b.size() != pardisomatrix.getMajorRows()*pardisomatrix.getMinorRows()) {
<a name="l01480"></a>01480         std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] Error: tried to solve sparse linear system with incompatible sizes of rhs vector and &quot;</span>
<a name="l01481"></a>01481                   &lt;&lt; <span class="stringliteral">&quot;coefficient matrix.&quot;</span> &lt;&lt; std::endl
<a name="l01482"></a>01482                   &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01483"></a>01483                        &lt;&lt; pardisomatrix.getMajorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMajorCols() &lt;&lt; std::endl
<a name="l01484"></a>01484                   &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block:\t&quot;</span>
<a name="l01485"></a>01485                        &lt;&lt; pardisomatrix.getMinorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMinorCols() &lt;&lt; std::endl
<a name="l01486"></a>01486                        &lt;&lt; <span class="stringliteral">&quot;\tRight hand side vector size:\t&quot;</span> &lt;&lt; b.size() &lt;&lt; std::endl;
<a name="l01487"></a>01487         exit(1);
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489 
<a name="l01490"></a>01490     <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd" title="Intel MKL direct sparse solver.">QVMKL_DSS</a>) {
<a name="l01491"></a>01491         <span class="comment">// Set size for solution vector X:</span>
<a name="l01492"></a>01492         x = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(pardisomatrix.getMajorCols()*pardisomatrix.getMinorCols());
<a name="l01493"></a>01493 
<a name="l01494"></a>01494         <span class="comment">// Allocate space for handle and associated variables (see MKL examples/solver/source/dss_sym_c.c):</span>
<a name="l01495"></a>01495         _MKL_DSS_HANDLE_t handle;
<a name="l01496"></a>01496         _INTEGER_t error;
<a name="l01497"></a>01497         <span class="keywordtype">int</span> opt = MKL_DSS_DEFAULTS;
<a name="l01498"></a>01498         <span class="keywordtype">int</span> sym = isSymmetric ? MKL_DSS_SYMMETRIC : MKL_DSS_NON_SYMMETRIC;
<a name="l01499"></a>01499         <span class="keywordtype">int</span> type = isPosDefinite ? MKL_DSS_POSITIVE_DEFINITE : MKL_DSS_INDEFINITE;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501         <span class="comment">// Initialize solver:</span>
<a name="l01502"></a>01502         error = dss_create(handle,opt);
<a name="l01503"></a>01503         CHECK_MKL_DSS_ERROR
<a name="l01504"></a>01504 
<a name="l01505"></a>01505         <span class="comment">// Define the non-zero structure of the matrix:</span>
<a name="l01506"></a>01506         error = dss_define_structure(handle,sym,pardisomatrix.rowIndex,pardisomatrix.nRows,pardisomatrix.nCols,
<a name="l01507"></a>01507                                      pardisomatrix.columns,pardisomatrix.nNonZeros);
<a name="l01508"></a>01508         CHECK_MKL_DSS_ERROR
<a name="l01509"></a>01509 
<a name="l01510"></a>01510         <span class="comment">// Reorder the matrix:</span>
<a name="l01511"></a>01511         error = dss_reorder(handle,opt,0);
<a name="l01512"></a>01512         CHECK_MKL_DSS_ERROR
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         <span class="comment">// Factor the matrix:</span>
<a name="l01515"></a>01515         error = dss_factor_real(handle,type,pardisomatrix.values);
<a name="l01516"></a>01516         CHECK_MKL_DSS_ERROR
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         <span class="comment">// Get the solution vector:</span>
<a name="l01519"></a>01519         <span class="keywordtype">int</span> nrhs = 1;
<a name="l01520"></a>01520         error = dss_solve_real(handle,opt,b.data(),nrhs,x.data());
<a name="l01521"></a>01521         CHECK_MKL_DSS_ERROR
<a name="l01522"></a>01522 
<a name="l01523"></a>01523         <span class="comment">// Deallocate solver storage:</span>
<a name="l01524"></a>01524         error = dss_delete(handle,opt);
<a name="l01525"></a>01525         CHECK_MKL_DSS_ERROR
<a name="l01526"></a>01526 
<a name="l01527"></a>01527         <span class="comment">// Always returns zero:</span>
<a name="l01528"></a>01528         <span class="keywordflow">return</span> 0.0;
<a name="l01529"></a>01529     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(method == <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a4e5ab535616a47622854edcf1d96684f" title="Intel MKL iterative sparse solver.">QVMKL_ISS</a>) {
<a name="l01530"></a>01530         <span class="comment">// Only for solving symmetric positive definite system of equations, simplest case:</span>
<a name="l01531"></a>01531         <span class="comment">// no preconditioning and no user-defined stopping tests.</span>
<a name="l01532"></a>01532         <span class="keywordflow">if</span>(not isSymmetric or not isPosDefinite) {
<a name="l01533"></a>01533             qFatal(<span class="stringliteral">&quot;[sparseSolve] QVMKL_ISS method only admits a symmetric and positive definite coefficient matrix.&quot;</span>);
<a name="l01534"></a>01534         }
<a name="l01535"></a>01535         <span class="comment">// MKL ISS parameters:</span>
<a name="l01536"></a>01536         MKL_INT n=b.size(), rci_request, itercount, i;
<a name="l01537"></a>01537         MKL_INT ipar[128];
<a name="l01538"></a>01538         <span class="keywordtype">double</span> dpar[128],*tmp;
<a name="l01539"></a>01539         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> temp(4*n);
<a name="l01540"></a>01540         tmp = temp.data();
<a name="l01541"></a>01541         <span class="keywordtype">char</span> tr=<span class="charliteral">&#39;u&#39;</span>;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543         <span class="comment">// Initial solution guess (vector of ones, if completely unknown, previous value of x otherwise):</span>
<a name="l01544"></a>01544         <span class="keywordflow">if</span>(start_from_x) {
<a name="l01545"></a>01545             <span class="keywordflow">if</span>(x.size() != pardisomatrix.getMajorCols()*pardisomatrix.getMinorCols()) {
<a name="l01546"></a>01546                 std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] (QVMKL_ISS): error, tried to reuse unknowns x vector with incompatible size with &quot;</span>
<a name="l01547"></a>01547                           &lt;&lt; <span class="stringliteral">&quot;coefficient matrix.&quot;</span> &lt;&lt; std::endl
<a name="l01548"></a>01548                           &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01549"></a>01549                           &lt;&lt; pardisomatrix.getMajorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMajorCols() &lt;&lt; std::endl
<a name="l01550"></a>01550                           &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block:\t&quot;</span>
<a name="l01551"></a>01551                           &lt;&lt; pardisomatrix.getMinorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMinorCols() &lt;&lt; std::endl
<a name="l01552"></a>01552                           &lt;&lt; <span class="stringliteral">&quot;\tunknowns x vector size:\t&quot;</span> &lt;&lt; x.size() &lt;&lt; std::endl;
<a name="l01553"></a>01553                 exit(1);
<a name="l01554"></a>01554             }
<a name="l01555"></a>01555         } <span class="keywordflow">else</span> {
<a name="l01556"></a>01556             <span class="comment">// Set size for solution vector x, and initialize with ones (for example):</span>
<a name="l01557"></a>01557             x = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(pardisomatrix.getMajorCols()*pardisomatrix.getMinorCols());
<a name="l01558"></a>01558             <span class="keywordflow">for</span>(i=0;i&lt;n;i++)
<a name="l01559"></a>01559                 x[i]=1.E0;
<a name="l01560"></a>01560         }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562         <span class="comment">// Initialize the solver:</span>
<a name="l01563"></a>01563         dcg_init(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01564"></a>01564         <span class="keywordflow">if</span> (rci_request!=0) <span class="keywordflow">goto</span> failure;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         <span class="comment">// Set the desired parameters:</span>
<a name="l01567"></a>01567         <span class="keywordflow">if</span>(iters_or_resid) {
<a name="l01568"></a>01568             <span class="comment">// Set maximum number of iterations:</span>
<a name="l01569"></a>01569             <span class="keywordflow">if</span>(iters &gt; pardisomatrix.getMajorCols()*pardisomatrix.getMinorCols()) {
<a name="l01570"></a>01570                 std::cout &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] (QVMKL_ISS): error, iters must be less than or equal to the dimension of the problem.\n&quot;</span>
<a name="l01571"></a>01571                           &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix number of blocks:\t&quot;</span>
<a name="l01572"></a>01572                           &lt;&lt; pardisomatrix.getMajorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMajorCols() &lt;&lt; std::endl
<a name="l01573"></a>01573                           &lt;&lt; <span class="stringliteral">&quot;\tSparse matrix size of each block: &quot;</span>
<a name="l01574"></a>01574                           &lt;&lt; pardisomatrix.getMinorRows() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; pardisomatrix.getMinorCols() &lt;&lt; std::endl
<a name="l01575"></a>01575                           &lt;&lt; <span class="stringliteral">&quot;\tdimension: &quot;</span> &lt;&lt; pardisomatrix.getMajorCols()*pardisomatrix.getMinorCols() &lt;&lt; std::endl
<a name="l01576"></a>01576                           &lt;&lt; <span class="stringliteral">&quot;\titers requested: &quot;</span> &lt;&lt; iters &lt;&lt; std::endl;
<a name="l01577"></a>01577                 exit(1);
<a name="l01578"></a>01578             }
<a name="l01579"></a>01579             ipar[4]=iters;
<a name="l01580"></a>01580             ipar[7]=1;
<a name="l01581"></a>01581             ipar[8]=0;
<a name="l01582"></a>01582             ipar[9]=0;
<a name="l01583"></a>01583         } <span class="keywordflow">else</span> {
<a name="l01584"></a>01584             <span class="comment">// Absolute norm of residual:</span>
<a name="l01585"></a>01585             ipar[8]=1;
<a name="l01586"></a>01586             ipar[9]=0;
<a name="l01587"></a>01587             dpar[0]=0.0;
<a name="l01588"></a>01588             dpar[1]=resid;
<a name="l01589"></a>01589         }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         <span class="comment">// Check the correctness and consistency of the newly set parameters.</span>
<a name="l01592"></a>01592         dcg_check(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01593"></a>01593         <span class="keywordflow">if</span> (rci_request!=0) <span class="keywordflow">goto</span> failure;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         <span class="comment">// Compute the solution by RCI (P)CG solver without preconditioning</span>
<a name="l01596"></a>01596         <span class="comment">// (Reverse Communications starts here).</span>
<a name="l01597"></a>01597     rci:
<a name="l01598"></a>01598         dcg(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp);
<a name="l01599"></a>01599         <span class="comment">// If rci_request=0, then the solution was found with the required precision.</span>
<a name="l01600"></a>01600         <span class="keywordflow">if</span> (rci_request==0) <span class="keywordflow">goto</span> getsln;
<a name="l01601"></a>01601         <span class="comment">// If rci_request=1, then compute the vector A*tmp[0] and put the result in vector tmp[n]:</span>
<a name="l01602"></a>01602         <span class="keywordflow">if</span> (rci_request==1) {
<a name="l01603"></a>01603                 mkl_dcsrsymv(&amp;tr, &amp;n, pardisomatrix.values, pardisomatrix.rowIndex, pardisomatrix.columns, tmp, &amp;tmp[n]);
<a name="l01604"></a>01604                 <span class="keywordflow">goto</span> rci;
<a name="l01605"></a>01605         }
<a name="l01606"></a>01606         <span class="comment">// If rci_request=anything else, then dcg subroutine failed to compute the solution vector: solution[n]</span>
<a name="l01607"></a>01607         <span class="comment">// goto failure;</span>
<a name="l01608"></a>01608         std::cerr &lt;&lt; <span class="stringliteral">&quot;[sparseSolve] WARNING: failed to complete requested convergence\n&quot;</span>;
<a name="l01609"></a>01609         <span class="comment">// (Reverse Communication ends here).</span>
<a name="l01610"></a>01610 
<a name="l01611"></a>01611         <span class="comment">// Get the current iteration number into itercount.</span>
<a name="l01612"></a>01612     getsln:
<a name="l01613"></a>01613         dcg_get(&amp;n,x.data(),<span class="keyword">const_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(b.data()),&amp;rci_request,ipar,dpar,tmp,&amp;itercount);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615         final_iter_count = itercount;
<a name="l01616"></a>01616         <span class="comment">//printf(&quot;ISS: Number of iterations: %d\n&quot;,itercount);</span>
<a name="l01617"></a>01617         <span class="keywordflow">goto</span> end;
<a name="l01618"></a>01618     failure:
<a name="l01619"></a>01619     std::cout &lt;&lt;  <span class="stringliteral">&quot;RCI CG solver failed to complete computations. Error code &quot;</span> &lt;&lt; rci_request &lt;&lt; std::endl;
<a name="l01620"></a>01620         qFatal(<span class="stringliteral">&quot;[sparseSolve] QVMKL_ISS method failed.&quot;</span>);
<a name="l01621"></a>01621     end:
<a name="l01622"></a>01622         <span class="keywordflow">return</span> dpar[4];
<a name="l01623"></a>01623     }
<a name="l01624"></a>01624     <span class="keywordflow">return</span> 0.0;
<a name="l01625"></a>01625 }
<a name="l01626"></a>01626 <span class="preprocessor">#endif</span>
<a name="l01627"></a>01627 <span class="preprocessor"></span>
<a name="l01628"></a>01628 <span class="comment">// Solves an homogeneous system using the inverse iteration algorithm.</span>
<a name="l01629"></a><a class="code" href="group__qvmatrixalgebra.html#gada28dcc8be2cf1b93f3b1f201cafdb88">01629</a> <span class="keywordtype">bool</span> <a class="code" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4" title="Solves an homogeneous linear system of equations.">solveHomogeneous</a>(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <span class="keywordtype">int</span> maxIterations, <span class="keyword">const</span> <span class="keywordtype">double</span> minRelativeError, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42" title="Available methods for sparse linear system solving.">TQVSparseSolve_Method</a> method)
<a name="l01630"></a>01630     {
<a name="l01631"></a>01631 <span class="preprocessor">    #ifdef MKL_AVAILABLE</span>
<a name="l01632"></a>01632 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(method != <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd" title="Intel MKL direct sparse solver.">QVMKL_DSS</a>) {
<a name="l01633"></a>01633         std::cerr &lt;&lt; <span class="stringliteral">&quot;[solveHomogeneous] Warning: this function for sparse matrices only supports QVMKL_DSS method.&quot;</span> &lt;&lt; std::endl;
<a name="l01634"></a>01634     }
<a name="l01635"></a>01635 
<a name="l01636"></a>01636     <span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> AtA = A.transpose() * A;
<a name="l01637"></a>01637 
<a name="l01638"></a>01638     <span class="comment">//std::cout &lt;&lt; &quot;A rows cols = &quot; &lt;&lt; QVMatrix(A).getRows() &lt;&lt; &quot;\t&quot; &lt;&lt; QVMatrix(A).getCols() &lt;&lt; std::endl;</span>
<a name="l01639"></a>01639     <span class="keyword">const</span> <span class="keywordtype">int</span> totalCols = AtA.<a class="code" href="classQVSparseBlockMatrix.html#a6cb89146c9191b915b8f493f0be6becc" title="Get majorCols from a sparse block matrix.">getMajorCols</a>() * AtA.<a class="code" href="classQVSparseBlockMatrix.html#ad606f1e2fe760064d0494e7c133dbed7" title="Get minorCols from a sparse block matrix.">getMinorCols</a>();
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     <span class="keywordflow">if</span> (x.count() != totalCols)
<a name="l01642"></a>01642         x = <a class="code" href="classQVVector.html#ac550cb33a94138c6a55901bc2dc23558" title="Creates a vector of random values.">QVVector::random</a>(totalCols);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644     <span class="comment">// -- Init MKL solver ------------------------------------------</span>
<a name="l01645"></a>01645     <span class="comment">// Convert sparse matrix to Pardiso format.</span>
<a name="l01646"></a>01646     <span class="keyword">const</span> <span class="keywordtype">int</span>   opt = MKL_DSS_DEFAULTS,
<a name="l01647"></a>01647             sym = MKL_DSS_SYMMETRIC,
<a name="l01648"></a>01648             type = MKL_DSS_POSITIVE_DEFINITE;
<a name="l01649"></a>01649 
<a name="l01650"></a>01650     MKLPardisoSparseFormat pardisomatrix(AtA, <span class="keyword">true</span>);
<a name="l01651"></a>01651 
<a name="l01652"></a>01652         <span class="comment">// Initialize solver:</span>
<a name="l01653"></a>01653     _MKL_DSS_HANDLE_t handle;
<a name="l01654"></a>01654     _INTEGER_t error = dss_create(handle,opt);
<a name="l01655"></a>01655     CHECK_MKL_DSS_ERROR;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         <span class="comment">// Define the non-zero structure of the matrix:</span>
<a name="l01658"></a>01658     error = dss_define_structure(handle, sym, pardisomatrix.rowIndex, pardisomatrix.nRows, pardisomatrix.nCols, pardisomatrix.columns, pardisomatrix.nNonZeros);
<a name="l01659"></a>01659     CHECK_MKL_DSS_ERROR;
<a name="l01660"></a>01660 
<a name="l01661"></a>01661         <span class="comment">// Reorder the matrix:</span>
<a name="l01662"></a>01662     error = dss_reorder(handle,opt,0);
<a name="l01663"></a>01663     CHECK_MKL_DSS_ERROR;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="comment">// Factor the matrix:</span>
<a name="l01666"></a>01666     error = dss_factor_real(handle, type, pardisomatrix.values);
<a name="l01667"></a>01667     CHECK_MKL_DSS_ERROR;
<a name="l01668"></a>01668     <span class="comment">// ------------------------------------------------------------</span>
<a name="l01669"></a>01669 
<a name="l01670"></a>01670     <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;
<a name="l01671"></a>01671     <span class="comment">// Iterate to obtain the solution.</span>
<a name="l01672"></a>01672     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; maxIterations; i++)
<a name="l01673"></a>01673         {
<a name="l01674"></a>01674         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> xNew = x;
<a name="l01675"></a>01675 
<a name="l01676"></a>01676         <span class="comment">//SparseSolve(AtA, xNew, x, true, true, QVMKL_DSS, true, true, 10);</span>
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         <span class="keywordtype">int</span> nrhs = 1;
<a name="l01679"></a>01679         error = dss_solve_real(handle, opt, x.data(), nrhs, xNew.data());
<a name="l01680"></a>01680         CHECK_MKL_DSS_ERROR;
<a name="l01681"></a>01681 
<a name="l01682"></a>01682         xNew = xNew / xNew.<a class="code" href="classQVVector.html#a49c6f41f1fa80efcc943f1c26fdcbf05" title="Norm 2 of the vector.">norm2</a>();
<a name="l01683"></a>01683         <span class="keyword">const</span> <span class="keywordtype">double</span> relativeError = (x-xNew).norm2();
<a name="l01684"></a>01684 
<a name="l01685"></a>01685         x = xNew;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687         <span class="keywordflow">if</span> (relativeError &lt;= minRelativeError)
<a name="l01688"></a>01688             {
<a name="l01689"></a>01689             success = <span class="keyword">true</span>;
<a name="l01690"></a>01690             <span class="keywordflow">break</span>;
<a name="l01691"></a>01691             }
<a name="l01692"></a>01692         }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694     <span class="comment">// -- Release MKL data ---</span>
<a name="l01695"></a>01695         <span class="comment">// Deallocate solver storage:</span>
<a name="l01696"></a>01696     error = dss_delete(handle,opt);
<a name="l01697"></a>01697     CHECK_MKL_DSS_ERROR;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     <span class="keywordflow">return</span> success;
<a name="l01700"></a>01700 
<a name="l01701"></a>01701 <span class="preprocessor">    #else</span>
<a name="l01702"></a>01702 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;[solveHomogeneous] Warning: this function requires the MKL library.&quot;</span> &lt;&lt; std::endl;
<a name="l01703"></a>01703 <span class="preprocessor">    #endif</span>
<a name="l01704"></a>01704 <span class="preprocessor"></span>    }
<a name="l01705"></a>01705 
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 <span class="comment">// -----------------------------------------------------------------------------------------------------------------------------------</span>
<a name="l01708"></a>01708 <span class="keywordtype">void</span> solveLinear(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l01709"></a>01709     {
<a name="l01710"></a>01710         std::cout &lt;&lt; <span class="stringliteral">&quot;solveLinear DEPRECATED, use any of the following functions instead, depending on your needs:\n&quot;</span>
<a name="l01711"></a>01711                      <span class="stringliteral">&quot;solveBySingularValueDecomposition\n&quot;</span>
<a name="l01712"></a>01712                      <span class="stringliteral">&quot;solveByCholeskyDecomposition\n&quot;</span>
<a name="l01713"></a>01713                      <span class="stringliteral">&quot;solveByLUDecomposition\n&quot;</span>
<a name="l01714"></a>01714                      <span class="stringliteral">&quot;solveByQRDecomposition\n&quot;</span>
<a name="l01715"></a>01715                      <span class="stringliteral">&quot;(see QVision documentation for details):\n&quot;</span>;
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01718"></a>01718     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == x.size());
<a name="l01719"></a>01719     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == b.size());
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l01722"></a>01722 <span class="preprocessor"></span>        gsl_matrix *gA = A;
<a name="l01723"></a>01723     gsl_vector *gB = b;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     gsl_linalg_HH_svx(gA, gB);
<a name="l01726"></a>01726     x = gB;
<a name="l01727"></a>01727 
<a name="l01728"></a>01728     gsl_matrix_free(gA);
<a name="l01729"></a>01729     gsl_vector_free(gB);
<a name="l01730"></a>01730 <span class="preprocessor">#else</span>
<a name="l01731"></a>01731 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;solveLinear: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l01732"></a>01732 <span class="preprocessor">#endif</span>
<a name="l01733"></a>01733 <span class="preprocessor"></span>        }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="keywordtype">void</span> solveLinear(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l01736"></a>01736     {
<a name="l01737"></a>01737         std::cout &lt;&lt; <span class="stringliteral">&quot;solveLinear DEPRECATED, use any of the following functions instead, depending on your needs:\n&quot;</span>
<a name="l01738"></a>01738                      <span class="stringliteral">&quot;solveBySingularValueDecomposition\n&quot;</span>
<a name="l01739"></a>01739                      <span class="stringliteral">&quot;solveByCholeskyDecomposition\n&quot;</span>
<a name="l01740"></a>01740                      <span class="stringliteral">&quot;solveByLUDecomposition\n&quot;</span>
<a name="l01741"></a>01741                      <span class="stringliteral">&quot;solveByQRDecomposition\n&quot;</span>
<a name="l01742"></a>01742                      <span class="stringliteral">&quot;(see QVision documentation for details):\n&quot;</span>;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01745"></a>01745     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == X.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01746"></a>01746     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == B.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l01749"></a>01749 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> dimN = A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l01750"></a>01750     <span class="keyword">const</span> <span class="keywordtype">int</span> numS = X.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l01751"></a>01751     <span class="keywordtype">int</span> signum;
<a name="l01752"></a>01752 
<a name="l01753"></a>01753     <span class="keywordtype">double</span> *dataX = X.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l01754"></a>01754     <span class="keyword">const</span> <span class="keywordtype">double</span> *dataB = B.<a class="code" href="classQVMatrix.html#a50de15cc657c8a1d9fcc749161192a64" title="Gets a read-only reference to the data buffer of the matrix.">getReadData</a>();
<a name="l01755"></a>01755 
<a name="l01756"></a>01756     gsl_matrix *a = A;
<a name="l01757"></a>01757     gsl_permutation *p = gsl_permutation_alloc(dimN);
<a name="l01758"></a>01758     gsl_vector *b = gsl_vector_alloc(dimN);
<a name="l01759"></a>01759     gsl_vector *x = gsl_vector_alloc(dimN);
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     gsl_linalg_LU_decomp(a, p, &amp;signum);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> sist = 0; sist &lt; numS; sist++)
<a name="l01764"></a>01764         {
<a name="l01765"></a>01765         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; dimN; i++)
<a name="l01766"></a>01766             b-&gt;data[i] = dataB[i*numS + sist];
<a name="l01767"></a>01767 
<a name="l01768"></a>01768         gsl_linalg_LU_solve(a, p, b, x);
<a name="l01769"></a>01769 
<a name="l01770"></a>01770         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; dimN; i++)
<a name="l01771"></a>01771             dataX[i*numS + sist] = x-&gt;data[i];
<a name="l01772"></a>01772         }
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     gsl_matrix_free(a);
<a name="l01775"></a>01775     gsl_permutation_free(p);
<a name="l01776"></a>01776     gsl_vector_free(b);
<a name="l01777"></a>01777     gsl_vector_free(x);
<a name="l01778"></a>01778 <span class="preprocessor">#else</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;solveLinear: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l01780"></a>01780 <span class="preprocessor">#endif</span>
<a name="l01781"></a>01781 <span class="preprocessor"></span>        }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="keywordtype">void</span> solveOverDetermined(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l01784"></a>01784     {
<a name="l01785"></a>01785         std::cout &lt;&lt; <span class="stringliteral">&quot;solveOverDetermined DEPRECATED, use any of the following functions instead:\n&quot;</span>
<a name="l01786"></a>01786                      <span class="stringliteral">&quot;solveBySingularValueDecomposition\n&quot;</span>
<a name="l01787"></a>01787                      <span class="stringliteral">&quot;solveByQRDecomposition\n&quot;</span>
<a name="l01788"></a>01788                      <span class="stringliteral">&quot;(see QVision documentation for details):\n&quot;</span>;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() &lt;= A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01791"></a>01791     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == X.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01792"></a>01792     Q_ASSERT(A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == B.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>());
<a name="l01793"></a>01793 
<a name="l01794"></a>01794 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l01795"></a>01795 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> dim1 = A.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l01796"></a>01796     <span class="keyword">const</span> <span class="keywordtype">int</span> dim2 = A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l01797"></a>01797     <span class="keyword">const</span> <span class="keywordtype">int</span> numS = X.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     <span class="keywordtype">double</span> *dataX = X.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l01800"></a>01800     <span class="keyword">const</span> <span class="keywordtype">double</span> *dataB = B.<a class="code" href="classQVMatrix.html#a50de15cc657c8a1d9fcc749161192a64" title="Gets a read-only reference to the data buffer of the matrix.">getReadData</a>();
<a name="l01801"></a>01801 
<a name="l01802"></a>01802     gsl_matrix *u = A;
<a name="l01803"></a>01803     gsl_vector *s = gsl_vector_alloc(dim2);
<a name="l01804"></a>01804     gsl_matrix *v = gsl_matrix_alloc(dim2, dim2);
<a name="l01805"></a>01805     gsl_vector *workV = gsl_vector_alloc(dim2);
<a name="l01806"></a>01806     gsl_matrix *workM = gsl_matrix_alloc(dim2,dim2);
<a name="l01807"></a>01807     gsl_vector *b = gsl_vector_alloc(dim1);
<a name="l01808"></a>01808     gsl_vector *x = gsl_vector_alloc(dim2);
<a name="l01809"></a>01809 
<a name="l01810"></a>01810     gsl_linalg_SV_decomp_mod(u, workM, v, s, workV);
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> sist = 0; sist &lt; numS; sist++)
<a name="l01813"></a>01813         {
<a name="l01814"></a>01814         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; dim1; i++)
<a name="l01815"></a>01815             b-&gt;data[i] = dataB[i*numS + sist];
<a name="l01816"></a>01816 
<a name="l01817"></a>01817         gsl_linalg_SV_solve(u, v, s, b, x);
<a name="l01818"></a>01818 
<a name="l01819"></a>01819         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; dim2; i++)
<a name="l01820"></a>01820             dataX[i*numS + sist] = x-&gt;data[i];
<a name="l01821"></a>01821         }
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     gsl_matrix_free(u);
<a name="l01824"></a>01824     gsl_vector_free(s);
<a name="l01825"></a>01825     gsl_matrix_free(v);
<a name="l01826"></a>01826     gsl_vector_free(workV);
<a name="l01827"></a>01827     gsl_matrix_free(workM);
<a name="l01828"></a>01828     gsl_vector_free(b);
<a name="l01829"></a>01829     gsl_vector_free(x);
<a name="l01830"></a>01830 <span class="preprocessor">#else</span>
<a name="l01831"></a>01831 <span class="preprocessor"></span>        qFatal(<span class="stringliteral">&quot;solveLinear: cannot use GSL methods if GSL library is not available.&quot;</span>);
<a name="l01832"></a>01832 <span class="preprocessor">#endif</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span>        }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835 <span class="keywordtype">void</span> solveHomogeneousLinear(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, QVector&lt;double&gt; &amp;x)
<a name="l01836"></a>01836     {
<a name="l01837"></a>01837         std::cout &lt;&lt; <span class="stringliteral">&quot;solveHomogeneousLinear DEPRECATED, use solveHomogeneous function instead (see QVision documentation).&quot;</span>
<a name="l01838"></a>01838                   &lt;&lt; std::endl;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> U, V, S;
<a name="l01841"></a>01841         SingularValueDecomposition(A, U, S, V<span class="comment">/*, LAPACK_THIN_DGESDD*/</span>);
<a name="l01842"></a>01842         <span class="comment">/* LAPACK_FULL_DGESDD, LAPACK_THIN_DGESVD, LAPACK_THIN_DGESDD */</span>
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     x = V.<a class="code" href="classQVMatrix.html#a476e9d1714f98c1ae1b7c1d396fcdbaa" title="Gets a column of the matrix.">getCol</a>(V.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>()-1);
<a name="l01845"></a>01845     }
<a name="l01846"></a>01846 
<a name="l01847"></a>01847 <span class="comment">// Adjust a line to given first and second order moments, and returns ratio of eigenvalues:</span>
<a name="l01848"></a>01848 <span class="keywordtype">double</span> homogLineFromMoments(<span class="keywordtype">double</span> x,<span class="keywordtype">double</span> y,<span class="keywordtype">double</span> xx,<span class="keywordtype">double</span> xy,<span class="keywordtype">double</span> yy,<span class="keywordtype">double</span> &amp;a,<span class="keywordtype">double</span> &amp;b,<span class="keywordtype">double</span> &amp;c)
<a name="l01849"></a>01849         {
<a name="l01850"></a>01850     <span class="keywordtype">double</span> a11=xx-x*x, a12=xy-x*y, a22=yy-y*y, temp, e1, e2, angle, cosangle, sinangle;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852     <span class="comment">// Validity check:</span>
<a name="l01853"></a>01853     temp = sqrt(a11*a11+4*a12*a12-2*a11*a22+a22*a22);
<a name="l01854"></a>01854     e1 = a11+a22-temp;
<a name="l01855"></a>01855     e2 = a11+a22+temp;
<a name="l01856"></a>01856     <span class="keywordflow">if</span>(e2&lt;EPSILON)
<a name="l01857"></a>01857         {
<a name="l01858"></a>01858         <span class="comment">/*std::cerr &lt;&lt; &quot; a11=&quot; &lt;&lt; a11 &lt;&lt; &quot; a12=&quot; &lt;&lt; a12 &lt;&lt; &quot; a22=&quot; &lt;&lt; a22</span>
<a name="l01859"></a>01859 <span class="comment">        &lt;&lt; &quot; x=&quot; &lt;&lt; x &lt;&lt; &quot; y=&quot; &lt;&lt; y &lt;&lt; &quot; xx=&quot; &lt;&lt; xx &lt;&lt; &quot; xy=&quot; &lt;&lt; xy &lt;&lt; &quot; yy=&quot; &lt;&lt; yy</span>
<a name="l01860"></a>01860 <span class="comment">        &lt;&lt; &quot;: Impossible moments in homogLineFromMoments!\n&quot;;*/</span>
<a name="l01861"></a>01861         <span class="keywordflow">return</span> 1.0;
<a name="l01862"></a>01862         }
<a name="l01863"></a>01863     <span class="keywordflow">if</span>(fabs(e1)/e2 &gt; 0.9)
<a name="l01864"></a>01864         {
<a name="l01865"></a>01865         <span class="comment">/*std::cerr &lt;&lt; &quot;Too high ratio of eigenvalues e1=&quot; &lt;&lt; e1 &lt;&lt; &quot;e2=&quot; &lt;&lt; e2 &lt;&lt;&quot;: No principal direction in homogLineFromMoments!\n&quot;;</span>
<a name="l01866"></a>01866 <span class="comment">        std::cerr &lt;&lt; &quot; a11=&quot; &lt;&lt; a11 &lt;&lt; &quot; a12=&quot; &lt;&lt; a12 &lt;&lt; &quot; a22=&quot; &lt;&lt; a22 &lt;&lt; &quot;\n&quot;;*/</span>
<a name="l01867"></a>01867         <span class="keywordflow">return</span> fabs(e1)/e2;
<a name="l01868"></a>01868         }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870     <span class="keywordflow">if</span>(fabs(a12)&gt;EPSILON)
<a name="l01871"></a>01871         angle = atan2(2*a12,a11-a22+temp);
<a name="l01872"></a>01872     <span class="keywordflow">else</span>
<a name="l01873"></a>01873     <span class="keywordflow">if</span>(a11&gt;=a22)
<a name="l01874"></a>01874         angle = 0;
<a name="l01875"></a>01875     <span class="keywordflow">else</span>
<a name="l01876"></a>01876         angle = PI/2;
<a name="l01877"></a>01877     <span class="keywordflow">if</span>(angle &lt; 0)
<a name="l01878"></a>01878         angle += PI;
<a name="l01879"></a>01879     cosangle = cos(angle); sinangle = sin(angle);
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     <span class="comment">//Standard deviation in perpendicular direction:</span>
<a name="l01882"></a>01882     <span class="comment">//desv_perp = sqrt(fabs(a11+a22-temp)/2.0);</span>
<a name="l01883"></a>01883     a = -sinangle; b = cosangle; c = x*sinangle-y*cosangle;
<a name="l01884"></a>01884     <span class="keywordflow">return</span> fabs(e1)/e2;
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886 
<a name="l01887"></a><a class="code" href="qvmatrixalgebra_8cpp.html#a2a11aaeedc4d76975389706a8e27defc">01887</a> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> <a class="code" href="qvmatrixalgebra_8cpp.html#a2a11aaeedc4d76975389706a8e27defc">regressionLine</a>(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;points)
<a name="l01888"></a>01888     {
<a name="l01890"></a>01890     <span class="keywordtype">double</span> x = 0, y = 0, xx = 0, yy = 0, xy = 0;
<a name="l01891"></a>01891     <span class="keyword">const</span> <span class="keywordtype">int</span> rows = points.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>();
<a name="l01892"></a>01892 
<a name="l01893"></a>01893     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++)
<a name="l01894"></a>01894         {
<a name="l01895"></a>01895         <span class="keywordtype">double</span> xActual = points(i,0), yActual = points(i,1);
<a name="l01896"></a>01896         x += xActual;
<a name="l01897"></a>01897         y += yActual;
<a name="l01898"></a>01898         xx += xActual*xActual;
<a name="l01899"></a>01899         xy += xActual*yActual;
<a name="l01900"></a>01900         yy += yActual*yActual;
<a name="l01901"></a>01901         }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     x /= rows; y /= rows; xx /= rows; xy /= rows; yy /= rows;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905     <span class="keywordtype">double</span> a, b, c;
<a name="l01906"></a>01906     <span class="keywordflow">if</span> (homogLineFromMoments(x,y,xx,xy,yy,a,b,c))
<a name="l01907"></a>01907         {
<a name="l01908"></a>01908         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> result(3);
<a name="l01909"></a>01909         result[0] = a; result[1] = b; result[2] = c;
<a name="l01910"></a>01910         <span class="keywordflow">return</span> result;
<a name="l01911"></a>01911         }
<a name="l01912"></a>01912     <span class="keywordflow">else</span>
<a name="l01913"></a>01913         <span class="keywordflow">return</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>();
<a name="l01914"></a>01914     }
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 <span class="comment">// Initialization for the MKL DSS method requires some milliseconds.</span>
<a name="l01917"></a>01917 <span class="comment">// Avoid that &#39;cold-start&#39; time in your code calling to this function</span>
<a name="l01918"></a>01918 <span class="keywordtype">void</span> cold_start_mkl_initialization(<span class="keyword">const</span> <span class="keywordtype">int</span> size)
<a name="l01919"></a>01919     {
<a name="l01920"></a>01920     <span class="comment">// COLD START FOR MKL DSS ROUTINE</span>
<a name="l01921"></a>01921 <span class="preprocessor">    #define COLD_START_MATRIX_SIZE      size</span>
<a name="l01922"></a>01922 <span class="preprocessor"></span>    <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> A = <a class="code" href="classQVMatrix.html#ad2840553c7fa2cf81c8ce982db34b7b4" title="Creates a matrix of random values.">QVMatrix::random</a>(COLD_START_MATRIX_SIZE,COLD_START_MATRIX_SIZE);
<a name="l01923"></a>01923     <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> sparseM(1, 1, COLD_START_MATRIX_SIZE, COLD_START_MATRIX_SIZE);
<a name="l01924"></a>01924     sparseM.setBlock(0, 0, A.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>() * A);
<a name="l01925"></a>01925     <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> xInc(COLD_START_MATRIX_SIZE, 0.0), b = <a class="code" href="classQVVector.html#ac550cb33a94138c6a55901bc2dc23558" title="Creates a vector of random values.">QVVector::random</a>(COLD_START_MATRIX_SIZE);
<a name="l01926"></a>01926     <a class="code" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158" title="Solves a sparse system of linear equations, taking advantage of sparseness to accelerate...">sparseSolve</a>(sparseM, xInc, b, <span class="keyword">true</span>, <span class="keyword">true</span>, <a class="code" href="group__qvmatrixalgebra.html#ggaacdaea1a26a36293bfb60ca30909ba42a1a4b4a69b2ed71568ebe6c71ed7672cd" title="Intel MKL direct sparse solver.">QVMKL_DSS</a>, <span class="keyword">true</span>, <span class="keyword">true</span>, 10);
<a name="l01927"></a>01927     }
<a name="l01928"></a>01928 
<a name="l01929"></a>01929 <span class="comment">// ---------------------------------------------------------------------------------------------------</span>
<a name="l01930"></a>01930 <span class="comment">// Deprecated</span>
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="keywordtype">void</span> SingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l01933"></a>01933     {
<a name="l01934"></a>01934     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SingularValueDecomposition&#39; deprecated. Use &#39;singularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01935"></a>01935     <a class="code" href="group__qvmatrixalgebra.html#gabe654b66e21aa3d27131c5f65fcc9dfb" title="Obtains the Singular Value Decomposition (SVD) of a rectangular  matrix M.">singularValueDecomposition</a>(M, U, s, V, method);
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937 
<a name="l01938"></a>01938 <span class="keywordtype">void</span> SolveFromSingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l01939"></a>01939     {
<a name="l01940"></a>01940     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromSingularValueDecomposition&#39; deprecated. Use &#39;solveFromSingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01941"></a>01941     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U, s, V, X, B);
<a name="l01942"></a>01942     }
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 <span class="keywordtype">void</span> SolveFromSingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l01945"></a>01945     {
<a name="l01946"></a>01946     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromSingularValueDecomposition&#39; deprecated. Use &#39;solveFromSingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01947"></a>01947     <a class="code" href="group__qvmatrixalgebra.html#gae7291c840628d8c7f67f90096f470351" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromSingularValueDecomposition</a>(U, s, V, x, b);
<a name="l01948"></a>01948     }
<a name="l01949"></a>01949 
<a name="l01950"></a>01950 <span class="keywordtype">void</span> SolveBySingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method )
<a name="l01951"></a>01951     {
<a name="l01952"></a>01952     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveBySingularValueDecomposition&#39; deprecated. Use &#39;solveBySingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01953"></a>01953     <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(M, X, B, method);
<a name="l01954"></a>01954     }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956 <span class="keywordtype">void</span> SolveBySingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method )
<a name="l01957"></a>01957     {
<a name="l01958"></a>01958     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveBySingularValueDecomposition&#39; deprecated. Use &#39;solveBySingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01959"></a>01959     <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(M, x, b, method);
<a name="l01960"></a>01960     }
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 <span class="keywordtype">void</span> SolveBySingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l01963"></a>01963     {
<a name="l01964"></a>01964     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveBySingularValueDecomposition&#39; deprecated. Use &#39;solveBySingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01965"></a>01965     <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(M, X, B, U, s, V, method);
<a name="l01966"></a>01966     }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <span class="keywordtype">void</span> SolveBySingularValueDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l01969"></a>01969     {
<a name="l01970"></a>01970     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveBySingularValueDecomposition&#39; deprecated. Use &#39;solveBySingularValueDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01971"></a>01971     <a class="code" href="group__qvmatrixalgebra.html#gac5e38c9a7f64b9c7785f4d353c0b9ada" title="Solves the linear system  for the unknown vector , using the singular value decomposition...">solveBySingularValueDecomposition</a>(M, x, b, U, s, V, method);
<a name="l01972"></a>01972     }
<a name="l01973"></a>01973 
<a name="l01974"></a>01974 <span class="keywordtype">double</span> SingularValueDecompositionResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;V)
<a name="l01975"></a>01975     {
<a name="l01976"></a>01976     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SingularValueDecompositionResidual&#39; deprecated. Use &#39;singularValueDecompositionResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01977"></a>01977     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga78792d4a8a6337b8b92a86a07ede57ac" title="Checks for correctness of the SVD of a matrix.">singularValueDecompositionResidual</a>(M, U, s, V);
<a name="l01978"></a>01978     }
<a name="l01979"></a>01979 
<a name="l01980"></a>01980 <span class="keywordtype">void</span> SingularValues(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gae838fb93502416d5876dd38769e3c5a0" title="Available methods for Singular Values only computation (SV).">TQVSV_Method</a> method)
<a name="l01981"></a>01981     {
<a name="l01982"></a>01982     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SingularValues&#39; deprecated. Use &#39;singularValues&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01983"></a>01983     <a class="code" href="group__qvmatrixalgebra.html#ga5d6aa6239753252830669883619f5da7" title="Gets the singular values of a matrix.">singularValues</a>(M, s, method);
<a name="l01984"></a>01984     }
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="keywordtype">double</span> SingularValuesResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;s)
<a name="l01987"></a>01987     {
<a name="l01988"></a>01988     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SingularValuesResidual&#39; deprecated. Use &#39;singularValuesResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01989"></a>01989     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga7e4b10036a1a456b58ffcb0ad0e30d52" title="Checks for correctness of the singular values of a matrix.">singularValuesResidual</a>(M, s);
<a name="l01990"></a>01990     }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992 <span class="keywordtype">void</span> SolveFromCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l01993"></a>01993     {
<a name="l01994"></a>01994     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromCholeskyDecomposition&#39; deprecated. Use &#39;solveFromCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l01995"></a>01995     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L, X, B);
<a name="l01996"></a>01996     }
<a name="l01997"></a>01997 
<a name="l01998"></a>01998 <span class="keywordtype">void</span> SolveFromCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l01999"></a>01999     {
<a name="l02000"></a>02000     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromCholeskyDecomposition&#39; deprecated. Use &#39;solveFromCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02001"></a>02001     <a class="code" href="group__qvmatrixalgebra.html#gafc11c4eb4acc7453b7bed072d6bf0a76" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromCholeskyDecomposition</a>(L, x, b);
<a name="l02002"></a>02002     }
<a name="l02003"></a>02003 
<a name="l02004"></a>02004 <span class="keywordtype">void</span> SolveByCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l02005"></a>02005     {
<a name="l02006"></a>02006     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByCholeskyDecomposition&#39; deprecated. Use &#39;solveByCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02007"></a>02007     <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(M, X, B, method);
<a name="l02008"></a>02008     }
<a name="l02009"></a>02009 
<a name="l02010"></a>02010 <span class="keywordtype">void</span> SolveByCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l02011"></a>02011     {
<a name="l02012"></a>02012     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByCholeskyDecomposition&#39; deprecated. Use &#39;solveByCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02013"></a>02013     <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(M, x, b, method);
<a name="l02014"></a>02014     }
<a name="l02015"></a>02015 
<a name="l02016"></a>02016 <span class="keywordtype">void</span> SolveByCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l02017"></a>02017     {
<a name="l02018"></a>02018     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByCholeskyDecomposition&#39; deprecated. Use &#39;solveByCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02019"></a>02019     <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(M, X, B, L, method);
<a name="l02020"></a>02020     }
<a name="l02021"></a>02021 
<a name="l02022"></a>02022 <span class="keywordtype">void</span> SolveByCholeskyDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gac52aa1a4772c42c68e53baf5a22e15c8" title="Available methods for Cholesky Decomposition.">TQVCholesky_Method</a> method)
<a name="l02023"></a>02023     {
<a name="l02024"></a>02024     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByCholeskyDecomposition&#39; deprecated. Use &#39;solveByCholeskyDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02025"></a>02025     <a class="code" href="group__qvmatrixalgebra.html#ga7afb7ef53aed190e810886e4941bc3de" title="Solves the linear system  for the unknown matrix , using the Cholesky decomposition...">solveByCholeskyDecomposition</a>(M, x, b, L, method);
<a name="l02026"></a>02026     }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028 <span class="keywordtype">void</span> SolveFromLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l02029"></a>02029     {
<a name="l02030"></a>02030     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromLUDecomposition&#39; deprecated. Use &#39;solveFromLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02031"></a>02031     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P, L, U, X, B);
<a name="l02032"></a>02032     }
<a name="l02033"></a>02033 
<a name="l02034"></a>02034 <span class="keywordtype">void</span> SolveFromLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l02035"></a>02035     {
<a name="l02036"></a>02036     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromLUDecomposition&#39; deprecated. Use &#39;solveFromLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02037"></a>02037     <a class="code" href="group__qvmatrixalgebra.html#gaa964f05ab494b8a34381d6fa81ce2076" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromLUDecomposition</a>(P, L, U, x, b);
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 <span class="keywordtype">void</span> SolveByLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l02041"></a>02041     {
<a name="l02042"></a>02042     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByLUDecomposition&#39; deprecated. Use &#39;solveByLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02043"></a>02043     <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(M, X, B, method);
<a name="l02044"></a>02044     }
<a name="l02045"></a>02045 
<a name="l02046"></a>02046 <span class="keywordtype">void</span> SolveByLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l02047"></a>02047     {
<a name="l02048"></a>02048     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByLUDecomposition&#39; deprecated. Use &#39;solveByLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02049"></a>02049     <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(M, x, b, method);
<a name="l02050"></a>02050     }
<a name="l02051"></a>02051 
<a name="l02052"></a>02052 <span class="keywordtype">void</span> SolveByLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l02053"></a>02053     {
<a name="l02054"></a>02054     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByLUDecomposition&#39; deprecated. Use &#39;solveByLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02055"></a>02055     <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(M, X, B, P, L, U, method);
<a name="l02056"></a>02056     }
<a name="l02057"></a>02057 
<a name="l02058"></a>02058 <span class="keywordtype">void</span> SolveByLUDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b,<a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;P, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;L, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;U, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga3b29cddbb2d5f75b1278f8a6d4abd736" title="Available methods for LU Decomposition.">TQVLU_Method</a> method)
<a name="l02059"></a>02059     {
<a name="l02060"></a>02060     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByLUDecomposition&#39; deprecated. Use &#39;solveByLUDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02061"></a>02061     <a class="code" href="group__qvmatrixalgebra.html#ga1e0e534e13e16518cc1c1aa750357a3c" title="Solves the linear system  for the unknown matrix , using the LU decomposition .">solveByLUDecomposition</a>(M, x, b, P, L, U, method);
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 <span class="keywordtype">void</span> SolveFromQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l02065"></a>02065     {
<a name="l02066"></a>02066     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromQRDecomposition&#39; deprecated. Use &#39;solveFromQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02067"></a>02067     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q, R, X, B);
<a name="l02068"></a>02068     }
<a name="l02069"></a>02069 
<a name="l02070"></a>02070 <span class="keywordtype">void</span> SolveFromQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l02071"></a>02071     {
<a name="l02072"></a>02072     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveFromQRDecomposition&#39; deprecated. Use &#39;solveFromQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02073"></a>02073     <a class="code" href="group__qvmatrixalgebra.html#ga4c9f02ada4121317c084f1c7ec09e17c" title="Solves the linear system  for the unknown matrix , using the previously obtained...">solveFromQRDecomposition</a>(Q, R, x, b);
<a name="l02074"></a>02074     }
<a name="l02075"></a>02075 
<a name="l02076"></a>02076 <span class="keywordtype">void</span> SolveByQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l02077"></a>02077     {
<a name="l02078"></a>02078     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByQRDecomposition&#39; deprecated. Use &#39;solveByQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02079"></a>02079     <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(M, X, B, method);
<a name="l02080"></a>02080     }
<a name="l02081"></a>02081 
<a name="l02082"></a>02082 <span class="keywordtype">void</span> SolveByQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l02083"></a>02083     {
<a name="l02084"></a>02084     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByQRDecomposition&#39; deprecated. Use &#39;solveByQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02085"></a>02085     <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(M, x, b, method);
<a name="l02086"></a>02086     }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 <span class="keywordtype">void</span> SolveByQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l02089"></a>02089     {
<a name="l02090"></a>02090     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByQRDecomposition&#39; deprecated. Use &#39;solveByQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02091"></a>02091     <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(M, X, B, Q, R, method);
<a name="l02092"></a>02092     }
<a name="l02093"></a>02093 
<a name="l02094"></a>02094 <span class="keywordtype">void</span> SolveByQRDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;R, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga34489f7f981fd3ad10dcd6e287644c21" title="Available methods for QR Decomposition.">TQVQR_Method</a> method)
<a name="l02095"></a>02095     {
<a name="l02096"></a>02096     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveByQRDecomposition&#39; deprecated. Use &#39;solveByQRDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02097"></a>02097     <a class="code" href="group__qvmatrixalgebra.html#ga35e4e3e2dd0a5ebbd93f672bf569e4a3" title="Solves the linear system  for the unknown vector , using the QR decomposition of...">solveByQRDecomposition</a>(M, x, b, Q, R, method);
<a name="l02098"></a>02098     }
<a name="l02099"></a>02099 
<a name="l02100"></a>02100 <span class="keywordtype">void</span> EigenDecomposition(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gae21e0895ad3ca32f8fdc58b4bf22bec8" title="Available methods for EigenDecomposition.">TQVEigenDecomposition_Method</a> method)
<a name="l02101"></a>02101     {
<a name="l02102"></a>02102     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;EigenDecomposition&#39; deprecated. Use &#39;eigenDecomposition&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02103"></a>02103     <a class="code" href="group__qvmatrixalgebra.html#gae95e6a42f2cce467f30a55289a0f9824" title="Obtains the eigen-decomposition of a symmetric matrix.">eigenDecomposition</a>(M, lambda, Q, method);
<a name="l02104"></a>02104     }
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 <span class="keywordtype">double</span> EigenDecompositionResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;Q)
<a name="l02107"></a>02107     {
<a name="l02108"></a>02108     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;EigenDecompositionResidual&#39; deprecated. Use &#39;eigenDecompositionResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02109"></a>02109     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga5ccc97075c8c8d5340dd6b8b2ace3190" title="Checks for correctness of the eigendecomposition of a matrix.">eigenDecompositionResidual</a>(M, lambda, Q);
<a name="l02110"></a>02110     }
<a name="l02111"></a>02111 
<a name="l02112"></a>02112 <span class="keywordtype">void</span> EigenValues(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#ga4d0b532a36bb590714b98f651a87f9d2" title="Available methods for EigenValues only computation.">TQVEigenValues_Method</a> method)
<a name="l02113"></a>02113     {
<a name="l02114"></a>02114     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;EigenValues&#39; deprecated. Use &#39;eigenValues&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02115"></a>02115     <a class="code" href="group__qvmatrixalgebra.html#gabbfe32bf1d0c4def6ecb805bca65d03c" title="Gets the eigenvalues of a matrix.">eigenValues</a>(M, lambda, method);
<a name="l02116"></a>02116     }
<a name="l02117"></a>02117 
<a name="l02118"></a>02118 <span class="keywordtype">double</span> EigenValuesResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;lambda)
<a name="l02119"></a>02119     {
<a name="l02120"></a>02120     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;EigenValuesResidual&#39; deprecated. Use &#39;eigenValuesResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02121"></a>02121     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga124008527c22895b3dc8b828eb867306" title="Checks for correctness of the eigenvalues of a symmetric matrix.">eigenValuesResidual</a>(M, lambda);
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 
<a name="l02124"></a>02124 <span class="keywordtype">void</span> SolveHomogeneous(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;A, QVector&lt;double&gt; &amp;x, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gad753ba41cd08df7e8d4173d8c2ac2575" title="Available methods for Singular Value Decomposition (SVD).">TQVSVD_Method</a> method)
<a name="l02125"></a>02125     {
<a name="l02126"></a>02126     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveHomogeneous&#39; deprecated. Use &#39;solveHomogeneous&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02127"></a>02127     <a class="code" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4" title="Solves an homogeneous linear system of equations.">solveHomogeneous</a>(A, x, method);
<a name="l02128"></a>02128     }
<a name="l02129"></a>02129 
<a name="l02130"></a>02130 <span class="keywordtype">double</span> SolveResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;X, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;B)
<a name="l02131"></a>02131     {
<a name="l02132"></a>02132     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveResidual&#39; deprecated. Use &#39;solveResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02133"></a>02133     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572" title="Returns the residual of the solution to a linear matrix equation.">solveResidual</a>(M, X, B);
<a name="l02134"></a>02134     }
<a name="l02135"></a>02135 
<a name="l02136"></a>02136 <span class="keywordtype">double</span> SolveResidual(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;b)
<a name="l02137"></a>02137     {
<a name="l02138"></a>02138     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveResidual&#39; deprecated. Use &#39;solveResidual&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02139"></a>02139     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#ga70717e261a395b8c380c4321dbb12572" title="Returns the residual of the solution to a linear matrix equation.">solveResidual</a>(M, x, b);
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141 
<a name="l02142"></a>02142 <span class="keywordtype">double</span> SparseSolve(     <span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> b, <span class="keyword">const</span> <span class="keywordtype">bool</span> isSymmetric, <span class="keyword">const</span> <span class="keywordtype">bool</span> isPosDefinite, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42" title="Available methods for sparse linear system solving.">TQVSparseSolve_Method</a> method,
<a name="l02143"></a>02143             <span class="keyword">const</span> <span class="keywordtype">bool</span> start_from_x, <span class="keyword">const</span> <span class="keywordtype">bool</span> iters_or_resid, <span class="keyword">const</span> <span class="keywordtype">int</span> iters, <span class="keyword">const</span> <span class="keywordtype">double</span> resid, <span class="keywordtype">int</span> &amp;final_iter_count)
<a name="l02144"></a>02144     {
<a name="l02145"></a>02145     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SparseSolve&#39; deprecated. Use &#39;sparseSolve&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02146"></a>02146     <span class="keywordflow">return</span> <a class="code" href="group__qvmatrixalgebra.html#gaf7293f186086b4b233cf51046f016158" title="Solves a sparse system of linear equations, taking advantage of sparseness to accelerate...">sparseSolve</a>(M, x, b, isSymmetric, isPosDefinite, method, start_from_x, iters_or_resid, iters, resid, final_iter_count);
<a name="l02147"></a>02147     }
<a name="l02148"></a>02148 
<a name="l02149"></a>02149 <span class="keywordtype">void</span> SolveHomogeneous(<span class="keyword">const</span> <a class="code" href="classQVSparseBlockMatrix.html" title="Implementation of sparse block matrices.">QVSparseBlockMatrix</a> &amp;A, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;x, <span class="keyword">const</span> <span class="keywordtype">int</span> maxIterations, <span class="keyword">const</span> <span class="keywordtype">double</span> minRelativeError, <span class="keyword">const</span> <a class="code" href="group__qvmatrixalgebra.html#gaacdaea1a26a36293bfb60ca30909ba42" title="Available methods for sparse linear system solving.">TQVSparseSolve_Method</a> method)
<a name="l02150"></a>02150     {
<a name="l02151"></a>02151     std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: &#39;SolveHomogeneous&#39; deprecated. Use &#39;solveHomogeneous&#39; instead.&quot;</span> &lt;&lt; std::endl;
<a name="l02152"></a>02152     <a class="code" href="group__qvmatrixalgebra.html#gabcefb2cb61ed46e61130f4892308fee4" title="Solves an homogeneous linear system of equations.">solveHomogeneous</a>(A, x, maxIterations, minRelativeError, method);
<a name="l02153"></a>02153     }
<a name="l02154"></a>02154 
<a name="l02155"></a>02155 <span class="preprocessor">#ifdef GSL_AVAILABLE</span>
<a name="l02156"></a>02156 <span class="preprocessor"></span><span class="comment">// Internal use only. Fast function for homogeneous solving.</span>
<a name="l02157"></a>02157 <span class="keywordtype">void</span> solveHomogeneousEig(<span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;M, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;result)
<a name="l02158"></a>02158     {
<a name="l02159"></a>02159     <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> A = M.<a class="code" href="classQVMatrix.html#a5470e61c2827d5485596c3901690154c" title="Matrix-matrix product.">dotProduct</a>(M,<span class="keyword">true</span>,<span class="keyword">false</span>);
<a name="l02160"></a>02160     <span class="keyword">const</span> <span class="keywordtype">int</span> n = A.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>();
<a name="l02161"></a>02161     gsl_matrix m;
<a name="l02162"></a>02162     m.size1 = m.size2 = m.tda = n;
<a name="l02163"></a>02163     m.data = A.<a class="code" href="classQVMatrix.html#a0c5b1e685d14d230c55cfcfb058e372a" title="Gets a reference of the data buffer of the matrix for read and write accesses.">getWriteData</a>();
<a name="l02164"></a>02164     m.block = NULL;
<a name="l02165"></a>02165     m.owner = 1;
<a name="l02166"></a>02166 
<a name="l02167"></a>02167     gsl_vector *eval = gsl_vector_alloc (n);
<a name="l02168"></a>02168     gsl_matrix *evec = gsl_matrix_alloc (n, n);
<a name="l02169"></a>02169     gsl_eigen_symmv_workspace *w = gsl_eigen_symmv_alloc (n);
<a name="l02170"></a>02170     gsl_eigen_symmv (&amp;m, eval, evec, w);
<a name="l02171"></a>02171     gsl_eigen_symmv_sort (eval, evec, GSL_EIGEN_SORT_VAL_DESC);
<a name="l02172"></a>02172     gsl_eigen_symmv_free (w);
<a name="l02173"></a>02173     gsl_vector_free (eval);
<a name="l02174"></a>02174 
<a name="l02175"></a>02175     result = <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(n);
<a name="l02176"></a>02176     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
<a name="l02177"></a>02177         result[i] = gsl_matrix_get(evec,i,n-1);
<a name="l02178"></a>02178 
<a name="l02179"></a>02179     gsl_matrix_free (evec);
<a name="l02180"></a>02180     }
<a name="l02181"></a>02181 <span class="preprocessor">#endif</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
