<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>QVImage&lt; Type, Channels &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__qvip.html">Image processing</a>]</small>
</h1><!-- doxytag: class="QVImage" --><!-- doxytag: inherits="QVGenericImage" -->
<p>Image representation class for the QVision.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qvimage_8h_source.html">QVImage</a>&gt;</code></p>

<p>Inherits <a class="el" href="classQVGenericImage.html">QVGenericImage</a>.</p>

<p><a href="classQVImage-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a87e4a3ea6bc2db99d0fe170ac8b21b1f">QVImage</a> (uInt cols=1, uInt rows=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a87e4a3ea6bc2db99d0fe170ac8b21b1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ace50f548bf3fa469eb47b933c2035690">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ace50f548bf3fa469eb47b933c2035690"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a0b5454af230d9acd72ddb3a30577c9eb">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a0b5454af230d9acd72ddb3a30577c9eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ad7d6e30612c95684d59d6daa4925f53e">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 1 &gt; const &amp;img)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a303afe5c7d2a227befc6303465984ec8">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a303afe5c7d2a227befc6303465984ec8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a68c896d6ce8c2a2ea3c8ac1459ffb30a">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a68c896d6ce8c2a2ea3c8ac1459ffb30a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a80eaaa6624571390646ab80b785e6f3c">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a80eaaa6624571390646ab80b785e6f3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5ac787f4d850296aa6b3ec72294a5aec">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a5ac787f4d850296aa6b3ec72294a5aec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5a6b75b27ecaf1e4faac04458338d62d">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a5a6b75b27ecaf1e4faac04458338d62d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ac9a4477f531fce77559b69f9ea3c9b16">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#ac9a4477f531fce77559b69f9ea3c9b16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#aa67b7a28fb4fd09981ef4093f2979961">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#aa67b7a28fb4fd09981ef4093f2979961"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a83e16b6938af2929874d6422a5c458ab">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a83e16b6938af2929874d6422a5c458ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a9887ce79d1d61fe76f25eccd322216c8">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a9887ce79d1d61fe76f25eccd322216c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a0d8c1ff65fbcc0ba8b9f188abfc2a3ff">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a0d8c1ff65fbcc0ba8b9f188abfc2a3ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a7e2572eb34936f9cae70f5e857e5bb24">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 3 &gt; const &amp;img)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy constructor.  <a href="#a7e2572eb34936f9cae70f5e857e5bb24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a4415e3727eb0d435036c75a58c41bf10">QVImage</a> (const QString &amp;filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a561acecc86434195b956fdd3522e647e">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;red, <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;green, <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose copy constructor.  <a href="#a561acecc86434195b956fdd3522e647e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a399459ea46e10770d6132951993638a6">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;red, <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;green, <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded compose copy constructor.  <a href="#a399459ea46e10770d6132951993638a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a157389cca693828417300178793fd3f1">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;red, <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;green, <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded compose copy constructor.  <a href="#a157389cca693828417300178793fd3f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a2f02163b2f1fb75590f1c6f8c1ce045c">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;red, <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;green, <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded compose copy constructor.  <a href="#a2f02163b2f1fb75590f1c6f8c1ce045c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a9bfd6e801925f782d73f8c1bd28f0c72">QVImage</a> (<a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;red, <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;green, <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded compose copy constructor.  <a href="#a9bfd6e801925f782d73f8c1bd28f0c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5448f8d71a6ce0bbf459a5b3d7c6e60c">QVImage</a> (const QImage &amp;qImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert constructor for QImage objects.  <a href="#a5448f8d71a6ce0bbf459a5b3d7c6e60c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a32786513dbed5b1277fdd08aca880d78">operator QImage</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> to a QImage object.  <a href="#a32786513dbed5b1277fdd08aca880d78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ab698fef2425b5309a05649c7c4b1525d">QVImage</a> (const IplImage *iplImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert constructor from OpenCV image objects (IplImage).  <a href="#ab698fef2425b5309a05649c7c4b1525d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5f0d4b9b20553387175ae0b0c658a6c6">operator IplImage *</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> to an OpenCV image object (IplImage).  <a href="#a5f0d4b9b20553387175ae0b0c658a6c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#aa8e2a101e62cdaa7d0fa7c020f625171">getTypeQString</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f" title="Obtain a char string identifying the type of the image. real image contained in the...">QVGenericImage::getTypeQString()</a>.  <a href="#aa8e2a101e62cdaa7d0fa7c020f625171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a55e71ad628f450ee82bb4226cb62ec17">getRows</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a8731e208b2f33a3ab1795fc4389f1ef3" title="Virtual method for getting the number of rows of the image.">QVGenericImage::getRows()</a>.  <a href="#a55e71ad628f450ee82bb4226cb62ec17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ad0f2758702ee4d96d538aa353ae81bb7">getCols</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a398764a3e00a553dd8ac75f78f6bf18a" title="Virtual method for getting the number of columns of the image.">QVGenericImage::getCols()</a>.  <a href="#ad0f2758702ee4d96d538aa353ae81bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a8c5cb45d0c7fbf135d89c5cb40ed4875">getStep</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a73b40cb2faa1943637116da270da800d" title="Virtual method for getting the row step of the image.">QVGenericImage::getStep()</a>.  <a href="#a8c5cb45d0c7fbf135d89c5cb40ed4875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5d430b0f71799b2b2ca8f8ae8f05ca3c">getChannels</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a3dde18969f0fe8ed9079d21540e3fc13" title="Virtual method for getting the number of channels of the image.">QVGenericImage::getChannels()</a>.  <a href="#a5d430b0f71799b2b2ca8f8ae8f05ca3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a397ee658c9574be3013a68c584b3f9d0">getDataSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a93cd55976a2289ba45d154c210597ea3" title="Virtual method for getting data size for the image.">QVGenericImage::getDataSize()</a>.  <a href="#a397ee658c9574be3013a68c584b3f9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uInt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a70e75bb386d5b424f266a62d000e52bf">getTypeSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded function from <a class="el" href="classQVGenericImage.html#a7429b1cdaa57edfcd7edfad8204c9024" title="Virtual method for getting bit depth of the image, in bytes.">QVGenericImage::getTypeSize()</a>.  <a href="#a70e75bb386d5b424f266a62d000e52bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Type *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a200b9b19dbe2a79f75d603f9ecc67bf1">getReadData</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to obtain image data buffer, in read mode.  <a href="#a200b9b19dbe2a79f75d603f9ecc67bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Type *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a231507d781e33e508fac771b5284c3c9">getWriteData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to obtain image data buffer, in read/write mode.  <a href="#a231507d781e33e508fac771b5284c3c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#addec4b1d837eb849d4b8605c1a86e3ac">set</a> (Type c1=0, Type c2=0, Type c3=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets pixel values for an image, to a given value.  <a href="#addec4b1d837eb849d4b8605c1a86e3ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ad69afa02dba6c9351cd3a16c29a4dce3">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the image is empty.  <a href="#ad69afa02dba6c9351cd3a16c29a4dce3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#abadb4ee2e54af167f6c80e247bf397cb">resize</a> (const int cols, const int rows)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the image.  <a href="#abadb4ee2e54af167f6c80e247bf397cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ab0f7c3d022a614cfb614c1b9fa8fd9b1">operator()</a> (const uInt col, const uInt row, const uInt channel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator to access pixel values for a pixel channel, given it's coordinates.  <a href="#ab0f7c3d022a614cfb614c1b9fa8fd9b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a923f82b6c7a2aeb5b5ef072860db9402">operator()</a> (const QPoint point, const uInt channel=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of operator (), to access pixel values for a pixel channel, given a QVPoint and a channel number.  <a href="#a923f82b6c7a2aeb5b5ef072860db9402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#af710e6e447f428ac01b0485c075315f2">operator()</a> (const uInt channel=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator to access pixel values for a pixel channel, given it's coordinates.  <a href="#af710e6e447f428ac01b0485c075315f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a3af2bb0d8e7fde9e2f6c778c4d7f23f9">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy operator.  <a href="#a3af2bb0d8e7fde9e2f6c778c4d7f23f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a540489c365419c8ba69631e4b8990242">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a540489c365419c8ba69631e4b8990242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#af135c7f46ac4890171b40eed31ce0718">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a046cc1bf4f14a7f8b359575366710739">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a046cc1bf4f14a7f8b359575366710739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ace925131622fdd17cb6a27cb87e91622">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#ace925131622fdd17cb6a27cb87e91622"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ae2386f631d272214bed8b1fd572fe2b4">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#ae2386f631d272214bed8b1fd572fe2b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a2f484d916f8888c6d3f51f91f1d36ed8">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a2f484d916f8888c6d3f51f91f1d36ed8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#abf620083c92cdc477f05872c82c65c89">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#abf620083c92cdc477f05872c82c65c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a3d221c1e02dffe9ba8b3d6e009dc52db">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a3d221c1e02dffe9ba8b3d6e009dc52db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ad65abc950f31339c2aa0294fd01f871b">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#ad65abc950f31339c2aa0294fd01f871b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a3ee88c54754fb107612a7becec982283">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a3ee88c54754fb107612a7becec982283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#afdc80320663f54860a6541030bd4a030">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#afdc80320663f54860a6541030bd4a030"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a621328747cffb8a2fb7dac91e7ffee9e">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a621328747cffb8a2fb7dac91e7ffee9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a83b874a6f925ef39265c3cea1d90caa2">operator=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 3 &gt; &amp;sourceImage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded copy operator.  <a href="#a83b874a6f925ef39265c3cea1d90caa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qvip.html#gad9b6ff6909da8e12d4c231500673d128">operator==</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality compare operator.  <a href="group__qvip.html#gad9b6ff6909da8e12d4c231500673d128"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a711605fe3079ed219867bd0c121a6726">operator!=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality compare operator.  <a href="#a711605fe3079ed219867bd0c121a6726"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#af6d740c62e447391106880b3bf4395c2">operator&lt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less than' compare operator.  <a href="#af6d740c62e447391106880b3bf4395c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#adcf4f5231bc72199068371199b34ce9c">operator&lt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less than' compare operator.  <a href="#adcf4f5231bc72199068371199b34ce9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a518e4c1bf6cd33a80c7c58a699c9c824">operator&lt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less than' compare operator.  <a href="#a518e4c1bf6cd33a80c7c58a699c9c824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a4e0924d6958c7f4f90be9ce65ae50755">operator&lt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less than' compare operator.  <a href="#a4e0924d6958c7f4f90be9ce65ae50755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a945fff634385b9f45dd164ecf9a4bf20">operator&lt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less than' compare operator.  <a href="#a945fff634385b9f45dd164ecf9a4bf20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a84defb58ab6c7c37a6c5e32a676c8155">operator&gt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater than' compare operator.  <a href="#a84defb58ab6c7c37a6c5e32a676c8155"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a7273af2c1c151a617b61a5075afcd9fd">operator&gt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater than' compare operator.  <a href="#a7273af2c1c151a617b61a5075afcd9fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a4848d665c762292664e2fe3a993a4aab">operator&gt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater than' compare operator.  <a href="#a4848d665c762292664e2fe3a993a4aab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#aa7e3abc72637e215078f769b83c2ae92">operator&gt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater than' compare operator.  <a href="#aa7e3abc72637e215078f769b83c2ae92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#afeaf1ded443756c60cd3d859ef0ba418">operator&gt;</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater than' compare operator.  <a href="#afeaf1ded443756c60cd3d859ef0ba418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a02c0d4b4a12bcfab61498c2b9f6eded8">operator&lt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less or equal than' compare operator.  <a href="#a02c0d4b4a12bcfab61498c2b9f6eded8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a133cfe9bcd8e7648f4f7bd2a14246d0f">operator&lt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less or equal than' compare operator.  <a href="#a133cfe9bcd8e7648f4f7bd2a14246d0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#af2f0602efc216991f1484756ce524ad3">operator&lt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less or equal than' compare operator.  <a href="#af2f0602efc216991f1484756ce524ad3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a6504831315915d366f2adf3e0c5d5981">operator&lt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less or equal than' compare operator.  <a href="#a6504831315915d366f2adf3e0c5d5981"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a0927cb1b154e0e502f46989279f35565">operator&lt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'less or equal than' compare operator.  <a href="#a0927cb1b154e0e502f46989279f35565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ab69223019a34542ef32ed9bdb56e6d9b">operator&gt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater or equal than' compare operator.  <a href="#ab69223019a34542ef32ed9bdb56e6d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a896e769e1e87810253a90736d60d9f16">operator&gt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater or equal than' compare operator.  <a href="#a896e769e1e87810253a90736d60d9f16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ae743a09e3a64e26c03eb4768a9fc4a6d">operator&gt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater or equal than' compare operator.  <a href="#ae743a09e3a64e26c03eb4768a9fc4a6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a6321d6989881a05fb864514e33786d17">operator&gt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater or equal than' compare operator.  <a href="#a6321d6989881a05fb864514e33786d17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a030527e91441086e7d3a042021d90077">operator&gt;=</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise 'greater or equal than' compare operator.  <a href="#a030527e91441086e7d3a042021d90077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a446a88f9290f14cb4cf9f93a4d5600fa">operator+</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise constant add operator.  <a href="#a446a88f9290f14cb4cf9f93a4d5600fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a37d4560acc3253c15ef377c60f7c0df4">operator*</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise constant product operator.  <a href="#a37d4560acc3253c15ef377c60f7c0df4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a955eab9bd6ba4582331d4f3834c27f96">operator-</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise constant subtraction operator.  <a href="#a955eab9bd6ba4582331d4f3834c27f96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a78d47c71ce0669bd78469cc75de823c7">operator/</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise constant division operator.  <a href="#a78d47c71ce0669bd78469cc75de823c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a61d7b5a18ab0774073e408d62c0a1a4c">operator&lt;&lt;</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise left shift operator.  <a href="#a61d7b5a18ab0774073e408d62c0a1a4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ab0d33365ec2a80cb154b812cfdf34d5c">operator&gt;&gt;</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise right shift operator.  <a href="#ab0d33365ec2a80cb154b812cfdf34d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a92d847580d4d8ff7c435beddb696cd33">operator!</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise NOT operation.  <a href="#a92d847580d4d8ff7c435beddb696cd33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a9edb618e4cbd6803f8ab64593380882a">operator&amp;</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise boolean and operator.  <a href="#a9edb618e4cbd6803f8ab64593380882a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#ac5a3f4f32627c88e66ed30edeb60f73d">operator|</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise boolean or operator.  <a href="#ac5a3f4f32627c88e66ed30edeb60f73d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a546ab721d0c37c727785194e3b0e443a">operator^</a> (const Type constant) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise bit-wise boolean xor operator.  <a href="#a546ab721d0c37c727785194e3b0e443a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#adfeba51bee210af2222fbbb9b2ff9ccb">operator+</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise add operator.  <a href="#adfeba51bee210af2222fbbb9b2ff9ccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a1777f27e4ed78711aa3dbd09eb5b9ac2">operator*</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise mult operator.  <a href="#a1777f27e4ed78711aa3dbd09eb5b9ac2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#a992c90d4bdf39e9bc0edc00868ccca85">operator-</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise subtraction operator.  <a href="#a992c90d4bdf39e9bc0edc00868ccca85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQVImage.html#abace2731ce10598de32940ff98e26a3d">operator/</a> (const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;img) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel wise division operator.  <a href="#abace2731ce10598de32940ff98e26a3d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#aa5abf377f3c4f95d128270d351b8269c">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#aa5abf377f3c4f95d128270d351b8269c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a250fd54325bf7b45311081f10d6a7d21">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a250fd54325bf7b45311081f10d6a7d21"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a26060f0d5c591843b2b47c8c33a55b77">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a26060f0d5c591843b2b47c8c33a55b77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a82511ed913536f548b1f5e10e7f8f4a1">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a82511ed913536f548b1f5e10e7f8f4a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#ab9e7c91408e79a5fc6a2a48f0b4bbcdd">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#ab9e7c91408e79a5fc6a2a48f0b4bbcdd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#aa9826942b7de555975fb354ef38bd76f">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#aa9826942b7de555975fb354ef38bd76f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a1da886203b77c0baac9a9a8e5e31fbbb">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a1da886203b77c0baac9a9a8e5e31fbbb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a23e0b7fcceda1b493c384991aecff5ab">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a23e0b7fcceda1b493c384991aecff5ab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#af223ffd23a8459c984a6cd9dad9864e7">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#af223ffd23a8459c984a6cd9dad9864e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a5449f66a7fd6c95310376ed220ba38fb">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a5449f66a7fd6c95310376ed220ba38fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#acd4dc980bb4626fb93142fffb06bd422">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#acd4dc980bb4626fb93142fffb06bd422"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQVImage.html#a851df498210edde9a152910076c12244">getTypeQString</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>.  <a href="#a851df498210edde9a152910076c12244"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Type = uChar, int Channels = 1&gt;<br/>
 class QVImage&lt; Type, Channels &gt;</h3>

<p>Image representation class for the QVision. </p>
<p><a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> class extends <a class="el" href="classQVGenericImage.html">QVGenericImage</a>, and wraps the data buffer and other values related to an image in a simple and lightweight structure, easy to use.</p>
<p>For further info about image objects and image usage, see section BasicImageProcessing of the manual.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Type</em>&nbsp;</td><td>Pixel storage type. Can be <em>uChar</em>, <em>sChar</em>, <em>uShort</em>, <em>sShort</em>, <em>uLong</em>, <em>sLong</em>, <em>sFloat</em> or <em>sDouble</em>. For further info see section <a class="el" href="TheQVImageClass.html">The QVImage class</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channels</em>&nbsp;</td><td>Number of channels in the image. Usually 1 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00201">201</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a87e4a3ea6bc2db99d0fe170ac8b21b1f"></a><!-- doxytag: member="QVImage::QVImage" ref="a87e4a3ea6bc2db99d0fe170ac8b21b1f" args="(uInt cols=1, uInt rows=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype">uInt&nbsp;</td>
          <td class="paramname"> <em>cols</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uInt&nbsp;</td>
          <td class="paramname"> <em>rows</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cols</em>&nbsp;</td><td>number of columns for the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rows</em>&nbsp;</td><td>number of rows for the image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00236">236</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="ace50f548bf3fa469eb47b933c2035690"></a><!-- doxytag: member="QVImage::QVImage" ref="ace50f548bf3fa469eb47b933c2035690" args="(QVImage&lt; uChar, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>This constructor can be used to construct an image from another one with same bit depth and channel number, or from an image differing in type or number of channels.</p>
<p>In the former case, this constructor will do a copy-on-write, duplicating the pointer to the data buffer of the image, and effectively copying the data only when modifying it if shared by more than one <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> object.</p>
<p>In the latter case, it will always allocate a new data buffer for the image, and make a conversion from different bit depth or channel number. Note that you can never convert from an image that differs in data type and bit-depth with the constructed image.</p>
<p>This constructor will copy the ROI and anchor of the parameter image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b5454af230d9acd72ddb3a30577c9eb"></a><!-- doxytag: member="QVImage::QVImage" ref="a0b5454af230d9acd72ddb3a30577c9eb" args="(QVImage&lt; uChar, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="ad7d6e30612c95684d59d6daa4925f53e"></a><!-- doxytag: member="QVImage::QVImage" ref="ad7d6e30612c95684d59d6daa4925f53e" args="(QVImage&lt; sChar, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a303afe5c7d2a227befc6303465984ec8"></a><!-- doxytag: member="QVImage::QVImage" ref="a303afe5c7d2a227befc6303465984ec8" args="(QVImage&lt; sChar, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a68c896d6ce8c2a2ea3c8ac1459ffb30a"></a><!-- doxytag: member="QVImage::QVImage" ref="a68c896d6ce8c2a2ea3c8ac1459ffb30a" args="(QVImage&lt; uShort, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a80eaaa6624571390646ab80b785e6f3c"></a><!-- doxytag: member="QVImage::QVImage" ref="a80eaaa6624571390646ab80b785e6f3c" args="(QVImage&lt; uShort, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a5ac787f4d850296aa6b3ec72294a5aec"></a><!-- doxytag: member="QVImage::QVImage" ref="a5ac787f4d850296aa6b3ec72294a5aec" args="(QVImage&lt; sShort, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a5a6b75b27ecaf1e4faac04458338d62d"></a><!-- doxytag: member="QVImage::QVImage" ref="a5a6b75b27ecaf1e4faac04458338d62d" args="(QVImage&lt; sShort, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="ac9a4477f531fce77559b69f9ea3c9b16"></a><!-- doxytag: member="QVImage::QVImage" ref="ac9a4477f531fce77559b69f9ea3c9b16" args="(QVImage&lt; uInt, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="aa67b7a28fb4fd09981ef4093f2979961"></a><!-- doxytag: member="QVImage::QVImage" ref="aa67b7a28fb4fd09981ef4093f2979961" args="(QVImage&lt; uInt, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a83e16b6938af2929874d6422a5c458ab"></a><!-- doxytag: member="QVImage::QVImage" ref="a83e16b6938af2929874d6422a5c458ab" args="(QVImage&lt; sInt, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a9887ce79d1d61fe76f25eccd322216c8"></a><!-- doxytag: member="QVImage::QVImage" ref="a9887ce79d1d61fe76f25eccd322216c8" args="(QVImage&lt; sInt, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a0d8c1ff65fbcc0ba8b9f188abfc2a3ff"></a><!-- doxytag: member="QVImage::QVImage" ref="a0d8c1ff65fbcc0ba8b9f188abfc2a3ff" args="(QVImage&lt; sFloat, 1 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a7e2572eb34936f9cae70f5e857e5bb24"></a><!-- doxytag: member="QVImage::QVImage" ref="a7e2572eb34936f9cae70f5e857e5bb24" args="(QVImage&lt; sFloat, 3 &gt; const &amp;img)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy constructor. </p>

</div>
</div>
<a class="anchor" id="a4415e3727eb0d435036c75a58c41bf10"></a><!-- doxytag: member="QVImage::QVImage" ref="a4415e3727eb0d435036c75a58c41bf10" args="(const QString &amp;filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>document this function </dd></dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00302">302</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a561acecc86434195b956fdd3522e647e"></a><!-- doxytag: member="QVImage::QVImage" ref="a561acecc86434195b956fdd3522e647e" args="(QVImage&lt; uChar, 1 &gt; const &amp;red, QVImage&lt; uChar, 1 &gt; const &amp;green, QVImage&lt; uChar, 1 &gt; const &amp;blue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compose copy constructor. </p>
<p>This constructor can be used to construct a 3-channels image from 3 1-channel images.</p>
<p>This constructor will copy the ROI and anchor of the first parameter image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>red</em>&nbsp;</td><td>image to be copied to the first channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>green</em>&nbsp;</td><td>image to be copied to the second channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blue</em>&nbsp;</td><td>image to be copied to the third channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a399459ea46e10770d6132951993638a6"></a><!-- doxytag: member="QVImage::QVImage" ref="a399459ea46e10770d6132951993638a6" args="(QVImage&lt; uShort, 1 &gt; const &amp;red, QVImage&lt; uShort, 1 &gt; const &amp;green, QVImage&lt; uShort, 1 &gt; const &amp;blue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded compose copy constructor. </p>

</div>
</div>
<a class="anchor" id="a157389cca693828417300178793fd3f1"></a><!-- doxytag: member="QVImage::QVImage" ref="a157389cca693828417300178793fd3f1" args="(QVImage&lt; sShort, 1 &gt; const &amp;red, QVImage&lt; sShort, 1 &gt; const &amp;green, QVImage&lt; sShort, 1 &gt; const &amp;blue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded compose copy constructor. </p>

</div>
</div>
<a class="anchor" id="a2f02163b2f1fb75590f1c6f8c1ce045c"></a><!-- doxytag: member="QVImage::QVImage" ref="a2f02163b2f1fb75590f1c6f8c1ce045c" args="(QVImage&lt; sInt, 1 &gt; const &amp;red, QVImage&lt; sInt, 1 &gt; const &amp;green, QVImage&lt; sInt, 1 &gt; const &amp;blue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded compose copy constructor. </p>

</div>
</div>
<a class="anchor" id="a9bfd6e801925f782d73f8c1bd28f0c72"></a><!-- doxytag: member="QVImage::QVImage" ref="a9bfd6e801925f782d73f8c1bd28f0c72" args="(QVImage&lt; sFloat, 1 &gt; const &amp;red, QVImage&lt; sFloat, 1 &gt; const &amp;green, QVImage&lt; sFloat, 1 &gt; const &amp;blue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded compose copy constructor. </p>

</div>
</div>
<a class="anchor" id="a5448f8d71a6ce0bbf459a5b3d7c6e60c"></a><!-- doxytag: member="QVImage::QVImage" ref="a5448f8d71a6ce0bbf459a5b3d7c6e60c" args="(const QImage &amp;qImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype">const QImage &amp;&nbsp;</td>
          <td class="paramname"> <em>qImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert constructor for QImage objects. </p>

</div>
</div>
<a class="anchor" id="ab698fef2425b5309a05649c7c4b1525d"></a><!-- doxytag: member="QVImage::QVImage" ref="ab698fef2425b5309a05649c7c4b1525d" args="(const IplImage *iplImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::<a class="el" href="classQVImage.html">QVImage</a> </td>
          <td>(</td>
          <td class="paramtype">const IplImage *&nbsp;</td>
          <td class="paramname"> <em>iplImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert constructor from OpenCV image objects (IplImage). </p>
<p>This function creates an image object importing the data from an OpenCV image (IplImage).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>OpenCV compatibility option must be enabled at the QVision library compilation to use this constructor </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iplImage</em>&nbsp;</td><td>pointer to the IplImage </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator IplImage *() const </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a32786513dbed5b1277fdd08aca880d78"></a><!-- doxytag: member="QVImage::operator QImage" ref="a32786513dbed5b1277fdd08aca880d78" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator QImage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> to a QImage object. </p>

</div>
</div>
<a class="anchor" id="a5f0d4b9b20553387175ae0b0c658a6c6"></a><!-- doxytag: member="QVImage::operator IplImage *" ref="a5f0d4b9b20553387175ae0b0c658a6c6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator IplImage * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> to an OpenCV image object (IplImage). </p>
<p>This function creates a new IplImage object with the same dimensions and content of the actual image. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>OpenCV compatibility option must be enabled at the QVision library compilation to use this constructor </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQVImage.html#ab698fef2425b5309a05649c7c4b1525d" title="Convert constructor from OpenCV image objects (IplImage).">QVImage(const IplImage *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa8e2a101e62cdaa7d0fa7c020f625171"></a><!-- doxytag: member="QVImage::getTypeQString" ref="aa8e2a101e62cdaa7d0fa7c020f625171" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f" title="Obtain a char string identifying the type of the image. real image contained in the...">QVGenericImage::getTypeQString()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

</div>
</div>
<a class="anchor" id="a55e71ad628f450ee82bb4226cb62ec17"></a><!-- doxytag: member="QVImage::getRows" ref="a55e71ad628f450ee82bb4226cb62ec17" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getRows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a8731e208b2f33a3ab1795fc4389f1ef3" title="Virtual method for getting the number of rows of the image.">QVGenericImage::getRows()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a8731e208b2f33a3ab1795fc4389f1ef3">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00364">364</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#ga16d78d75712d628864cbfcd0e9622052">applyHomography()</a>, <a class="el" href="group__qvip.html#ga192921df3cd4daafb183772dc960d138">CountingSort()</a>, <a class="el" href="classQVKLTTracker.html#a6047e10322f0d4ed95ad61a787fdfebb">QVKLTTracker::detect()</a>, <a class="el" href="group__qvip.html#ga48592e8d0ecc14b8a01c373e97a0b630">FASTFeatures()</a>, <a class="el" href="group__qvip.html#ga0a73e3730368b307c874e53dd5af54c4">FastLaplaceFilter()</a>, <a class="el" href="group__qvip.html#ga69cc8d72179389d9897aa9ac97d62c33">FastSmoothFilter()</a>, <a class="el" href="group__qvipp.html#ga26877fdb37dbf494fa5672d84b7d3519">FilterDoG()</a>, <a class="el" href="group__qvip.html#gade8ced9dc785b2238de521daff597b13">FilterLocalMax()</a>, <a class="el" href="group__qvipp.html#gaacf3624cc8f531fccb9a436878af3fba">FilterSeparable()</a>, <a class="el" href="group__qvip.html#gacfe3100b9457c7fe9965a0b0e937ba24">getConnectedSetBorderContoursThreshold()</a>, <a class="el" href="classQVBRIEFDetector.html#a0882e01e86c84b45d5c9f6e138af2cca">QVBRIEFDetector::getDescriptors()</a>, <a class="el" href="classQVVideoReader.html#a7c9765c5ed51cdf2349e456dc7a6f3f2">QVVideoReader::getGrayImage()</a>, <a class="el" href="group__qvip.html#ga5dab7ea4ed1170143df3e59fdd895bf9">getLineContoursThreshold4Connectivity()</a>, <a class="el" href="group__qvip.html#ga804db01dcec15dce0c303ed4a4715bd6">getLineContoursThreshold8Connectivity()</a>, <a class="el" href="group__qvmser.html#ga7270e20566a7ad57a59acb4844ca4921">getLTMSER()</a>, <a class="el" href="group__qvip.html#ga782538a21f9e2ea0aef216b54cbf0570">getMSERContours()</a>, <a class="el" href="classQVVideoReader.html#a7922b56a1ea4e76444aeda9ea4a3d093">QVVideoReader::getRGBImage()</a>, <a class="el" href="group__qvsiftgpu.html#ga84ba9885258ee2d66f7a577ea09a4062">getSiftGPUFeatures()</a>, <a class="el" href="classQVVideoReader.html#af79c7379cbbfc613b64d21a74eb7f8eb">QVVideoReader::getYUVImage()</a>, <a class="el" href="classQVVideoReader.html#a9dacd1ed256f1f48a193314d7e876140">QVVideoReader::grab()</a>, <a class="el" href="qvip_8cpp.html#ad59b48c43b863530b8ef45a61ef250e7">myFloodFill()</a>, <a class="el" href="classQVImage.html#ab0f7c3d022a614cfb614c1b9fa8fd9b1">QVImage&lt; uChar, 3 &gt;::operator()()</a>, <a class="el" href="group__qvip.html#gad9b6ff6909da8e12d4c231500673d128">QVImage&lt; Type, Channels &gt;::operator==()</a>, <a class="el" href="classQVComponentTree.html#ac807f5189700723202a4b5f120fd2e57">QVComponentTree::QVComponentTree()</a>, <a class="el" href="classQVImage.html#a5448f8d71a6ce0bbf459a5b3d7c6e60c">QVImage&lt; uChar, 3 &gt;::QVImage()</a>, <a class="el" href="classQVKLTTracker.html#affe245d7de2e04d06d4bca4439d80009">QVKLTTracker::redetect()</a>, <a class="el" href="classQVImage.html#abadb4ee2e54af167f6c80e247bf397cb">QVImage&lt; uChar, 3 &gt;::resize()</a>, <a class="el" href="group__qvip.html#ga083ddecc2c02b1aa32bd2dd9d6c69601">SmoothFilter()</a>, <a class="el" href="classQVKLTTracker.html#a03abf973b520dbd9ce624c5977b973ba">QVKLTTracker::track()</a>, <a class="el" href="classQVCUDAImage.html#afc679c7ec7a57687d282a486ccaaef17">QVCUDAImage&lt; Type, Channels &gt;::uploadToDevice()</a>, and <a class="el" href="group__qvip.html#ga0eee999bb396163138cd084286249a05">writeYUV4MPEG2Frame()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0f2758702ee4d96d538aa353ae81bb7"></a><!-- doxytag: member="QVImage::getCols" ref="ad0f2758702ee4d96d538aa353ae81bb7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getCols </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a398764a3e00a553dd8ac75f78f6bf18a" title="Virtual method for getting the number of columns of the image.">QVGenericImage::getCols()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a398764a3e00a553dd8ac75f78f6bf18a">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00367">367</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="group__qvprojectivegeometry.html#ga16d78d75712d628864cbfcd0e9622052">applyHomography()</a>, <a class="el" href="group__qvip.html#ga192921df3cd4daafb183772dc960d138">CountingSort()</a>, <a class="el" href="classQVKLTTracker.html#a6047e10322f0d4ed95ad61a787fdfebb">QVKLTTracker::detect()</a>, <a class="el" href="group__qvip.html#ga48592e8d0ecc14b8a01c373e97a0b630">FASTFeatures()</a>, <a class="el" href="group__qvip.html#ga0a73e3730368b307c874e53dd5af54c4">FastLaplaceFilter()</a>, <a class="el" href="group__qvip.html#ga69cc8d72179389d9897aa9ac97d62c33">FastSmoothFilter()</a>, <a class="el" href="group__qvipp.html#ga26877fdb37dbf494fa5672d84b7d3519">FilterDoG()</a>, <a class="el" href="group__qvip.html#gade8ced9dc785b2238de521daff597b13">FilterLocalMax()</a>, <a class="el" href="group__qvipp.html#gaacf3624cc8f531fccb9a436878af3fba">FilterSeparable()</a>, <a class="el" href="group__qvip.html#gacfe3100b9457c7fe9965a0b0e937ba24">getConnectedSetBorderContoursThreshold()</a>, <a class="el" href="classQVBRIEFDetector.html#a0882e01e86c84b45d5c9f6e138af2cca">QVBRIEFDetector::getDescriptors()</a>, <a class="el" href="classQVVideoReader.html#a7c9765c5ed51cdf2349e456dc7a6f3f2">QVVideoReader::getGrayImage()</a>, <a class="el" href="group__qvip.html#ga5dab7ea4ed1170143df3e59fdd895bf9">getLineContoursThreshold4Connectivity()</a>, <a class="el" href="group__qvip.html#ga804db01dcec15dce0c303ed4a4715bd6">getLineContoursThreshold8Connectivity()</a>, <a class="el" href="group__qvmser.html#ga7270e20566a7ad57a59acb4844ca4921">getLTMSER()</a>, <a class="el" href="group__qvip.html#ga782538a21f9e2ea0aef216b54cbf0570">getMSERContours()</a>, <a class="el" href="classQVVideoReader.html#a7922b56a1ea4e76444aeda9ea4a3d093">QVVideoReader::getRGBImage()</a>, <a class="el" href="classQVVideoReader.html#af79c7379cbbfc613b64d21a74eb7f8eb">QVVideoReader::getYUVImage()</a>, <a class="el" href="classQVVideoReader.html#a9dacd1ed256f1f48a193314d7e876140">QVVideoReader::grab()</a>, <a class="el" href="qvip_8cpp.html#ad59b48c43b863530b8ef45a61ef250e7">myFloodFill()</a>, <a class="el" href="classQVImage.html#ab0f7c3d022a614cfb614c1b9fa8fd9b1">QVImage&lt; uChar, 3 &gt;::operator()()</a>, <a class="el" href="group__qvip.html#gad9b6ff6909da8e12d4c231500673d128">QVImage&lt; Type, Channels &gt;::operator==()</a>, <a class="el" href="classQVComponentTree.html#ac807f5189700723202a4b5f120fd2e57">QVComponentTree::QVComponentTree()</a>, <a class="el" href="classQVImage.html#a5448f8d71a6ce0bbf459a5b3d7c6e60c">QVImage&lt; uChar, 3 &gt;::QVImage()</a>, <a class="el" href="classQVKLTTracker.html#affe245d7de2e04d06d4bca4439d80009">QVKLTTracker::redetect()</a>, <a class="el" href="classQVImage.html#abadb4ee2e54af167f6c80e247bf397cb">QVImage&lt; uChar, 3 &gt;::resize()</a>, <a class="el" href="group__qvip.html#ga083ddecc2c02b1aa32bd2dd9d6c69601">SmoothFilter()</a>, <a class="el" href="classQVKLTTracker.html#a03abf973b520dbd9ce624c5977b973ba">QVKLTTracker::track()</a>, <a class="el" href="classQVCUDAImage.html#afc679c7ec7a57687d282a486ccaaef17">QVCUDAImage&lt; Type, Channels &gt;::uploadToDevice()</a>, and <a class="el" href="group__qvip.html#ga0eee999bb396163138cd084286249a05">writeYUV4MPEG2Frame()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c5cb45d0c7fbf135d89c5cb40ed4875"></a><!-- doxytag: member="QVImage::getStep" ref="a8c5cb45d0c7fbf135d89c5cb40ed4875" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getStep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a73b40cb2faa1943637116da270da800d" title="Virtual method for getting the row step of the image.">QVGenericImage::getStep()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a73b40cb2faa1943637116da270da800d">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00370">370</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="group__qvippIAALO.html#ga63c39cf1436d95d0979ca8e9464e6167">Abs()</a>, <a class="el" href="group__qvippIAALO.html#ga3590c52ad9bdc161f350b49277b13a65">AbsDiff()</a>, <a class="el" href="group__qvippIAALO.html#ga44cde4bf9c772056004a9fc94fd4123b">Add()</a>, <a class="el" href="group__qvippIAALO.html#ga79125dd2c16c07ab21c9bf8ca78a7583">AddC()</a>, <a class="el" href="group__qvippIDEAIF.html#ga0f8ef21d706b4ac63b913eee414bc891">AddRandUniform_Direct()</a>, <a class="el" href="group__qvippIAALO.html#gae788b457daf219808755a533ec16aa98">And()</a>, <a class="el" href="group__qvippIAALO.html#ga2f1da78d1e68b39a8462228bc78d5343">AndC()</a>, <a class="el" href="group__qvippCV.html#ga56269a74576283f8743352552aadc12a">Canny()</a>, <a class="el" href="group__qvippTACO.html#gacfe8d6c3fe355a5ebbfd5d919411f787">Compare()</a>, <a class="el" href="group__qvippTACO.html#ga57cc9276708cb5ff3dace1640356af0d">CompareC()</a>, <a class="el" href="group__qvippTACO.html#gaf8eb6e174a20b48eebcbf80f3c04b37d">ComputeThreshold_Otsu()</a>, <a class="el" href="group__qvippIDEAIF.html#gaf06a00b7fdd224fed5534c9de89e1d0d">Convert()</a>, <a class="el" href="group__qvippIDEAIF.html#ga64a91daa77c57e0f93dbe10b8d5ff3f8">Copy()</a>, <a class="el" href="group__qvippMO.html#ga06522a34f60319acd1200610bb7f381e">Dilate()</a>, <a class="el" href="group__qvippCV.html#gaf6656a4313795ffc3b9467f3cc306006">DistanceTransform_5x5()</a>, <a class="el" href="group__qvippIAALO.html#gaf3539de07571607988bf21e9ba9d4622">Div()</a>, <a class="el" href="group__qvippIAALO.html#ga8d63a381e75d25e92bb083eddbcf0961">DivC()</a>, <a class="el" href="classQVCUDAImage.html#aaf6520232ea4609f1aec970e60b2b488">QVCUDAImage&lt; Type, Channels &gt;::downloadFromDevice()</a>, <a class="el" href="group__qvippMO.html#gaec4a680ae5ed084aecff6eb0b594face">Erode()</a>, <a class="el" href="group__qvip.html#ga48592e8d0ecc14b8a01c373e97a0b630">FASTFeatures()</a>, <a class="el" href="group__qvip.html#ga0a73e3730368b307c874e53dd5af54c4">FastLaplaceFilter()</a>, <a class="el" href="group__qvippCV.html#ga7f456ffa2169dd985fb607bd0a66a33a">FastMarching()</a>, <a class="el" href="group__qvipp.html#gaa3b64cec3b1037dc5935e6c37ef277e6">fastMaximalPoints()</a>, <a class="el" href="group__qvip.html#ga69cc8d72179389d9897aa9ac97d62c33">FastSmoothFilter()</a>, <a class="el" href="group__qvippFF.html#ga6d8b00040deb1afc4a23e856f5157907">Filter()</a>, <a class="el" href="group__qvippFF.html#ga2d118e9683ff100e1ae96b54158040ca">FilterBox()</a>, <a class="el" href="group__qvippFF.html#ga5386b7a396525c51c65fbbe60ea83c9f">FilterColumn()</a>, <a class="el" href="group__qvippFF.html#gae5c1010fcf026e45590b363519769da5">FilterGauss()</a>, <a class="el" href="group__qvippFF.html#ga103146095de7a376dfb779a63e6a0f6a">FilterHipass()</a>, <a class="el" href="group__qvippFF.html#ga5ea3603eeaf76f10efb5582e4b67ded0">FilterLaplace()</a>, <a class="el" href="group__qvippFF.html#ga216b6082d331960a7f06427bd71e30c9">FilterLowpass()</a>, <a class="el" href="group__qvippFF.html#ga30636f7f21a0c31e2be512cd81885276">FilterMax()</a>, <a class="el" href="group__qvippFF.html#ga4939840684f7d21b53310482b5302a3f">FilterMedian()</a>, <a class="el" href="group__qvippFF.html#ga56326921b1584946f8b42c7976354dcd">FilterMedianColor()</a>, <a class="el" href="group__qvippFF.html#ga2a35b35050509de3e580c0b8e8a8b057">FilterMedianCross()</a>, <a class="el" href="group__qvippFF.html#gaa60c522dfe683cf577e01467744e871a">FilterMedianHoriz()</a>, <a class="el" href="group__qvippFF.html#gae4625d68fdea1f80866a957cffa7e631">FilterMedianVert()</a>, <a class="el" href="group__qvippFF.html#ga314ef0125c72a7fadb509ef5ca3c8c5d">FilterMedianWeightedCenter3x3()</a>, <a class="el" href="group__qvippFF.html#gafd3151bc8843f531b4dd3c80a905774b">FilterMin()</a>, <a class="el" href="group__qvippFF.html#ga1a5d630d6aa13bd38ebd10c6cc2c243e">FilterRow()</a>, <a class="el" href="group__qvippFF.html#ga80cdf87494c982146fbaf42fa4e1886f">FilterSobelHorizMask()</a>, <a class="el" href="group__qvippFF.html#gac4c214ba6435857ee9874d2103e99418">FilterSobelVertMask()</a>, <a class="el" href="classQVBRIEFDetector.html#a0882e01e86c84b45d5c9f6e138af2cca">QVBRIEFDetector::getDescriptors()</a>, <a class="el" href="group__qvmser.html#ga7270e20566a7ad57a59acb4844ca4921">getLTMSER()</a>, <a class="el" href="group__qvsiftgpu.html#ga84ba9885258ee2d66f7a577ea09a4062">getSiftGPUFeatures()</a>, <a class="el" href="group__qvipp.html#gae25c99f8b8e1975910a913eaa8d41d96">HistogramRange()</a>, <a class="el" href="group__qvippCV.html#ga130796a6842e97aaf115d50585c76930">Inpaint()</a>, <a class="el" href="group__qvippCV.html#ga4bd093b7fbf6a2e95e439172dfc2d538">InpaintInitAllocC1()</a>, <a class="el" href="group__qvippCV.html#gae87027225d01eb6d7c21e9a67dccfba2">InpaintInitAllocC3()</a>, <a class="el" href="group__qvippISF.html#ga9ae3f12a9b4be81b9657f78eb6932063">Integral()</a>, <a class="el" href="group__qvippIAALO.html#ga1c3b64b9805d40a0fee1709bfdbb0b4e">Ln()</a>, <a class="el" href="group__qvippIAALO.html#gaa272533bb737b850a681adfd2b93180a">LShiftC()</a>, <a class="el" href="group__qvippISF.html#ga5c6818c716512e7ee6612b688cf19bd1">Max()</a>, <a class="el" href="group__qvippISF.html#ga868dcc76643480b3e18c858392fe91e4">MaxEvery()</a>, <a class="el" href="group__qvip.html#gad2ed4c0a62c68685797fe9c88148426a">maximalPoints()</a>, <a class="el" href="group__qvippISF.html#gaea578fd5bc05a457eb8af0c80386b819">Mean()</a>, <a class="el" href="group__qvippISF.html#ga47cad14d543d670d8d3b514780cec32f">Min()</a>, <a class="el" href="group__qvippCV.html#ga6610bc68ec46cd944b93444fc5001b90">MinEigenVal()</a>, <a class="el" href="group__qvippISF.html#gad008e2584b86a28ee53c3a599b268b5d">MinEvery()</a>, <a class="el" href="group__qvippIAALO.html#gaf69fed782124cc0f79894de83b83e82a">Mul()</a>, <a class="el" href="group__qvippIAALO.html#gadc8a14bd103bb45afa43950ce454f2fd">MulC()</a>, <a class="el" href="group__qvippIAALO.html#ga6fd6ed80182abfe683866f1d73fc004d">MulScale()</a>, <a class="el" href="group__qvippIAALO.html#ga0f76ac931b05682dd833a75b8854e805">Not()</a>, <a class="el" href="classQVImage.html#a32786513dbed5b1277fdd08aca880d78">QVImage&lt; uChar, 3 &gt;::operator QImage()</a>, <a class="el" href="classQVImage.html#ab0f7c3d022a614cfb614c1b9fa8fd9b1">QVImage&lt; uChar, 3 &gt;::operator()()</a>, <a class="el" href="group__qvippIAALO.html#ga3ac1055487286aceb5d233ca7504016e">Or()</a>, <a class="el" href="group__qvippIAALO.html#ga4677036234afa163f05ae161104ff086">OrC()</a>, <a class="el" href="classQVImage.html#a5448f8d71a6ce0bbf459a5b3d7c6e60c">QVImage&lt; uChar, 3 &gt;::QVImage()</a>, <a class="el" href="group__qvippICC.html#ga57fabe31feb69ecbad447dc01984cc04">RGBToGray()</a>, <a class="el" href="group__qvippICC.html#ga6bed5439d377438a4d1a687a2d326a69">RGBToYUV420()</a>, <a class="el" href="group__qvippIAALO.html#ga12d66f301cb06d19388d3e59b9ee20b7">RShiftC()</a>, <a class="el" href="group__qvippIDEAIF.html#gaf93db8f575d466b450b67cb42d41d502">Scale()</a>, <a class="el" href="group__qvippIDEAIF.html#gae2bed87200a1f753701bf5fc1e7a476b">Set()</a>, <a class="el" href="group__qvip.html#ga083ddecc2c02b1aa32bd2dd9d6c69601">SmoothFilter()</a>, <a class="el" href="group__qvippIAALO.html#ga994013601359adbacaf680beeef4d2ea">Sqr()</a>, <a class="el" href="group__qvippIAALO.html#gad33dbf2f4305241b30c50d9523b3b818">Sub()</a>, <a class="el" href="group__qvippIAALO.html#ga1ee065c873d2ce8d8d40538f80ea001e">SubC()</a>, <a class="el" href="group__qvippISF.html#ga2e7319ac380719f2d97cb2ea111e8bc2">Sum()</a>, <a class="el" href="group__qvippTACO.html#gada5e790176ab9e695b9b70ae399ffb2b">Threshold()</a>, <a class="el" href="group__qvippTACO.html#ga25082b30820f150a44ce266a33a3371c">Threshold_LTValGTVal()</a>, <a class="el" href="group__qvippTACO.html#ga587b93bed357cb8d79cf5a4bddc0b69f">Threshold_Val()</a>, <a class="el" href="classQVCUDAImage.html#afc679c7ec7a57687d282a486ccaaef17">QVCUDAImage&lt; Type, Channels &gt;::uploadToDevice()</a>, <a class="el" href="group__qvippIAALO.html#gae4d2d2d281131408081edcb67965fbed">Xor()</a>, <a class="el" href="group__qvippIAALO.html#gaf5e86b41fc6e6c893709f6b0b639322e">XorC()</a>, and <a class="el" href="group__qvippICC.html#ga1a13cf2a5106e65fc94f046e98f547ca">YUV420ToRGB()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d430b0f71799b2b2ca8f8ae8f05ca3c"></a><!-- doxytag: member="QVImage::getChannels" ref="a5d430b0f71799b2b2ca8f8ae8f05ca3c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a3dde18969f0fe8ed9079d21540e3fc13" title="Virtual method for getting the number of channels of the image.">QVGenericImage::getChannels()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a3dde18969f0fe8ed9079d21540e3fc13">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00373">373</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="group__qvip.html#gad9b6ff6909da8e12d4c231500673d128">QVImage&lt; Type, Channels &gt;::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a397ee658c9574be3013a68c584b3f9d0"></a><!-- doxytag: member="QVImage::getDataSize" ref="a397ee658c9574be3013a68c584b3f9d0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getDataSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a93cd55976a2289ba45d154c210597ea3" title="Virtual method for getting data size for the image.">QVGenericImage::getDataSize()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a93cd55976a2289ba45d154c210597ea3">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00376">376</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="classQVImage.html#ad69afa02dba6c9351cd3a16c29a4dce3">QVImage&lt; uChar, 3 &gt;::isEmpty()</a>, and <a class="el" href="classQVImage.html#ab0f7c3d022a614cfb614c1b9fa8fd9b1">QVImage&lt; uChar, 3 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a70e75bb386d5b424f266a62d000e52bf"></a><!-- doxytag: member="QVImage::getTypeSize" ref="a70e75bb386d5b424f266a62d000e52bf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uInt <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getTypeSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function from <a class="el" href="classQVGenericImage.html#a7429b1cdaa57edfcd7edfad8204c9024" title="Virtual method for getting bit depth of the image, in bytes.">QVGenericImage::getTypeSize()</a>. </p>

<p>Implements <a class="el" href="classQVGenericImage.html#a7429b1cdaa57edfcd7edfad8204c9024">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00379">379</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a200b9b19dbe2a79f75d603f9ecc67bf1"></a><!-- doxytag: member="QVImage::getReadData" ref="a200b9b19dbe2a79f75d603f9ecc67bf1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Type* <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getReadData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to obtain image data buffer, in read mode. </p>
<p>This method can be used to program fast access algorithms to pixel values in an image.</p>
<p>It is intended to be used only to read pixels in an image, thus <a class="el" href="classQVImage.html#a231507d781e33e508fac771b5284c3c9" title="Method to obtain image data buffer, in read/write mode.">getWriteData()</a> method should be used when access to write or read/write is intended to be done.</p>
<p>This function will generally be faster than <a class="el" href="classQVImage.html#a231507d781e33e508fac771b5284c3c9" title="Method to obtain image data buffer, in read/write mode.">getWriteData()</a>, because it will not need to realize copy on write, in the case that the image data buffer where shared with other <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a>. </p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00391">391</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="classQVKLTTracker.html#a6047e10322f0d4ed95ad61a787fdfebb">QVKLTTracker::detect()</a>, <a class="el" href="group__qvip.html#ga48592e8d0ecc14b8a01c373e97a0b630">FASTFeatures()</a>, <a class="el" href="group__qvip.html#ga0a73e3730368b307c874e53dd5af54c4">FastLaplaceFilter()</a>, <a class="el" href="group__qvipp.html#gaa3b64cec3b1037dc5935e6c37ef277e6">fastMaximalPoints()</a>, <a class="el" href="group__qvip.html#ga69cc8d72179389d9897aa9ac97d62c33">FastSmoothFilter()</a>, <a class="el" href="classQVBRIEFDetector.html#a0882e01e86c84b45d5c9f6e138af2cca">QVBRIEFDetector::getDescriptors()</a>, <a class="el" href="group__qvsiftgpu.html#ga84ba9885258ee2d66f7a577ea09a4062">getSiftGPUFeatures()</a>, <a class="el" href="group__qvippCV.html#ga4bd093b7fbf6a2e95e439172dfc2d538">InpaintInitAllocC1()</a>, <a class="el" href="group__qvippCV.html#gae87027225d01eb6d7c21e9a67dccfba2">InpaintInitAllocC3()</a>, <a class="el" href="classQVImage.html#a32786513dbed5b1277fdd08aca880d78">QVImage&lt; uChar, 3 &gt;::operator QImage()</a>, <a class="el" href="classQVKLTTracker.html#affe245d7de2e04d06d4bca4439d80009">QVKLTTracker::redetect()</a>, <a class="el" href="group__qvip.html#ga083ddecc2c02b1aa32bd2dd9d6c69601">SmoothFilter()</a>, <a class="el" href="classQVKLTTracker.html#a03abf973b520dbd9ce624c5977b973ba">QVKLTTracker::track()</a>, and <a class="el" href="classQVCUDAImage.html#afc679c7ec7a57687d282a486ccaaef17">QVCUDAImage&lt; Type, Channels &gt;::uploadToDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="a231507d781e33e508fac771b5284c3c9"></a><!-- doxytag: member="QVImage::getWriteData" ref="a231507d781e33e508fac771b5284c3c9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::getWriteData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to obtain image data buffer, in read/write mode. </p>
<p>This method can be used to program fast access algorithms to pixel values in an image.</p>
<p>This function will perform copy on write in the case that the data buffer for this image where shared with other QVImage's.</p>
<p>Thus can be slower than <a class="el" href="classQVImage.html#a200b9b19dbe2a79f75d603f9ecc67bf1" title="Method to obtain image data buffer, in read mode.">getReadData()</a> method to access image pixels, but will ensure avoiding side effects on modifying shared buffers with other images. </p>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00403">403</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

<p>Referenced by <a class="el" href="group__qvippCV.html#ga56269a74576283f8743352552aadc12a">Canny()</a>, <a class="el" href="classQVCUDAImage.html#aaf6520232ea4609f1aec970e60b2b488">QVCUDAImage&lt; Type, Channels &gt;::downloadFromDevice()</a>, <a class="el" href="group__qvip.html#ga0a73e3730368b307c874e53dd5af54c4">FastLaplaceFilter()</a>, <a class="el" href="group__qvippCV.html#ga7f456ffa2169dd985fb607bd0a66a33a">FastMarching()</a>, <a class="el" href="group__qvip.html#ga69cc8d72179389d9897aa9ac97d62c33">FastSmoothFilter()</a>, <a class="el" href="group__qvmser.html#ga7270e20566a7ad57a59acb4844ca4921">getLTMSER()</a>, <a class="el" href="group__qvippCV.html#ga6610bc68ec46cd944b93444fc5001b90">MinEigenVal()</a>, <a class="el" href="classQVImage.html#a5448f8d71a6ce0bbf459a5b3d7c6e60c">QVImage&lt; uChar, 3 &gt;::QVImage()</a>, <a class="el" href="group__qvgpukltflow.html#ga37213de8a554819178f0de47e43c1dd1">qvOpticalFlowGPU()</a>, and <a class="el" href="group__qvip.html#ga083ddecc2c02b1aa32bd2dd9d6c69601">SmoothFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="addec4b1d837eb849d4b8605c1a86e3ac"></a><!-- doxytag: member="QVImage::set" ref="addec4b1d837eb849d4b8605c1a86e3ac" args="(Type c1=0, Type c2=0, Type c3=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>c1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>c2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>c3</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets pixel values for an image, to a given value. </p>
<p>This method uses the region of interest of the image, to set pixels inside it to a given value. It can be used either for one channel, or several channel images.</p>
<p>In the former case, it should be used with one parameter, only specifying value for the first channel, otherwise, values for other channels will be ignored. If no parameters are given, the image region of interest will be set to zero value pixels.</p>
<p>In the latter case, default values of 0 will be used if there are unspecified channel values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c1</em>&nbsp;</td><td>value to set pixel's first channel in the region of interest of the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c2</em>&nbsp;</td><td>value to set pixel's second channel in the region of interest of the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c3</em>&nbsp;</td><td>value to set pixel's third channel in the region of interest of the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad69afa02dba6c9351cd3a16c29a4dce3"></a><!-- doxytag: member="QVImage::isEmpty" ref="ad69afa02dba6c9351cd3a16c29a4dce3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the image is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image contains no data, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00425">425</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="abadb4ee2e54af167f6c80e247bf397cb"></a><!-- doxytag: member="QVImage::resize" ref="abadb4ee2e54af167f6c80e247bf397cb" args="(const int cols, const int rows)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the image. </p>
<p>This method reserves extra space for a larger image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cols</em>&nbsp;</td><td>new columns number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rows</em>&nbsp;</td><td>new row number. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00436">436</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0f7c3d022a614cfb614c1b9fa8fd9b1"></a><!-- doxytag: member="QVImage::operator()" ref="ab0f7c3d022a614cfb614c1b9fa8fd9b1" args="(const uInt col, const uInt row, const uInt channel=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const uInt&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uInt&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uInt&nbsp;</td>
          <td class="paramname"> <em>channel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator to access pixel values for a pixel channel, given it's coordinates. </p>
<p>This operator can be used either with one channel or multichannel images. In the first case, it shouldn't be given a channel number, to use the default zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>column number of pixel to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row</em>&nbsp;</td><td>row number of pixel to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>channel number of pixel to be accessed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00455">455</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a923f82b6c7a2aeb5b5ef072860db9402"></a><!-- doxytag: member="QVImage::operator()" ref="a923f82b6c7a2aeb5b5ef072860db9402" args="(const QPoint point, const uInt channel=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const QPoint&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uInt&nbsp;</td>
          <td class="paramname"> <em>channel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of operator (), to access pixel values for a pixel channel, given a QVPoint and a channel number. </p>
<p>This overload is like the previous, but can be used with a QPoint, to access a concrete pixel in the image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>QPoint indicating location of the pixel to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>channel number of pixel to be accessed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00485">485</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="af710e6e447f428ac01b0485c075315f2"></a><!-- doxytag: member="QVImage::operator()" ref="af710e6e447f428ac01b0485c075315f2" args="(const uInt channel=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const uInt&nbsp;</td>
          <td class="paramname"> <em>channel</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator to access pixel values for a pixel channel, given it's coordinates. </p>
<p>This operator can be used either with one channel or multichannel images. In the first case, it shouldn't be given a channel number, to use the default zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>column number of pixel to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row</em>&nbsp;</td><td>row number of pixel to be accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>channel number of pixel to be accessed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3af2bb0d8e7fde9e2f6c778c4d7f23f9"></a><!-- doxytag: member="QVImage::operator=" ref="a3af2bb0d8e7fde9e2f6c778c4d7f23f9" args="(const QVImage&lt; uChar, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy operator. </p>
<p>Like the copy constructor, this operator can be used to copy an image from another one with same bit depth and channel number, or from an image differing in type or number of channels.</p>
<p>In the former case, this operator will do a copy-on-write, duplicating the pointer to the data buffer of the image, and effectively copying the data only when modifying it if shared by more than one <a class="el" href="classQVImage.html" title="Image representation class for the QVision.">QVImage</a> object.</p>
<p>In the latter case, it will always allocate a new data buffer for the image, and make a conversion from different bit depth or channel number. Note that you can never convert from an image that differs in data type and bit-depth with the constructed image.</p>
<p>The copy operator will copy the ROI and anchor of the parameter image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a540489c365419c8ba69631e4b8990242"></a><!-- doxytag: member="QVImage::operator=" ref="a540489c365419c8ba69631e4b8990242" args="(const QVImage&lt; uChar, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="af135c7f46ac4890171b40eed31ce0718"></a><!-- doxytag: member="QVImage::operator=" ref="af135c7f46ac4890171b40eed31ce0718" args="(const QVImage&lt; sChar, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a046cc1bf4f14a7f8b359575366710739"></a><!-- doxytag: member="QVImage::operator=" ref="a046cc1bf4f14a7f8b359575366710739" args="(const QVImage&lt; sChar, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="ace925131622fdd17cb6a27cb87e91622"></a><!-- doxytag: member="QVImage::operator=" ref="ace925131622fdd17cb6a27cb87e91622" args="(const QVImage&lt; uShort, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="ae2386f631d272214bed8b1fd572fe2b4"></a><!-- doxytag: member="QVImage::operator=" ref="ae2386f631d272214bed8b1fd572fe2b4" args="(const QVImage&lt; uShort, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a2f484d916f8888c6d3f51f91f1d36ed8"></a><!-- doxytag: member="QVImage::operator=" ref="a2f484d916f8888c6d3f51f91f1d36ed8" args="(const QVImage&lt; sShort, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="abf620083c92cdc477f05872c82c65c89"></a><!-- doxytag: member="QVImage::operator=" ref="abf620083c92cdc477f05872c82c65c89" args="(const QVImage&lt; sShort, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a3d221c1e02dffe9ba8b3d6e009dc52db"></a><!-- doxytag: member="QVImage::operator=" ref="a3d221c1e02dffe9ba8b3d6e009dc52db" args="(const QVImage&lt; uInt, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="ad65abc950f31339c2aa0294fd01f871b"></a><!-- doxytag: member="QVImage::operator=" ref="ad65abc950f31339c2aa0294fd01f871b" args="(const QVImage&lt; uInt, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a3ee88c54754fb107612a7becec982283"></a><!-- doxytag: member="QVImage::operator=" ref="a3ee88c54754fb107612a7becec982283" args="(const QVImage&lt; sInt, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="afdc80320663f54860a6541030bd4a030"></a><!-- doxytag: member="QVImage::operator=" ref="afdc80320663f54860a6541030bd4a030" args="(const QVImage&lt; sInt, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a621328747cffb8a2fb7dac91e7ffee9e"></a><!-- doxytag: member="QVImage::operator=" ref="a621328747cffb8a2fb7dac91e7ffee9e" args="(const QVImage&lt; sFloat, 1 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a83b874a6f925ef39265c3cea1d90caa2"></a><!-- doxytag: member="QVImage::operator=" ref="a83b874a6f925ef39265c3cea1d90caa2" args="(const QVImage&lt; sFloat, 3 &gt; &amp;sourceImage)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt;&amp; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceImage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded copy operator. </p>

</div>
</div>
<a class="anchor" id="a711605fe3079ed219867bd0c121a6726"></a><!-- doxytag: member="QVImage::operator!=" ref="a711605fe3079ed219867bd0c121a6726" args="(const QVImage&lt; Type, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality compare operator. </p>
<p>This operator will compare two images of same bit depth and channel number, and will return true if images differ in any of:</p>
<ul>
<li>dimensions (cols and rows).</li>
<li>region of interest.</li>
<li>content of region of interest. returning false otherwise.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>Shouldn't ignore dimensions in caparisons, and only check if region of interest content are the same?</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if images are practically equal (same content of region of interest and dimensions). </dd></dl>

<p>Definition at line <a class="el" href="qvimage_8h_source.html#l00601">601</a> of file <a class="el" href="qvimage_8h_source.html">qvimage.h</a>.</p>

</div>
</div>
<a class="anchor" id="af6d740c62e447391106880b3bf4395c2"></a><!-- doxytag: member="QVImage::operator&lt;" ref="af6d740c62e447391106880b3bf4395c2" args="(const QVImage&lt; uChar, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="adcf4f5231bc72199068371199b34ce9c"></a><!-- doxytag: member="QVImage::operator&lt;" ref="adcf4f5231bc72199068371199b34ce9c" args="(const QVImage&lt; uShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a518e4c1bf6cd33a80c7c58a699c9c824"></a><!-- doxytag: member="QVImage::operator&lt;" ref="a518e4c1bf6cd33a80c7c58a699c9c824" args="(const QVImage&lt; sShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0924d6958c7f4f90be9ce65ae50755"></a><!-- doxytag: member="QVImage::operator&lt;" ref="a4e0924d6958c7f4f90be9ce65ae50755" args="(const QVImage&lt; sInt, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a945fff634385b9f45dd164ecf9a4bf20"></a><!-- doxytag: member="QVImage::operator&lt;" ref="a945fff634385b9f45dd164ecf9a4bf20" args="(const QVImage&lt; sFloat, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a84defb58ab6c7c37a6c5e32a676c8155"></a><!-- doxytag: member="QVImage::operator&gt;" ref="a84defb58ab6c7c37a6c5e32a676c8155" args="(const QVImage&lt; uChar, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a7273af2c1c151a617b61a5075afcd9fd"></a><!-- doxytag: member="QVImage::operator&gt;" ref="a7273af2c1c151a617b61a5075afcd9fd" args="(const QVImage&lt; uShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a4848d665c762292664e2fe3a993a4aab"></a><!-- doxytag: member="QVImage::operator&gt;" ref="a4848d665c762292664e2fe3a993a4aab" args="(const QVImage&lt; sShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7e3abc72637e215078f769b83c2ae92"></a><!-- doxytag: member="QVImage::operator&gt;" ref="aa7e3abc72637e215078f769b83c2ae92" args="(const QVImage&lt; sInt, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="afeaf1ded443756c60cd3d859ef0ba418"></a><!-- doxytag: member="QVImage::operator&gt;" ref="afeaf1ded443756c60cd3d859ef0ba418" args="(const QVImage&lt; sFloat, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a02c0d4b4a12bcfab61498c2b9f6eded8"></a><!-- doxytag: member="QVImage::operator&lt;=" ref="a02c0d4b4a12bcfab61498c2b9f6eded8" args="(const QVImage&lt; uChar, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a133cfe9bcd8e7648f4f7bd2a14246d0f"></a><!-- doxytag: member="QVImage::operator&lt;=" ref="a133cfe9bcd8e7648f4f7bd2a14246d0f" args="(const QVImage&lt; uShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="af2f0602efc216991f1484756ce524ad3"></a><!-- doxytag: member="QVImage::operator&lt;=" ref="af2f0602efc216991f1484756ce524ad3" args="(const QVImage&lt; sShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a6504831315915d366f2adf3e0c5d5981"></a><!-- doxytag: member="QVImage::operator&lt;=" ref="a6504831315915d366f2adf3e0c5d5981" args="(const QVImage&lt; sInt, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a0927cb1b154e0e502f46989279f35565"></a><!-- doxytag: member="QVImage::operator&lt;=" ref="a0927cb1b154e0e502f46989279f35565" args="(const QVImage&lt; sFloat, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'less or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is less or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="ab69223019a34542ef32ed9bdb56e6d9b"></a><!-- doxytag: member="QVImage::operator&gt;=" ref="ab69223019a34542ef32ed9bdb56e6d9b" args="(const QVImage&lt; uChar, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uChar, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a896e769e1e87810253a90736d60d9f16"></a><!-- doxytag: member="QVImage::operator&gt;=" ref="a896e769e1e87810253a90736d60d9f16" args="(const QVImage&lt; uShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="ae743a09e3a64e26c03eb4768a9fc4a6d"></a><!-- doxytag: member="QVImage::operator&gt;=" ref="ae743a09e3a64e26c03eb4768a9fc4a6d" args="(const QVImage&lt; sShort, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a6321d6989881a05fb864514e33786d17"></a><!-- doxytag: member="QVImage::operator&gt;=" ref="a6321d6989881a05fb864514e33786d17" args="(const QVImage&lt; sInt, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a030527e91441086e7d3a042021d90077"></a><!-- doxytag: member="QVImage::operator&gt;=" ref="a030527e91441086e7d3a042021d90077" args="(const QVImage&lt; sFloat, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;uChar, 1&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise 'greater or equal than' compare operator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>image to compare with this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1-channel uChar bit depth image containing non-zero values for pixels which value for corresponding pixel in this image is greater or equal than value for corresponding pixel in given image. </dd></dl>

</div>
</div>
<a class="anchor" id="a446a88f9290f14cb4cf9f93a4d5600fa"></a><!-- doxytag: member="QVImage::operator+" ref="a446a88f9290f14cb4cf9f93a4d5600fa" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise constant add operator. </p>
<p>Uses as the second operand a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a37d4560acc3253c15ef377c60f7c0df4"></a><!-- doxytag: member="QVImage::operator*" ref="a37d4560acc3253c15ef377c60f7c0df4" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise constant product operator. </p>
<p>Uses as the second operand a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a955eab9bd6ba4582331d4f3834c27f96"></a><!-- doxytag: member="QVImage::operator&#45;" ref="a955eab9bd6ba4582331d4f3834c27f96" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise constant subtraction operator. </p>
<p>Uses as the second operand a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a78d47c71ce0669bd78469cc75de823c7"></a><!-- doxytag: member="QVImage::operator/" ref="a78d47c71ce0669bd78469cc75de823c7" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise constant division operator. </p>
<p>Uses as the second operand a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a61d7b5a18ab0774073e408d62c0a1a4c"></a><!-- doxytag: member="QVImage::operator&lt;&lt;" ref="a61d7b5a18ab0774073e408d62c0a1a4c" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise left shift operator. </p>
<p>Uses as the value to shift a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0d33365ec2a80cb154b812cfdf34d5c"></a><!-- doxytag: member="QVImage::operator&gt;&gt;" ref="ab0d33365ec2a80cb154b812cfdf34d5c" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise right shift operator. </p>
<p>Uses as the value to shift a constant value for every pixel computed.</p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a92d847580d4d8ff7c435beddb696cd33"></a><!-- doxytag: member="QVImage::operator!" ref="a92d847580d4d8ff7c435beddb696cd33" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise NOT operation. </p>
<p>Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a9edb618e4cbd6803f8ab64593380882a"></a><!-- doxytag: member="QVImage::operator&amp;" ref="a9edb618e4cbd6803f8ab64593380882a" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise boolean and operator. </p>
<p>Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a3f4f32627c88e66ed30edeb60f73d"></a><!-- doxytag: member="QVImage::operator|" ref="ac5a3f4f32627c88e66ed30edeb60f73d" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise boolean or operator. </p>
<p>Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a546ab721d0c37c727785194e3b0e443a"></a><!-- doxytag: member="QVImage::operator^" ref="a546ab721d0c37c727785194e3b0e443a" args="(const Type constant) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const Type&nbsp;</td>
          <td class="paramname"> <em>constant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise bit-wise boolean xor operator. </p>
<p>Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constant</em>&nbsp;</td><td>second operand value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="adfeba51bee210af2222fbbb9b2ff9ccb"></a><!-- doxytag: member="QVImage::operator+" ref="adfeba51bee210af2222fbbb9b2ff9ccb" args="(const QVImage&lt; Type, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise add operator. </p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>operand image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a1777f27e4ed78711aa3dbd09eb5b9ac2"></a><!-- doxytag: member="QVImage::operator*" ref="a1777f27e4ed78711aa3dbd09eb5b9ac2" args="(const QVImage&lt; Type, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise mult operator. </p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>operand image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a992c90d4bdf39e9bc0edc00868ccca85"></a><!-- doxytag: member="QVImage::operator&#45;" ref="a992c90d4bdf39e9bc0edc00868ccca85" args="(const QVImage&lt; Type, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise subtraction operator. </p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>operand image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="abace2731ce10598de32940ff98e26a3d"></a><!-- doxytag: member="QVImage::operator/" ref="abace2731ce10598de32940ff98e26a3d" args="(const QVImage&lt; Type, Channels &gt; &amp;img) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type = uChar, int Channels = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQVImage.html">QVImage</a>&lt;Type, Channels&gt; <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQVImage.html">QVImage</a>&lt; Type, Channels &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>img</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel wise division operator. </p>
<p>Saturation is used for integer bit depth data (any except sFloat bit depth). Regions of interests, and anchors are applied in this operator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operator is based on functionality from the Intel IPP library. Thus, compatibility with that library must be enabled to be available.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>operand image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting image for the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5abf377f3c4f95d128270d351b8269c"></a><!-- doxytag: member="QVImage::getTypeQString" ref="aa5abf377f3c4f95d128270d351b8269c" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00032">32</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a250fd54325bf7b45311081f10d6a7d21"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a250fd54325bf7b45311081f10d6a7d21" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sChar, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00033">33</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26060f0d5c591843b2b47c8c33a55b77"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a26060f0d5c591843b2b47c8c33a55b77" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00034">34</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82511ed913536f548b1f5e10e7f8f4a1"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a82511ed913536f548b1f5e10e7f8f4a1" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; uShort, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00035">35</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e7c91408e79a5fc6a2a48f0b4bbcdd"></a><!-- doxytag: member="QVImage::getTypeQString" ref="ab9e7c91408e79a5fc6a2a48f0b4bbcdd" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00036">36</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9826942b7de555975fb354ef38bd76f"></a><!-- doxytag: member="QVImage::getTypeQString" ref="aa9826942b7de555975fb354ef38bd76f" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sShort, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00037">37</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1da886203b77c0baac9a9a8e5e31fbbb"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a1da886203b77c0baac9a9a8e5e31fbbb" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00038">38</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23e0b7fcceda1b493c384991aecff5ab"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a23e0b7fcceda1b493c384991aecff5ab" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sInt, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00039">39</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af223ffd23a8459c984a6cd9dad9864e7"></a><!-- doxytag: member="QVImage::getTypeQString" ref="af223ffd23a8459c984a6cd9dad9864e7" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00040">40</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5449f66a7fd6c95310376ed220ba38fb"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a5449f66a7fd6c95310376ed220ba38fb" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; uInt, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00041">41</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd4dc980bb4626fb93142fffb06bd422"></a><!-- doxytag: member="QVImage::getTypeQString" ref="acd4dc980bb4626fb93142fffb06bd422" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 1 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00042">42</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a851df498210edde9a152910076c12244"></a><!-- doxytag: member="QVImage::getTypeQString" ref="a851df498210edde9a152910076c12244" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classQVImage.html">QVImage</a>&lt; sFloat, 3 &gt;::getTypeQString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a char string identifying the type of the image. real image contained in the <a class="el" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a constant char string identifying image type. </dd></dl>

<p>Implements <a class="el" href="classQVGenericImage.html#a11b4c13e54a1e89d735c12f9cbec277f">QVGenericImage</a>.</p>

<p>Definition at line <a class="el" href="qvimage_8cpp_source.html#l00043">43</a> of file <a class="el" href="qvimage_8cpp_source.html">qvimage.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/qvip/<a class="el" href="qvimage_8h_source.html">qvimage.h</a></li>
</ul>
</div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
