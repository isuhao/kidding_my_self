<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvblockprogramming/qvguiblocks/qv3dcanvas.cpp</h1><a href="qv3dcanvas_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;QMouseEvent&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">//#include &lt;qvipp.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="qvdefines_8h.html" title="File from the QVision library.">qvdefines.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;qvmatrixalgebra.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="qv3dcanvas_8h.html" title="File from the QVision library.">qv3dcanvas.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;QTimer&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;GL/glu.h&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#define GL_VIEW_ASPECT   1.333</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef DOXYGEN_IGNORE_THIS</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>QV3DCanvas::QV3DCanvas( <span class="keyword">const</span> QString &amp;title, <span class="keyword">const</span> <span class="keywordtype">double</span> zoom, <span class="keywordtype">bool</span> dr_center, <span class="keyword">const</span> QColor &amp;backgroundColor, QWidget* parent): QGLWidget(parent),
<a name="l00040"></a>00040             trackballQuat(<a class="code" href="classQVQuaternion.html" title="Implementation of quaternions.">QVQuaternion</a>::trackball(0.0, 0.0, 0.0, 0.0)),
<a name="l00041"></a>00041             cx(0), cy(0), cz(0), ambientLightR(1.0), ambientLightG(1.0), ambientLightB(1.0),
<a name="l00042"></a>00042             dr_center(dr_center), zoom(zoom), fov(45), pressedleft(FALSE), pressedright(FALSE), colorCursor(0), backgroundColor(backgroundColor)
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044     setName(title);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     resize(400,(<span class="keywordtype">int</span>)(400/GL_VIEW_ASPECT));
<a name="l00047"></a>00047     setWindowTitle(title);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049     QTimer *timer = <span class="keyword">new</span> QTimer(<span class="keyword">this</span>);
<a name="l00050"></a>00050     connect(timer, SIGNAL(timeout()), <span class="keyword">this</span>, SLOT(updateGL()));
<a name="l00051"></a>00051     timer-&gt;start(1000/24);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053     show();
<a name="l00054"></a>00054     }
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 QV3DCanvas::~QV3DCanvas ()
<a name="l00057"></a>00057     {
<a name="l00058"></a>00058     <span class="comment">// FIXME: is it needed?: makeCurrent();</span>
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keywordtype">void</span> QV3DCanvas::initializeGL()
<a name="l00062"></a>00062     {
<a name="l00063"></a>00063     glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     glDisable(GL_CULL_FACE);
<a name="l00066"></a>00066     glEnable(GL_DEPTH_TEST);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068     glEnable(GL_DITHER);
<a name="l00069"></a>00069     glShadeModel(GL_SMOOTH);
<a name="l00070"></a>00070     glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
<a name="l00071"></a>00071     glHint(GL_POLYGON_SMOOTH_HINT, GL_FASTEST);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
<a name="l00074"></a>00074     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
<a name="l00075"></a>00075     glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     glEnable(GL_DEPTH_TEST);
<a name="l00078"></a>00078     glEnable(GL_CULL_FACE);
<a name="l00079"></a>00079     glEnable(GL_TEXTURE_2D);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081     init();
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keywordtype">void</span> QV3DCanvas::draw_center_of_rotation()
<a name="l00085"></a>00085     {
<a name="l00086"></a>00086     <span class="comment">/* Yellow cross: (center of rotation). */</span>
<a name="l00087"></a>00087     glBegin(GL_LINES);
<a name="l00088"></a>00088         glColor3ub(255,255,0);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         glVertex3f(cx - 0.1,cy,cz);
<a name="l00091"></a>00091         glVertex3f(cx + 0.1,cy,cz);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         glVertex3f(cx,cy- 0.1,cz);
<a name="l00094"></a>00094         glVertex3f(cx,cy+ 0.1,cz);
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         glVertex3f(cx,cy,cz- 0.1);
<a name="l00097"></a>00097         glVertex3f(cx,cy,cz+ 0.1);
<a name="l00098"></a>00098     glEnd();
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="preprocessor">#define S       15</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="keywordtype">void</span> QV3DCanvas::paintGL()
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104     <span class="comment">// Loads identity matrix in the projection stack</span>
<a name="l00105"></a>00105     glMatrixMode(GL_PROJECTION);
<a name="l00106"></a>00106     glLoadIdentity();
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="comment">// Set up a perspective projection matrix</span>
<a name="l00109"></a>00109     qvGluPerspective(fov, (<span class="keywordtype">float</span>)size().width()/(<span class="keywordtype">float</span>)size().height(), 0.25, 100*zoom);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     <span class="comment">// Loads identity matrix in the model view stack</span>
<a name="l00112"></a>00112     glMatrixMode(GL_MODELVIEW);
<a name="l00113"></a>00113     glLoadIdentity();
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     <span class="comment">// Setup background color.</span>
<a name="l00116"></a>00116     qglClearColor(backgroundColor);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">// Clear the scene to the background color.</span>
<a name="l00119"></a>00119     glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">// Enable lightning.</span>
<a name="l00122"></a>00122     glEnable(GL_LIGHTING);
<a name="l00123"></a>00123     glEnable(GL_LIGHT0);                <span class="comment">// Set up sunlight.</span>
<a name="l00124"></a>00124     glEnable(GL_COLOR_MATERIAL);        <span class="comment">// Configure glColor().</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="comment">// Setup ambient light.</span>
<a name="l00127"></a>00127     <span class="keyword">const</span> GLfloat ambientLight[4] = {ambientLightR, ambientLightG, ambientLightB, 1.0 };
<a name="l00128"></a>00128     glLightModelfv(GL_LIGHT_MODEL_AMBIENT,  ambientLight);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="comment">// Draw images objects</span>
<a name="l00131"></a>00131     <span class="keywordflow">foreach</span>(QString name, getPropertyList())
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (getPropertyFlags(name) &amp; inputFlag)
<a name="l00133"></a>00133             {
<a name="l00134"></a>00134             <span class="comment">// Draw &lt;uChar,1&gt; images</span>
<a name="l00135"></a>00135             <span class="keywordflow">if</span> (isType&lt; <a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a> &gt;(name)) {
<a name="l00136"></a>00136                 <a class="code" href="classQVImage.html">QVImage&lt;uChar, 1&gt;</a> imageAux = getPropertyValue&lt;QVImage&lt;uChar,1&gt; &gt;(name);
<a name="l00137"></a>00137                 drawQVImage(&amp;imageAux);
<a name="l00138"></a>00138                 }
<a name="l00139"></a>00139             <span class="comment">// Draw &lt;uChar,3&gt; images</span>
<a name="l00140"></a>00140             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isType&lt; <a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a> &gt;(name)) {
<a name="l00141"></a>00141                 <a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a> imageAux = getPropertyValue&lt;QVImage&lt;uChar,3&gt; &gt;(name);
<a name="l00142"></a>00142                 drawQVImage(&amp;imageAux);
<a name="l00143"></a>00143                 }
<a name="l00144"></a>00144             <span class="comment">// Draw &lt;sFloat,1&gt; images</span>
<a name="l00145"></a>00145             <span class="comment">/*else if (isType&lt; QVImage&lt;sFloat,1&gt; &gt;(name)) {</span>
<a name="l00146"></a>00146 <span class="comment">                QVImage&lt;sFloat,1&gt; imageAux = getPropertyValue&lt;QVImage&lt;sFloat,1&gt; &gt;(name);</span>
<a name="l00147"></a>00147 <span class="comment">                drawQVImage(&amp;imageAux, TRUE, _low, _high);</span>
<a name="l00148"></a>00148 <span class="comment">                }</span>
<a name="l00149"></a>00149 <span class="comment">            // Draw &lt;sFloat,3&gt; images</span>
<a name="l00150"></a>00150 <span class="comment">            else if (isType&lt; QVImage&lt;sFloat,3&gt; &gt;(name)) {</span>
<a name="l00151"></a>00151 <span class="comment">                QVImage&lt;sFloat,3&gt; imageAux = getPropertyValue&lt;QVImage&lt;sFloat,3&gt; &gt;(name);</span>
<a name="l00152"></a>00152 <span class="comment">                drawQVImage(&amp;imageAux, TRUE, _low, _high);</span>
<a name="l00153"></a>00153 <span class="comment">                }</span>
<a name="l00158"></a>00158 <span class="comment">            // Draw &lt;sShort,1&gt; images</span>
<a name="l00159"></a>00159 <span class="comment">            else if (isType&lt; QVImage&lt;uShort,1&gt; &gt;(name)) {</span>
<a name="l00160"></a>00160 <span class="comment">                QVImage&lt;uChar, 1&gt; imageAux = getPropertyValue&lt;QVImage&lt;uShort,1&gt; &gt;(name);</span>
<a name="l00161"></a>00161 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00162"></a>00162 <span class="comment">                }</span>
<a name="l00163"></a>00163 <span class="comment">            // Draw &lt;sShort,3&gt; images</span>
<a name="l00164"></a>00164 <span class="comment">            else if (isType&lt; QVImage&lt;uShort,3&gt; &gt;(name)) {</span>
<a name="l00165"></a>00165 <span class="comment">                QVImage&lt;uChar, 3&gt; imageAux = getPropertyValue&lt;QVImage&lt;uShort,3&gt; &gt;(name);</span>
<a name="l00166"></a>00166 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00167"></a>00167 <span class="comment">                }</span>
<a name="l00168"></a>00168 <span class="comment">            // Draw &lt;sShort,1&gt; images</span>
<a name="l00169"></a>00169 <span class="comment">            else if (isType&lt; QVImage&lt;sShort,1&gt; &gt;(name)) {</span>
<a name="l00170"></a>00170 <span class="comment">                QVImage&lt;uChar, 1&gt; imageAux = getPropertyValue&lt;QVImage&lt;sShort,1&gt; &gt;(name);</span>
<a name="l00171"></a>00171 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00172"></a>00172 <span class="comment">                }</span>
<a name="l00173"></a>00173 <span class="comment">            // Draw &lt;sShort,3&gt; images</span>
<a name="l00174"></a>00174 <span class="comment">            else if (isType&lt; QVImage&lt;sShort,3&gt; &gt;(name)) {</span>
<a name="l00175"></a>00175 <span class="comment">                QVImage&lt;uChar, 3&gt; imageAux = getPropertyValue&lt;QVImage&lt;sShort,3&gt; &gt;(name);</span>
<a name="l00176"></a>00176 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00177"></a>00177 <span class="comment">                }</span>
<a name="l00178"></a>00178 <span class="comment">            // Draw &lt;sInt,1&gt; images</span>
<a name="l00179"></a>00179 <span class="comment">            else if (isType&lt; QVImage&lt;sInt,1&gt; &gt;(name)) {</span>
<a name="l00180"></a>00180 <span class="comment">                QVImage&lt;uChar, 1&gt; imageAux = getPropertyValue&lt;QVImage&lt;sInt,1&gt; &gt;(name);</span>
<a name="l00181"></a>00181 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00182"></a>00182 <span class="comment">                }</span>
<a name="l00183"></a>00183 <span class="comment">            // Draw &lt;sInt,3&gt; images</span>
<a name="l00184"></a>00184 <span class="comment">            else if (isType&lt; QVImage&lt;sInt,3&gt; &gt;(name)) {</span>
<a name="l00185"></a>00185 <span class="comment">                QVImage&lt;uChar, 3&gt; imageAux = getPropertyValue&lt;QVImage&lt;sInt,3&gt; &gt;(name);</span>
<a name="l00186"></a>00186 <span class="comment">                drawQVImage(&amp;imageAux);</span>
<a name="l00187"></a>00187 <span class="comment">                }*/</span>
<a name="l00188"></a>00188             }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     glTranslatef(0,0,-8*zoom);
<a name="l00191"></a>00191     <span class="comment">//const QVMatrix R = QVMatrix(trackballQuat);</span>
<a name="l00192"></a>00192     <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R = (trackballQuat.toRotationMatrix() | <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(3,0.0)) &amp; (<a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(3,0.0) &lt;&lt; 1);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     glMultMatrixd(R.<a class="code" href="classQVMatrix.html#a50de15cc657c8a1d9fcc749161192a64" title="Gets a read-only reference to the data buffer of the matrix.">getReadData</a>());
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         glTranslatef(-cx,-cy,-cz);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     display();
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     viewer();
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="keywordflow">if</span>(dr_center)
<a name="l00203"></a>00203         draw_center_of_rotation();
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     glFlush();
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keywordtype">void</span> QV3DCanvas::resizeGL( <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h )
<a name="l00210"></a>00210     {
<a name="l00211"></a>00211     glViewport(0,0,w,h);
<a name="l00212"></a>00212     reshape(w,h);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     glScaled((GLdouble)0.5,(GLdouble)0.5,(GLdouble)0.5);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     viewer();
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     glFlush();
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keywordtype">void</span> QV3DCanvas::mousePressEvent(QMouseEvent *event)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227     beginx = <span class="keyword">event</span>-&gt;x();
<a name="l00228"></a>00228     beginy = <span class="keyword">event</span>-&gt;y();
<a name="l00229"></a>00229     <span class="keywordflow">if</span>(event-&gt;button() == Qt::LeftButton) {
<a name="l00230"></a>00230         pressedleft = TRUE;
<a name="l00231"></a>00231     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event-&gt;button() == Qt::RightButton) {
<a name="l00232"></a>00232         pressedright = TRUE;
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keywordtype">void</span> QV3DCanvas::mouseReleaseEvent(QMouseEvent *event)
<a name="l00237"></a>00237 {
<a name="l00238"></a>00238     <span class="keywordflow">if</span>(event-&gt;button() == Qt::LeftButton) {
<a name="l00239"></a>00239         pressedleft = FALSE;
<a name="l00240"></a>00240     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(event-&gt;button() == Qt::RightButton) {
<a name="l00241"></a>00241         pressedright = FALSE;
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keywordtype">void</span> QV3DCanvas::mouseMoveEvent(QMouseEvent *event)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247     <span class="keywordtype">int</span> x,y;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     x = (int) event-&gt;x();
<a name="l00250"></a>00250     y = (int) event-&gt;y();
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordflow">if</span> (pressedleft) {
<a name="l00253"></a>00253     <a class="code" href="classQVQuaternion.html" title="Implementation of quaternions.">QVQuaternion</a> spinQuat = <a class="code" href="classQVQuaternion.html#afc059199578068271288acb8712cb083" title="Gets the quaternion corresponding to a trackball rotation.">QVQuaternion::trackball</a>(
<a name="l00254"></a>00254             (2.0*beginx - size().width())       / size().width(),
<a name="l00255"></a>00255             (size().height() - 2.0*beginy)      / size().height(),
<a name="l00256"></a>00256             (2.0*x - size().width())    / size().width(),
<a name="l00257"></a>00257             (size().height() - 2.0*y)   / size().height());
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         trackballQuat = trackballQuat * spinQuat;
<a name="l00260"></a>00260         updateGL();
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262 <span class="comment">/*</span>
<a name="l00263"></a>00263 <span class="comment">    if (pressedright) {</span>
<a name="l00264"></a>00264 <span class="comment">        //printf(&quot;MouseMove right button\n&quot;);</span>
<a name="l00265"></a>00265 <span class="comment">        zoom += ((y - beginy) / size().height()) * 100;</span>
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment">        //if (zoom &lt; 5) zoom = 5;</span>
<a name="l00268"></a>00268 <span class="comment">        //if (zoom &gt; 120) zoom = 120;</span>
<a name="l00269"></a>00269 <span class="comment">        updateGL();</span>
<a name="l00270"></a>00270 <span class="comment">    }*/</span>
<a name="l00271"></a>00271     beginx = x;
<a name="l00272"></a>00272     beginy = y;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keywordtype">void</span> QV3DCanvas::wheelEvent(QWheelEvent *event)
<a name="l00276"></a>00276     {
<a name="l00277"></a>00277     zoom *= pow(0.9995,event-&gt;delta());
<a name="l00278"></a>00278     updateGL();
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="keywordtype">void</span> QV3DCanvas::keyPressEvent(QKeyEvent *event)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283     <span class="comment">//printf(&quot;KeyPress\n&quot;);</span>
<a name="l00284"></a>00284     <span class="keywordflow">switch</span>(event-&gt;key()) {
<a name="l00285"></a>00285       <span class="keywordflow">case</span> Qt::Key_Left:
<a name="l00286"></a>00286         cx -= 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00287"></a>00287         <span class="keywordflow">break</span>;
<a name="l00288"></a>00288       <span class="keywordflow">case</span> Qt::Key_Right:
<a name="l00289"></a>00289         cx += 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00290"></a>00290         <span class="keywordflow">break</span>;
<a name="l00291"></a>00291       <span class="keywordflow">case</span> Qt::Key_Up:
<a name="l00292"></a>00292         cy += 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00293"></a>00293         <span class="keywordflow">break</span>;
<a name="l00294"></a>00294       <span class="keywordflow">case</span> Qt::Key_Down:
<a name="l00295"></a>00295         cy -= 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00296"></a>00296         <span class="keywordflow">break</span>;
<a name="l00297"></a>00297       <span class="keywordflow">case</span> Qt::Key_PageUp:
<a name="l00298"></a>00298         cz += 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00299"></a>00299         <span class="keywordflow">break</span>;
<a name="l00300"></a>00300       <span class="keywordflow">case</span> Qt::Key_PageDown:
<a name="l00301"></a>00301         cz -= 0.1; <span class="comment">// maxwide/20;</span>
<a name="l00302"></a>00302         <span class="keywordflow">break</span>;
<a name="l00303"></a>00303       <span class="keywordflow">case</span> <span class="charliteral">&#39;C&#39;</span>:
<a name="l00304"></a>00304         dr_center = not dr_center;
<a name="l00305"></a>00305         <span class="keywordflow">break</span>;
<a name="l00306"></a>00306       <span class="comment">//case &#39;B&#39;:</span>
<a name="l00307"></a>00307         <span class="comment">//dr_box = not dr_box;</span>
<a name="l00308"></a>00308         <span class="comment">//break;</span>
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="comment">/* Something changed; redraw: */</span>
<a name="l00311"></a>00311     updateGL();
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keywordtype">void</span> QV3DCanvas::closeEvent(QCloseEvent * event)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316     Q_UNUSED(event);
<a name="l00317"></a>00317     emit closed();
<a name="l00318"></a>00318 }
<a name="l00319"></a>00319 
<a name="l00321"></a>00321 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00322"></a>00322 <span class="keywordtype">void</span> QV3DCanvas::viewer()
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324     qDebug() &lt;&lt; <span class="stringliteral">&quot;QVImageCanvas::viewer()&quot;</span>;
<a name="l00325"></a>00325     readInputProperties();
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     <span class="comment">// Draw other objects</span>
<a name="l00328"></a>00328     <span class="keywordflow">foreach</span>(QString name, getPropertyList())
<a name="l00329"></a>00329         <span class="keywordflow">if</span> (getPropertyFlags(name) &amp; inputFlag)
<a name="l00330"></a>00330             {
<a name="l00331"></a>00331             <span class="comment">// Draw QV3DPolylineF</span>
<a name="l00332"></a>00332             <span class="keywordflow">if</span> (isType&lt; QV3DPolylineF &gt;(name))
<a name="l00333"></a>00333                 draw(   getPropertyValue&lt; QV3DPolylineF &gt;(name),
<a name="l00334"></a>00334                     getPropertyValue&lt;QColor&gt;(<span class="stringliteral">&quot;Color for &quot;</span> + name),
<a name="l00335"></a>00335                     getPropertyValue&lt;double&gt;(<span class="stringliteral">&quot;Size for &quot;</span> + name));
<a name="l00336"></a>00336             <span class="comment">// Draw QList&lt;QV3DPointF&gt;</span>
<a name="l00337"></a>00337             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isType&lt; QList&lt;QV3DPointF&gt; &gt;(name))
<a name="l00338"></a>00338                 draw(   getPropertyValue&lt; QList&lt;QV3DPointF&gt; &gt;(name),
<a name="l00339"></a>00339                     getPropertyValue&lt;QColor&gt;(<span class="stringliteral">&quot;Color for &quot;</span> + name),
<a name="l00340"></a>00340                     getPropertyValue&lt;double&gt;(<span class="stringliteral">&quot;Size for &quot;</span> + name));
<a name="l00341"></a>00341             <span class="comment">// Draw QList&lt;QV3DPolylineF&gt;</span>
<a name="l00342"></a>00342             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isType&lt; QList&lt;QV3DPolylineF&gt; &gt;(name))
<a name="l00343"></a>00343                 <span class="keywordflow">foreach</span>(<a class="code" href="classQV3DPolylineF.html" title="3D polyline representation">QV3DPolylineF</a> polyline, getPropertyValue&lt; QList&lt;QV3DPolylineF&gt; &gt;(name))
<a name="l00344"></a>00344                     draw(       polyline,
<a name="l00345"></a>00345                         getPropertyValue&lt;QColor&gt;(<span class="stringliteral">&quot;Color for &quot;</span> + name));
<a name="l00346"></a>00346             }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="keywordflow">foreach</span>(QV3DModel *model, models)
<a name="l00349"></a>00349         model-&gt;updatePaint(*<span class="keyword">this</span>);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     qDebug() &lt;&lt; <span class="stringliteral">&quot;QVImageCanvas::viewer() -&gt; return&quot;</span>;
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keywordtype">void</span> QV3DCanvas::draw(<span class="keyword">const</span> <a class="code" href="classQV3DPolylineF.html" title="3D polyline representation">QV3DPolylineF</a> &amp;qv3DPolyline, <span class="keyword">const</span> QColor color, <span class="keyword">const</span> <span class="keywordtype">double</span> size)
<a name="l00355"></a>00355     {
<a name="l00356"></a>00356     glPointSize(size);
<a name="l00357"></a>00357     glBegin(GL_LINES);
<a name="l00358"></a>00358     qglColor(color);
<a name="l00359"></a>00359     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; qv3DPolyline.size(); i++)
<a name="l00360"></a>00360         {
<a name="l00361"></a>00361         glVertex3f(qv3DPolyline[i].x(), qv3DPolyline[i].y(), qv3DPolyline[i].z());
<a name="l00362"></a>00362         glVertex3f(qv3DPolyline[i-1].x(), qv3DPolyline[i-1].y(), qv3DPolyline[i-1].z());
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364     glEnd();
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keywordtype">void</span> QV3DCanvas::draw(<span class="keyword">const</span> QList&lt;QV3DPointF&gt; &amp;qv3DPointList, <span class="keyword">const</span> QColor color, <span class="keyword">const</span> <span class="keywordtype">double</span> size)
<a name="l00368"></a>00368     {
<a name="l00369"></a>00369                 glBegin(GL_POINTS);
<a name="l00370"></a>00370                 qglColor(color);
<a name="l00371"></a>00371                 glPointSize(size);
<a name="l00372"></a>00372                 <span class="keywordflow">foreach</span>(<a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> point, qv3DPointList) {
<a name="l00373"></a>00373                     <span class="comment">//QV3DEllipsoid(color, size, size, size, point.x(), point.y(), point.z(), 10, 10).updatePaint(*this);</span>
<a name="l00374"></a>00374                     glVertex3f(point.<a class="code" href="classQV3DPointF.html#aab1c8e4380b126607771339778a83a1e" title="Gets the value for the first coordinate of the 3D point.">x</a>(), point.<a class="code" href="classQV3DPointF.html#ab3999406794a8d4afa0718af691b8920" title="Gets the value for the second coordinate of the 3D point.">y</a>(), point.<a class="code" href="classQV3DPointF.html#aba286a7e040358ecbffce7c4566cdd8d" title="Gets the value for the third coordinate of the 3D point.">z</a>());
<a name="l00375"></a>00375                 }
<a name="l00376"></a>00376                 glEnd();
<a name="l00377"></a>00377          }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="keywordtype">bool</span> QV3DCanvas::linkUnspecifiedInputProperty(<a class="code" href="classQVPropertyContainer.html" title="Base class for dynamic property container objects.">QVPropertyContainer</a> *sourceContainer, QString sourcePropName, LinkType linkType)
<a name="l00380"></a>00380     {
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (linkType == SynchronousLink)
<a name="l00382"></a>00382         {
<a name="l00383"></a>00383         std::cerr       &lt;&lt; <span class="stringliteral">&quot;ERROR: QVImageCanvas::linkUnspecifiedInputProperty():&quot;</span>
<a name="l00384"></a>00384                 &lt;&lt; <span class="stringliteral">&quot; the linkType must be AsynchronousLink, the link will not be done&quot;</span>
<a name="l00385"></a>00385                 &lt;&lt; std::endl;
<a name="l00386"></a>00386         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389     <a class="code" href="classQVProcessingBlock.html" title="Base class for Block threads.">QVProcessingBlock</a>* block;
<a name="l00390"></a>00390     <span class="keywordflow">if</span>((block = dynamic_cast&lt;QVProcessingBlock*&gt;(sourceContainer)) != NULL)
<a name="l00391"></a>00391         {
<a name="l00392"></a>00392         std::cout &lt;&lt; <span class="stringliteral">&quot;QV3DCanvas: Adding property &#39;&quot;</span> &lt;&lt; qPrintable(sourcePropName) &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00393"></a>00393         addPropertyFromQVariant(sourcePropName, inputFlag, block-&gt;<a class="code" href="classQVPropertyContainer.html#a253156f365b20fa2e0accc82dff1284f" title="Method to get the value of a property as a QVariant.">getPropertyQVariantValue</a>(sourcePropName), block-&gt;<a class="code" href="classQVPropertyContainer.html#afbbd3b9914406c1e237d9443ea5fa48b" title="Method to get the info QString for int typed property.">getPropertyInfo</a>(sourcePropName));
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (    block-&gt;<a class="code" href="classQVPropertyContainer.html#afdd65a88f713e0031ac4847485acfce4" title="Checks if a property is of a given type.">isType</a>&lt; <a class="code" href="classQV3DPolylineF.html" title="3D polyline representation">QV3DPolylineF</a> &gt;(sourcePropName)          ||
<a name="l00395"></a>00395             block-&gt;<a class="code" href="classQVPropertyContainer.html#afdd65a88f713e0031ac4847485acfce4" title="Checks if a property is of a given type.">isType</a>&lt; QList&lt;QV3DPointF&gt; &gt;(sourcePropName)  ||
<a name="l00396"></a>00396             block-&gt;<a class="code" href="classQVPropertyContainer.html#afdd65a88f713e0031ac4847485acfce4" title="Checks if a property is of a given type.">isType</a>&lt; QList&lt;QV3DPolylineF&gt; &gt;(sourcePropName)               )
<a name="l00397"></a>00397             {
<a name="l00398"></a>00398             addProperty&lt;QColor&gt;(<span class="stringliteral">&quot;Color for &quot;</span> + sourcePropName, inputFlag, getNextColor(), QString(<span class="stringliteral">&quot;Color for object &quot;</span>) + sourcePropName);
<a name="l00399"></a>00399             addProperty&lt;double&gt;(<span class="stringliteral">&quot;Size for &quot;</span> + sourcePropName, inputFlag, 1, QString(<span class="stringliteral">&quot;Size for object &quot;</span>) + sourcePropName);
<a name="l00400"></a>00400             std::cout &lt;&lt; <span class="stringliteral">&quot;QV3DCanvas: Added property &#39;Color for &quot;</span> &lt;&lt; qPrintable(sourcePropName) &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00401"></a>00401             std::cout &lt;&lt; <span class="stringliteral">&quot;QV3DCanvas: Added property &#39;Size for &quot;</span> &lt;&lt; qPrintable(sourcePropName) &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00402"></a>00402             }
<a name="l00403"></a>00403         <span class="keywordtype">bool</span> result = block-&gt;<a class="code" href="classQVPropertyContainer.html#abd2a991c0bc91cee684ff3ffc80825dd" title="Links properties among QVPropertyContainer&amp;#39;s.">linkProperty</a>(sourcePropName, <span class="keyword">this</span>, sourcePropName ,QVProcessingBlock::AsynchronousLink);
<a name="l00404"></a>00404         <span class="comment">//QObject::connect(block, SIGNAL(endIteration(uint, int)), this, SLOT(refreshImageArea()));</span>
<a name="l00405"></a>00405         <span class="keywordflow">return</span> result;
<a name="l00406"></a>00406         }
<a name="l00407"></a>00407     <span class="keywordflow">else</span>
<a name="l00408"></a>00408         {
<a name="l00409"></a>00409         std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: QVImageCanvas::linkUnspecifiedInputProperty(): the sourceContainer container must be a QVProcessingBlock, the link will not be done&quot;</span> &lt;&lt; std::endl;
<a name="l00410"></a>00410         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="keywordtype">void</span> QV3DCanvas::drawQVImage(<a class="code" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a> *image)
<a name="l00415"></a>00415 {
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <a class="code" href="classQVGenericImage.html" title="Base class for QVImage objects.">QVGenericImage</a> *imagecopy=NULL;
<a name="l00418"></a>00418     <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,1&gt;&quot;</span>)) {
<a name="l00419"></a>00419         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>;
<a name="l00420"></a>00420         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,1&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00421"></a>00421     }
<a name="l00422"></a>00422     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,3&gt;&quot;</span>)) {
<a name="l00423"></a>00423         imagecopy = <span class="keyword">new</span> <a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>;
<a name="l00424"></a>00424         *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*<span class="keyword">&gt;</span>(imagecopy)) = *(<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classQVImage.html">QVImage&lt;uChar,3&gt;</a>*<span class="keyword">&gt;</span>(image));
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     <span class="keywordflow">else</span> {
<a name="l00427"></a>00427         <span class="comment">// alternate code for that type of image ...</span>
<a name="l00428"></a>00428         qFatal(<span class="stringliteral">&quot;Type of QVGenericImage still not supported in drawQVImage&quot;</span>);
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430 
<a name="l00432"></a>00432     <span class="keyword">const</span> <span class="keywordtype">int</span>   cols = image-&gt;<a class="code" href="classQVGenericImage.html#a398764a3e00a553dd8ac75f78f6bf18a" title="Virtual method for getting the number of columns of the image.">getCols</a>(),
<a name="l00433"></a>00433             rows = image-&gt;<a class="code" href="classQVGenericImage.html#a8731e208b2f33a3ab1795fc4389f1ef3" title="Virtual method for getting the number of rows of the image.">getRows</a>();
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     setMinimumSize(cols,rows);
<a name="l00436"></a>00436     setMaximumSize(cols,rows);
<a name="l00437"></a>00437     resize(cols,rows);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439     <span class="comment">// Push the current OpenGL projection and modelview matrices onto their</span>
<a name="l00440"></a>00440     <span class="comment">// respective stacks:</span>
<a name="l00441"></a>00441     glPushAttrib(GL_ALL_ATTRIB_BITS);
<a name="l00442"></a>00442     glPushClientAttrib(GL_ALL_ATTRIB_BITS);
<a name="l00443"></a>00443     glMatrixMode(GL_PROJECTION);
<a name="l00444"></a>00444     glPushMatrix();
<a name="l00445"></a>00445     glMatrixMode(GL_MODELVIEW);
<a name="l00446"></a>00446     glPushMatrix();
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="comment">// Set the correct viewport and perspective and model transformation</span>
<a name="l00449"></a>00449     <span class="comment">// for native OpenGL calls:</span>
<a name="l00450"></a>00450     glViewport(0,0,width(),height());
<a name="l00451"></a>00451     glMatrixMode(GL_PROJECTION);
<a name="l00452"></a>00452     glLoadIdentity();
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     glOrtho(0, cols, rows,0,-1,1);
<a name="l00455"></a>00455     glMatrixMode(GL_MODELVIEW);
<a name="l00456"></a>00456     glLoadIdentity();
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="comment">// Intersection of current window viewport and image rectangles:</span>
<a name="l00459"></a>00459     <span class="keyword">const</span> QRect final_rect =  QRect(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a9fede2a177fed58d69d9d13e93cd38b6" title="Obtains actual anchor point for the image.">getAnchor</a>()+imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().topLeft(),
<a name="l00460"></a>00460                           QSize(imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().width(),imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a55132f8ba36904516dcf384039c670e4" title="Method for obtaining actual region of interest for image.">getROI</a>().height()));
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="comment">// Now, render the image using OpenGL calls:</span>
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         <span class="comment">/* const double zoom = 1.0;*/</span>
<a name="l00465"></a>00465 
<a name="l00466"></a>00466     <span class="comment">// Now the dirty trick for offset, using glBitmap:</span>
<a name="l00467"></a>00467     glRasterPos2f(0.0 , 0.0);
<a name="l00468"></a>00468     glBitmap(0, 0, 0.0, 0.0, 0.0, 0.0, NULL);
<a name="l00469"></a>00469     glPixelZoom(1.0,-1.0);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="comment">// ... and second, WHAT to draw:</span>
<a name="l00472"></a>00472     <span class="comment">//QRect what(0,0,cols, rows);</span>
<a name="l00473"></a>00473     <span class="keywordtype">int</span> img_step = imagecopy-&gt;<a class="code" href="classQVGenericImage.html#a73b40cb2faa1943637116da270da800d" title="Virtual method for getting the row step of the image.">getStep</a>();
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     <span class="comment">/*what.setX(imagecopy-&gt;getROI().topLeft().x());</span>
<a name="l00476"></a>00476 <span class="comment">    what.setWidth(final_rect.width());</span>
<a name="l00477"></a>00477 <span class="comment">    what.setY(imagecopy-&gt;getROI().topLeft().y());</span>
<a name="l00478"></a>00478 <span class="comment">    what.setHeight(final_rect.height());*/</span>
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="comment">//std::cout &lt;&lt; &quot;what = &quot; &lt;&lt; what.x() &lt;&lt; &quot;, &quot; &lt;&lt; what.y() &lt;&lt; &quot;\t&quot; &lt;&lt; what.width() &lt;&lt; &quot;, &quot; &lt;&lt; what.height() &lt;&lt; std::endl;</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,1&gt;&quot;</span>))
<a name="l00483"></a>00483         {
<a name="l00484"></a>00484         glPixelStorei(GL_UNPACK_ROW_LENGTH, img_step);
<a name="l00485"></a>00485         glDrawPixels(cols, rows, GL_LUMINANCE, GL_UNSIGNED_BYTE, <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uchar,1&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData());
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(image-&gt;<a class="code" href="classQVGenericImage.html#a21b9bc211bcb5b0694ecdad16f1e5d59" title="Check whether an image is compatible in type with another image, provided its type...">isCompatibleWith</a>(<span class="stringliteral">&quot;QVImage&lt;uChar,3&gt;&quot;</span>))
<a name="l00488"></a>00488         {
<a name="l00489"></a>00489         glPixelStorei(GL_UNPACK_ROW_LENGTH, img_step/3);
<a name="l00490"></a>00490         glDrawPixels(cols, rows, GL_RGB, GL_UNSIGNED_BYTE, <span class="keyword">static_cast&lt;</span><a class="code" href="classQVImage.html" title="Image representation class for the QVision.">QVImage&lt;uchar,3&gt;</a> *<span class="keyword">&gt;</span>(imagecopy)-&gt;getReadData());
<a name="l00491"></a>00491         }
<a name="l00492"></a>00492     <span class="keywordflow">else</span>
<a name="l00493"></a>00493         qFatal(<span class="stringliteral">&quot;Type of QVGenericImage still not supported in drawQVImage&quot;</span>);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="comment">// Pop the OpenGL projection and modelview matrices off their respective</span>
<a name="l00496"></a>00496     <span class="comment">// stacks. Pop the OpenGL attributes off the attribute stack.</span>
<a name="l00497"></a>00497     glPopClientAttrib();
<a name="l00498"></a>00498     glPopAttrib();
<a name="l00499"></a>00499     glMatrixMode(GL_MODELVIEW);
<a name="l00500"></a>00500     glPopMatrix();
<a name="l00501"></a>00501     glMatrixMode(GL_PROJECTION);
<a name="l00502"></a>00502     glPopMatrix();
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="keywordtype">void</span> QV3DEllipsoid::paint(QV3DCanvas &amp;glWidget)
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507     glWidget.qglColor(color);
<a name="l00508"></a>00508     <span class="comment">//glWidget.qglColor(Qt::yellow);</span>
<a name="l00509"></a>00509     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= lats; i++)
<a name="l00510"></a>00510         {
<a name="l00511"></a>00511         <span class="keywordtype">double</span> lat0 = M_PI * (-0.5 + (double) (i - 1) / lats);
<a name="l00512"></a>00512         <span class="keywordtype">double</span> z0 = sin(lat0);
<a name="l00513"></a>00513         <span class="keywordtype">double</span> zr0 = cos(lat0);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="keywordtype">double</span> lat1 = M_PI * (-0.5 + (double) i / lats);
<a name="l00516"></a>00516         <span class="keywordtype">double</span> z1 = sin(lat1);
<a name="l00517"></a>00517         <span class="keywordtype">double</span> zr1 = cos(lat1);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         glBegin(GL_QUAD_STRIP);
<a name="l00520"></a>00520         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt;= longs; j++)
<a name="l00521"></a>00521             {
<a name="l00522"></a>00522             <span class="keywordtype">double</span> lng = 2 * M_PI * (double) (j - 1) / longs;
<a name="l00523"></a>00523             <span class="keywordtype">double</span> x = cos(lng);
<a name="l00524"></a>00524             <span class="keywordtype">double</span> y = sin(lng);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526             glNormal3f(rx * x * zr0 + cx, ry * y * zr0 + cy, rz * z0 + cz);
<a name="l00527"></a>00527             glVertex3f(rx * x * zr0 + cx, ry * y * zr0 + cy, rz * z0 + cz);
<a name="l00528"></a>00528             glNormal3f(rx * x * zr1 + cx, ry * y * zr1 + cy, rz * z1 + cz);
<a name="l00529"></a>00529             glVertex3f(rx * x * zr1 + cx, ry * y * zr1 + cy, rz * z1 + cz);
<a name="l00530"></a>00530             }
<a name="l00531"></a>00531         glEnd();
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533     };
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 <span class="preprocessor">#endif</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span>
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
