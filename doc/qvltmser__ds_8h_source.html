<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvltmser/qvltmser_ds.h</h1><a href="qvltmser__ds_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef QVLTMSER_DS_H</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#define QVLTMSER_DS_H</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;QVImage&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;QVector&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;QVMSER&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">// Class for boundary pixels (it is a priority queue of stacks, with high priority for darker gray levels:</span>
<a name="l00033"></a>00033 <span class="keyword">class </span>QVLtmserBoundary {
<a name="l00034"></a>00034   <span class="keyword">public</span>:
<a name="l00035"></a>00035     <span class="comment">// Index of maximum priority entry on the queue (-1 if empty):</span>
<a name="l00036"></a>00036     <span class="keywordtype">int</span> maxStackPr;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="comment">// Constructor:</span>
<a name="l00039"></a>00039     <span class="comment">// * pGreyLevels: number of gray levels of image.</span>
<a name="l00040"></a>00040     <span class="comment">// * pWidth, pHeight: image dimensions.</span>
<a name="l00041"></a>00041     QVLtmserBoundary(uInt pWidth, uInt pHeight, uInt pGreyLevels);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     <span class="comment">// Heap initialization:</span>
<a name="l00044"></a>00044     <span class="keywordtype">void</span> initHeap(QVector&lt; int &gt; &amp;histogram);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">// Push a new pixel in boundary, for a given gray level:</span>
<a name="l00047"></a>00047     <span class="keywordtype">void</span> pushPixel(uInt greyLevel, uInt pixel);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049     <span class="comment">// Pop a pixel from boundary (returns true if it has been possible, false otherwise):</span>
<a name="l00050"></a>00050     <span class="keywordtype">bool</span> popPixel(uInt greyLevel, uInt &amp;pixel);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="keyword">protected</span>:
<a name="l00053"></a>00053     <span class="comment">// Image size:</span>
<a name="l00054"></a>00054     uInt width, height;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="comment">// Number of gray levels:</span>
<a name="l00057"></a>00057     uInt greyLevels;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     <span class="comment">// Number of pixels to process:</span>
<a name="l00060"></a>00060     uInt numPixels;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="comment">// Length of stacks:</span>
<a name="l00063"></a>00063     QVector&lt;int&gt; stackLength;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="comment">// Start of each stack (-1 if it will never have any pixel):</span>
<a name="l00066"></a>00066     QVector&lt;int&gt; stackStart;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068     <span class="comment">// The heap is implemented in a compressed manner. Array stackStart contains the start index of each stack</span>
<a name="l00069"></a>00069     <span class="comment">// (for a given priority), or -1 if that stack is empty, while array stackLength contains the corresponding</span>
<a name="l00070"></a>00070     <span class="comment">// top of the stack. The first array will be initialized once at the beginning, using the image histogram.</span>
<a name="l00071"></a>00071     <span class="comment">// Note: Coordinates of pixels have been previously transformed to ints (int_value=(y*num_cols)+x).</span>
<a name="l00072"></a>00072     QVector&lt;uInt&gt; heap;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="comment">// Get index of stack with greater priority (-1 if heap is empty)</span>
<a name="l00075"></a>00075     <span class="keywordtype">int</span> getMaxStackPr();
<a name="l00076"></a>00076 };
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">// Class for each individual component of the component stack:</span>
<a name="l00079"></a>00079 <span class="keyword">class </span>QVLtmserComponent {
<a name="l00080"></a>00080   <span class="keyword">public</span>:
<a name="l00081"></a>00081     <span class="comment">// Constructor:</span>
<a name="l00082"></a>00082     QVLtmserComponent(uInt pGreyLevel);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084     <span class="comment">// Destructor.</span>
<a name="l00085"></a>00085     ~QVLtmserComponent();
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">// Current and minimum gray levels of component:</span>
<a name="l00088"></a>00088     uChar greyLevel, greyLevelMin;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="comment">// Seed pixel: (at the deepest point of component):</span>
<a name="l00091"></a>00091     uInt seedX, seedY;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <span class="comment">// Number of pixels that the component has in the current grayLevel:</span>
<a name="l00094"></a>00094     uInt numPixels;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">// History of areas of the component:</span>
<a name="l00097"></a>00097     QVector&lt;uInt&gt; *history;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="comment">// Static class members: pointer to result seed list and algorithm parameters:</span>
<a name="l00100"></a>00100     <span class="keyword">static</span> QHash&lt;QPoint,QVMSER&gt; theSeedList;
<a name="l00101"></a>00101     <span class="keyword">static</span> uInt minArea;
<a name="l00102"></a>00102     <span class="keyword">static</span> uInt maxArea;
<a name="l00103"></a>00103     <span class="keyword">static</span> uChar delta;
<a name="l00104"></a>00104     <span class="keyword">static</span> <span class="keywordtype">float</span> delta_threshold;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="comment">// Set seed of component:</span>
<a name="l00107"></a>00107     <span class="keywordtype">void</span> setSeed(uInt r, uInt c);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="comment">// Add a new pixel to component:</span>
<a name="l00110"></a>00110     <span class="keywordtype">void</span> addPixel(uChar pGreyLevel);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     <span class="comment">// Test if component is a MSER:</span>
<a name="l00113"></a>00113     <span class="keywordtype">void</span> testMSER();
<a name="l00114"></a>00114                    
<a name="l00115"></a>00115     <span class="comment">// Raise gray level to &quot;newGreyLevel&quot;, updating variables &quot;greyLevel&quot; and &quot;numPixels&quot;, and history of component:</span>
<a name="l00116"></a>00116     <span class="keywordtype">void</span> upGreyLevel(uInt newGreyLevel);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">// Add another component to this component:</span>
<a name="l00119"></a>00119     <span class="keywordtype">void</span> addComponent(QVLtmserComponent &amp;otherComponent, uInt newlevel);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="keyword">private</span>:
<a name="l00122"></a>00122     <span class="comment">// Reference counter to history (to delete it in destructor when counter reaches zero):</span>
<a name="l00123"></a>00123     uInt countRefsHistory;
<a name="l00124"></a>00124 };
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">// Class for component stack:</span>
<a name="l00127"></a>00127 <span class="keyword">class </span>QVLtmserComponentStack {
<a name="l00128"></a>00128   <span class="keyword">public</span>:
<a name="l00129"></a>00129     <span class="comment">// Constructor:</span>
<a name="l00130"></a>00130     <span class="comment">// * pGreyLevels: Number of possible gray levels:</span>
<a name="l00131"></a>00131     QVLtmserComponentStack(uInt pGreyLevels);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="comment">// Destructor:</span>
<a name="l00134"></a>00134     ~QVLtmserComponentStack();
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="comment">// Components of stack are stored as pointers in a vector:</span>
<a name="l00137"></a>00137     QVector&lt;QVLtmserComponent*&gt; *components;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="comment">// Initialize component stack:</span>
<a name="l00140"></a>00140     <span class="keywordtype">void</span> initComponents();
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="comment">// Push a new component in the stack (its gray level must be lesser than the gray level of component that</span>
<a name="l00143"></a>00143     <span class="comment">// was until now in the top):</span>
<a name="l00144"></a>00144     <span class="keywordtype">void</span> pushComponent(uInt aGreyLevel, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> c);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="comment">// Pop and destroy the component in the top of the stack:</span>
<a name="l00147"></a>00147     <span class="keywordtype">void</span> popComponent();
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     <span class="comment">// Get index in vector corresponding to top (returns -1 if empty):</span>
<a name="l00150"></a>00150     <span class="keywordtype">int</span> getPosTop();
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   <span class="keyword">protected</span>:
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="comment">// Number of gray levels:</span>
<a name="l00155"></a>00155     uInt greyLevels;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="comment">// Position of top in &quot;components&quot;. If empty, posTop=-1:</span>
<a name="l00158"></a>00158     <span class="keywordtype">int</span> posTop;
<a name="l00159"></a>00159 };
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="preprocessor">#endif</span>
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
