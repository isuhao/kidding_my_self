<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- 
	Copyright (C) 2007, 2008, 2009, 2010, 2011. PARP Research Group.
	<http://perception.inf.um.es>
	University of Murcia, Spain.

	This file is part of the QVision library.

	QVision is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation, version 3 of the License.

	QVision is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with QVision. If not, see <http://www.gnu.org/licenses/>.
-->

<html><head><meta http-equiv="content-Type" content="text/html;charset=UTF-8">
<title>QVision: Qt&#39;s Image, Video and Computer Vision Library</title>
<meta name="title" content="QVision" />
<meta name="dc.title" content="QVision" />
<meta name="url" content="http://perception.inf.um.es/QVision" />
<meta name="author" content="PARP Research Group - http://perception.inf.um.es" />
<meta name="revisit-after" content="30 DAYS"/>
<meta name="robots" content="index,follow"/>
<meta name="classification" content="*">
<meta name="rating" content="Safe For Kids">
<meta name="distribution" content="GLOBAL"/>
<meta name="description" content="Qt's Image, Video and Computer Vision Library"/>
<meta name="page-topic" content="Computer Vision research and prototype programming"/>
<meta name="geo.country" content="ES" />

<!--
Keywords:
By license:		open source, gnu, lgpl, gpl, free
By theme:		computer vision, image processing, robotics, programming, source, development
By usage:		library, toolkit, framework, prototype, application
By programming specs:	object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping
Interoperability with:	Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack
Functionallity:		image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface
Main data-types:	matrix, vector, tensor, quaternion, image, polyline
Video sources:		webcam, camera, stream
Devices:		embedded, desktop computer, laptop, mini-laptop
Authors:		PARP research group. University of Murcia, Spain.
-->

<meta name="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="keywords" content="augmented reality, sfm, structure from motion, open source, gnu, lgpl, gpl, free, computer vision, image processing, robotics, programming, source, development, library, toolkit, framework, prototype, application, object oriented, c++, block programming, reusability, gui, graphical, parallel computing, high performance, GPU, prototyping, Qt, GSL, GNU Scientific library, OpenCV, CGAL, QWT, CUDA, mplayer, IPP, Intel Image Performance Primitives, blas, lapack, image features, matrix algebra, projective geometry, mser, function minimization, function optimization, canny operator, harris operator, corner detection, performance evaluation, cpu usage, graphical interface, matrix, vector, tensor, quaternion, image, polyline, webcam, camera, stream, embedded, desktop computer, laptop, mini-laptop, University of Murcia, Spain, PARP research group, vision por computador"/>
<meta http-equiv="pragma" content="no-cache"/>
<meta http-equiv="title" content="QVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" />
</head><body>

<table width="100%"><tr>
	<td><a href="http://perception.inf.um.es/"><img src="parp.png" border="0" /> <big>PARP Research Group</big></a></td>
	<td align="right"><a href="http://www.um.es/"><big>Universidad de Murcia</big> <img src="um.png" border="0" /></a></td>
</tr></table>

<hr /><br />

<table width="95%" align="center"><tr><td>

<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <form id="FSearchBox" action="search.php" method="get">
            <img id="MSearchSelect" src="search/search.png" alt=""/>
            <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                   onfocus="searchBox.OnSearchFieldFocus(true)" 
                   onblur="searchBox.OnSearchFieldFocus(false)"/>
          </form>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/qvsfm/readSfMReconstruction.cpp</h1><a href="readSfMReconstruction_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *      Copyright (C) 2011, 2012. PARP Research Group.</span>
<a name="l00003"></a>00003 <span class="comment"> *      &lt;http://perception.inf.um.es&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *      University of Murcia, Spain.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *      This file is part of the QVision library.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *      QVision is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> *      it under the terms of the GNU Lesser General Public License as</span>
<a name="l00010"></a>00010 <span class="comment"> *      published by the Free Software Foundation, version 3 of the License.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *      QVision is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *      but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *      GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *      You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *      License along with QVision. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;qvsfm.h&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">// Read the numbers contained in the file, as a vector</span>
<a name="l00028"></a>00028 <span class="comment">// Faster than &#39;readVector&#39;.</span>
<a name="l00029"></a>00029 <span class="keywordtype">bool</span> readNumbersFromTextStream(QTextStream &amp;stream, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;numbers, <span class="keyword">const</span> <span class="keywordtype">int</span> estimatedSize)
<a name="l00030"></a>00030         {
<a name="l00031"></a>00031         numbers.clear();
<a name="l00032"></a>00032         numbers.reserve(estimatedSize);
<a name="l00033"></a>00033 
<a name="l00034"></a>00034         <span class="keywordtype">double</span> sign = +1.0;
<a name="l00035"></a>00035         <span class="keywordtype">int</span> idx = 0;
<a name="l00036"></a>00036         <span class="keywordtype">char</span> buffer[256] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038         <span class="keywordflow">while</span> (not stream.atEnd())
<a name="l00039"></a>00039                 {
<a name="l00040"></a>00040                 <span class="keywordtype">char</span> c;
<a name="l00041"></a>00041                 stream &gt;&gt; c;
<a name="l00042"></a>00042                 <span class="comment">//file.getChar(&amp;c);</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044                 <span class="comment">// If number, dot, or minus, store in the buffer.</span>
<a name="l00045"></a>00045                 <span class="keywordflow">if</span> (    ( (c &gt;= <span class="charliteral">&#39;0&#39;</span>) and (c &lt;= <span class="charliteral">&#39;9&#39;</span>) ) or 
<a name="l00046"></a>00046                                 ( (idx &gt; 0) and (c == <span class="charliteral">&#39;e&#39;</span>) ) or
<a name="l00047"></a>00047                                 (c == &#39;.&#39;) <span class="comment">//or (c == &#39;-&#39;) or (c == &#39;+&#39;)</span>
<a name="l00048"></a>00048                         )
<a name="l00049"></a>00049                         buffer[idx++] = c;
<a name="l00050"></a>00050                 <span class="comment">// Ignore line comments.</span>
<a name="l00051"></a>00051                 else if ( c == &#39;<span class="preprocessor">#&#39; )</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>                        {
<a name="l00053"></a>00053                         <span class="keywordflow">while</span> ( (c != <span class="charliteral">&#39;\n&#39;</span>) and (not stream.atEnd()) )
<a name="l00054"></a>00054                                 stream &gt;&gt; c;
<a name="l00055"></a>00055                                 <span class="comment">//file.getChar(&amp;c);</span>
<a name="l00056"></a>00056                         <span class="keywordflow">if</span> (stream.atEnd())
<a name="l00057"></a>00057                                 <span class="keywordflow">break</span>;
<a name="l00058"></a>00058                         }
<a name="l00059"></a>00059                 <span class="keywordflow">else</span>
<a name="l00060"></a>00060                         {
<a name="l00061"></a>00061                         buffer[idx] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063                         <span class="keywordflow">if</span> (idx &gt; 0)
<a name="l00064"></a>00064                                 numbers &lt;&lt; sign * atof(buffer);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066                         idx = 0;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068                         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;-&#39;</span>)
<a name="l00069"></a>00069                                 sign = -1.0;
<a name="l00070"></a>00070                         <span class="keywordflow">else</span> <span class="comment">//if (c == &#39;+&#39;)</span>
<a name="l00071"></a>00071                                 sign = +1.0;
<a name="l00072"></a>00072                         }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074                 <span class="keywordflow">if</span>(idx &gt;= 256)
<a name="l00075"></a>00075                         {
<a name="l00076"></a>00076                         std::cout &lt;&lt; <span class="stringliteral">&quot;[readNumbersFromFile] Error: buffer overrun.&quot;</span> &lt;&lt; std::endl;
<a name="l00077"></a>00077                         exit(0);
<a name="l00078"></a>00078                         }
<a name="l00079"></a>00079                 }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00082"></a>00082         }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">// Read the numbers contained in the file, as a vector</span>
<a name="l00086"></a>00086 <span class="comment">// Faster than &#39;readVector&#39;.</span>
<a name="l00087"></a>00087 <span class="keywordtype">bool</span> readNumbersFromFile(QFile &amp;file, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;numbers, <span class="keyword">const</span> <span class="keywordtype">int</span> estimatedSize)
<a name="l00088"></a>00088         {
<a name="l00089"></a>00089         numbers.clear();
<a name="l00090"></a>00090         numbers.reserve(estimatedSize);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         <span class="keywordtype">double</span> sign = +1.0;
<a name="l00093"></a>00093         <span class="keywordtype">int</span> idx = 0;
<a name="l00094"></a>00094         <span class="keywordtype">char</span> buffer[256] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         <span class="keywordflow">while</span> (not file.atEnd())
<a name="l00097"></a>00097                 {
<a name="l00098"></a>00098                 <span class="keywordtype">char</span> c;
<a name="l00099"></a>00099                 file.getChar(&amp;c);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101                 <span class="comment">// If number, dot, or minus, store in the buffer.</span>
<a name="l00102"></a>00102                 <span class="keywordflow">if</span> (    ( (c &gt;= <span class="charliteral">&#39;0&#39;</span>) and (c &lt;= <span class="charliteral">&#39;9&#39;</span>) ) or 
<a name="l00103"></a>00103                                 ( (idx &gt; 0) and (c == <span class="charliteral">&#39;e&#39;</span>) ) or
<a name="l00104"></a>00104                                 (c == <span class="charliteral">&#39;.&#39;</span>) <span class="comment">//or (c == &#39;-&#39;) or (c == &#39;+&#39;)</span>
<a name="l00105"></a>00105                         )
<a name="l00106"></a>00106                         buffer[idx++] = c;
<a name="l00107"></a>00107                 <span class="comment">// Ignore line comments.</span>
<a name="l00108"></a>00108                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( c == <span class="charliteral">&#39;#&#39;</span> )
<a name="l00109"></a>00109                         {
<a name="l00110"></a>00110                         <span class="keywordflow">while</span> ( (c != <span class="charliteral">&#39;\n&#39;</span>) and (not file.atEnd()) )
<a name="l00111"></a>00111                                 file.getChar(&amp;c);
<a name="l00112"></a>00112                         <span class="keywordflow">if</span> (file.atEnd())
<a name="l00113"></a>00113                                 <span class="keywordflow">break</span>;
<a name="l00114"></a>00114                         }
<a name="l00115"></a>00115                 <span class="keywordflow">else</span>
<a name="l00116"></a>00116                         {
<a name="l00117"></a>00117                         buffer[idx] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119                         <span class="keywordflow">if</span> (idx &gt; 0)
<a name="l00120"></a>00120                                 numbers &lt;&lt; sign * atof(buffer);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122                         idx = 0;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124                         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;-&#39;</span>)
<a name="l00125"></a>00125                                 sign = -1.0;
<a name="l00126"></a>00126                         <span class="keywordflow">else</span> <span class="comment">//if (c == &#39;+&#39;)</span>
<a name="l00127"></a>00127                                 sign = +1.0;
<a name="l00128"></a>00128                         }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130                 <span class="keywordflow">if</span>(idx &gt;= 256)
<a name="l00131"></a>00131                         {
<a name="l00132"></a>00132                         std::cout &lt;&lt; <span class="stringliteral">&quot;[readNumbersFromFile] Error: buffer overrun.&quot;</span> &lt;&lt; std::endl;
<a name="l00133"></a>00133                         exit(0);
<a name="l00134"></a>00134                         }
<a name="l00135"></a>00135                 }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00138"></a>00138         }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">// Read the numbers contained in the file, as a vector</span>
<a name="l00141"></a>00141 <span class="comment">// Faster than &#39;readVector&#39;.</span>
<a name="l00142"></a>00142 <span class="keywordtype">bool</span> readNumbersFromFile(<span class="keyword">const</span> QString fileName, <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> &amp;numbers, <span class="keyword">const</span> <span class="keywordtype">int</span> estimatedSize)
<a name="l00143"></a>00143         {
<a name="l00144"></a>00144         QFile file(fileName);
<a name="l00145"></a>00145         <span class="keywordflow">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00146"></a>00146                 {
<a name="l00147"></a>00147                 std::cout &lt;&lt; <span class="stringliteral">&quot;[readNumbersFromFile] Cannot open file &quot;</span> &lt;&lt; qPrintable(fileName) &lt;&lt; std::endl;
<a name="l00148"></a>00148                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00149"></a>00149                 }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="keywordflow">return</span> readNumbersFromFile(file, numbers, estimatedSize);
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> readVector(QFile &amp;file)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156     <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00157"></a>00157     <span class="keywordflow">while</span>(not file.atEnd())
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00161"></a>00161             <span class="keywordflow">continue</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         <span class="keyword">const</span> QStringList stringList = line.split(<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         QList&lt;double&gt; vector;
<a name="l00166"></a>00166         <span class="keywordflow">foreach</span>(QString <span class="keywordtype">string</span>, stringList)
<a name="l00167"></a>00167             {
<a name="l00168"></a>00168             <span class="keyword">const</span> <span class="keywordtype">double</span> value = <span class="keywordtype">string</span>.toDouble(&amp;ok);
<a name="l00169"></a>00169             <span class="keywordflow">if</span> (ok)
<a name="l00170"></a>00170                 vector &lt;&lt; value;
<a name="l00171"></a>00171             }
<a name="l00172"></a>00172         <span class="keywordflow">return</span> vector.toVector();
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174     <span class="keywordflow">return</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>(0,0.0);
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> readVector(<span class="keyword">const</span> QString &amp;line)
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179     <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00180"></a>00180     <span class="keyword">const</span> QStringList stringList = line.split(<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     QList&lt;double&gt; vector;
<a name="l00183"></a>00183     <span class="keywordflow">foreach</span>(QString <span class="keywordtype">string</span>, stringList)
<a name="l00184"></a>00184         {
<a name="l00185"></a>00185         <span class="keyword">const</span> <span class="keywordtype">double</span> value = <span class="keywordtype">string</span>.toDouble(&amp;ok);
<a name="l00186"></a>00186         <span class="keywordflow">if</span> (ok)
<a name="l00187"></a>00187             vector &lt;&lt; value;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189     <span class="keywordflow">return</span> vector.toVector();
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> readMatrix(<span class="keyword">const</span> QString fileName)
<a name="l00194"></a>00194     {
<a name="l00195"></a>00195     QFile file(fileName);
<a name="l00196"></a>00196     <span class="keywordflow">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00197"></a>00197                 <span class="keywordflow">return</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>();
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     QList&lt;QVVector&gt; rows;
<a name="l00200"></a>00200     <span class="keywordflow">while</span> (!file.atEnd())
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00203"></a>00203         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00204"></a>00204             <span class="keywordflow">continue</span>;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keyword">const</span> QStringList stringList = line.split (<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> v;
<a name="l00209"></a>00209         <span class="keywordflow">foreach</span>(QString <span class="keywordtype">string</span>, stringList)
<a name="l00210"></a>00210             {
<a name="l00211"></a>00211             <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00212"></a>00212             <span class="keyword">const</span> <span class="keywordtype">double</span> value = <span class="keywordtype">string</span>.toDouble(&amp;ok);
<a name="l00213"></a>00213             <span class="keywordflow">if</span> (ok)
<a name="l00214"></a>00214                 v &lt;&lt; value;
<a name="l00215"></a>00215             }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         rows &lt;&lt; v;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219     <span class="keywordflow">return</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(rows);
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="group__qvsfm.html#gaa8c336259c5d54dc09ad6fe8ab1ddb91">00222</a> <span class="keywordtype">bool</span> <a class="code" href="group__qvsfm.html#gaa8c336259c5d54dc09ad6fe8ab1ddb91" title="Loads a SfM reconstruction from a NVM file.">readReconstruction_NVM</a>(    <span class="keyword">const</span> QString fileName,
<a name="l00223"></a>00223                                                                 QList&lt;QString&gt; &amp;imageFiles,
<a name="l00224"></a>00224                                                                 QList&lt;QVMatrix&gt; &amp;cameraCalibrationMatrices,
<a name="l00225"></a>00225                                                                 QList&lt;QVCameraPose&gt; &amp;cameraPoses,
<a name="l00226"></a>00226                                                                 QList&lt;QV3DPointF&gt; &amp;points3D,
<a name="l00227"></a>00227                                                                 QList&lt; QColor &gt; &amp;rgbColors,
<a name="l00228"></a>00228                                                                 QList&lt; QHash&lt; int, QPointF&gt; &gt; &amp;pointTrackings)
<a name="l00229"></a>00229     {
<a name="l00230"></a>00230         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> temp;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         imageFiles.clear();
<a name="l00233"></a>00233         cameraCalibrationMatrices.clear();
<a name="l00234"></a>00234     cameraPoses.clear();
<a name="l00235"></a>00235     points3D.clear();
<a name="l00236"></a>00236     rgbColors.clear();
<a name="l00237"></a>00237     pointTrackings.clear();
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordtype">int</span> numline = 0;
<a name="l00240"></a>00240     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_NVM] Opening file&quot;</span> &lt;&lt; std::endl;
<a name="l00241"></a>00241     QFile file(fileName);
<a name="l00242"></a>00242     <span class="keywordflow">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00243"></a>00243         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (not line.startsWith(<span class="stringliteral">&quot;NVM_V3&quot;</span>))
<a name="l00247"></a>00247                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <span class="comment">// Read cameras.</span>
<a name="l00250"></a>00250         file.readLine();
<a name="l00251"></a>00251         temp = readVector(file);
<a name="l00252"></a>00252         <span class="keywordflow">if</span> (temp.count() != 1)
<a name="l00253"></a>00253                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00254"></a>00254         <span class="keyword">const</span> <span class="keywordtype">int</span> numCameras = temp[0];
<a name="l00255"></a>00255         std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_NVM] Reading &quot;</span> &lt;&lt; numCameras &lt;&lt; <span class="stringliteral">&quot; cameras...&quot;</span>;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; numCameras; idx++)
<a name="l00258"></a>00258                 {
<a name="l00259"></a>00259                 <span class="keyword">const</span> QStringList tokens = QString(file.readLine()).split(<span class="charliteral">&#39;\t&#39;</span>);
<a name="l00260"></a>00260                 <span class="keywordflow">if</span> (tokens.count() != 2)
<a name="l00261"></a>00261                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263                 temp = readVector(tokens[1]);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265                 <span class="keywordflow">if</span> (temp.count() != 10)
<a name="l00266"></a>00266                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268                 imageFiles &lt;&lt; tokens[0];
<a name="l00269"></a>00269                 cameraCalibrationMatrices &lt;&lt; <a class="code" href="classQVMatrix.html#a953207e797ad5c2f8477d3507dbcf86b" title="Creates an intrinsic camera calibration matrix.">QVMatrix::cameraCalibrationMatrix</a>(temp[0]);
<a name="l00270"></a>00270                 cameraPoses &lt;&lt; <a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a>( <a class="code" href="classQVQuaternion.html" title="Implementation of quaternions.">QVQuaternion</a>(temp[2], temp[3], temp[4], temp[1]), <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(temp[5], temp[6], temp[7]));
<a name="l00271"></a>00271                 }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         std::cout &lt;&lt; <span class="stringliteral">&quot;done.&quot;</span> &lt;&lt; std::endl;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="comment">// Read points.</span>
<a name="l00276"></a>00276         file.readLine();
<a name="l00277"></a>00277         temp = readVector(file);
<a name="l00278"></a>00278         <span class="keywordflow">if</span> (temp.count() != 1)
<a name="l00279"></a>00279                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00280"></a>00280         <span class="keyword">const</span> <span class="keywordtype">int</span> numPoints = temp[0];
<a name="l00281"></a>00281         std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_NVM] Reading &quot;</span> &lt;&lt; numPoints &lt;&lt; <span class="stringliteral">&quot; points...&quot;</span> &lt;&lt; std::endl;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numPoints; i++)
<a name="l00284"></a>00284                 {
<a name="l00285"></a>00285                 temp = readVector(file);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287                 points3D &lt;&lt; <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(temp[0], temp[1], temp[2]);
<a name="l00288"></a>00288                 rgbColors &lt;&lt; QColor(temp[3], temp[4], temp[5]);
<a name="l00289"></a>00289                 <span class="keyword">const</span> <span class="keywordtype">int</span> numMeasurements = temp[6];
<a name="l00290"></a>00290 
<a name="l00291"></a>00291                 <span class="keywordflow">if</span>(temp.count() - 7 != numMeasurements * 4)
<a name="l00292"></a>00292                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294                 QHash&lt; int, QPointF&gt; tracking;
<a name="l00295"></a>00295                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 7; j &lt; temp.count(); j+=4)
<a name="l00296"></a>00296                         tracking[ temp[j] ] = QPointF(temp[j+2], temp[j+3]);
<a name="l00297"></a>00297                 pointTrackings &lt;&lt; tracking;
<a name="l00298"></a>00298                 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_NVM] Readed &quot;</span>     &lt;&lt; numPoints &lt;&lt; <span class="stringliteral">&quot; points, &quot;</span> &lt;&lt; numCameras &lt;&lt; <span class="stringliteral">&quot; cameras.&quot;</span> &lt;&lt; std::endl;
<a name="l00303"></a>00303     file.close();
<a name="l00304"></a>00304     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="keywordtype">bool</span> readReconstruction_BAITL(  <span class="keyword">const</span> QString fileName,
<a name="l00309"></a>00309                 QList&lt;QVMatrix&gt; &amp;cameraCalibrations,
<a name="l00310"></a>00310                 QList&lt;QVCameraPose&gt; &amp;cameraPoses,
<a name="l00311"></a>00311                 QList&lt;QV3DPointF&gt; &amp;points3D,
<a name="l00312"></a>00312                 QList&lt; QColor &gt; &amp;rgbColors,
<a name="l00313"></a>00313                 QList&lt; QHash&lt; int, QPointF&gt; &gt; &amp;pointTrackings)
<a name="l00314"></a>00314     {
<a name="l00315"></a>00315     <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>      A1 = <a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(<a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(+1.0, -1.0, +1.0)),
<a name="l00316"></a>00316             A2 = <a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(<a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(+1.0, +1.0, -1.0)),
<a name="l00317"></a>00317             A3 = <a class="code" href="classQVMatrix.html#abcfe032545b49448a2a064a7952f7ece" title="Gets the diagonal of the matrix.">QVMatrix::diagonal</a>(<a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(-1.0, +1.0, +1.0));
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     cameraPoses.clear();
<a name="l00320"></a>00320     points3D.clear();
<a name="l00321"></a>00321     rgbColors.clear();
<a name="l00322"></a>00322     pointTrackings.clear();
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keywordtype">int</span> numline = 0;
<a name="l00325"></a>00325     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL] Opening file&quot;</span> &lt;&lt; std::endl;
<a name="l00326"></a>00326     QFile file(fileName);
<a name="l00327"></a>00327     <span class="keywordflow">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00328"></a>00328         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00331"></a>00331     <span class="keywordtype">int</span> numCameras = -1, numPoints = -1, numProjections = -1;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     <span class="comment">// Read header</span>
<a name="l00334"></a>00334     <span class="keywordflow">while</span> (not ok and not file.atEnd())
<a name="l00335"></a>00335         {
<a name="l00336"></a>00336         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00338"></a>00338             <span class="keywordflow">continue</span>;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keyword">const</span> QStringList stringList = line.split (<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         numCameras = stringList[0].toInt(&amp;ok);
<a name="l00343"></a>00343         numPoints = stringList[1].toInt(&amp;ok);
<a name="l00344"></a>00344         numProjections = stringList[2].toInt(&amp;ok);
<a name="l00345"></a>00345         numline++;
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="keyword">const</span> <span class="keywordtype">int</span> fractionCameras = numCameras / 7, fractionPoints = numPoints / 7, fractionProjections = numProjections / 7;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="comment">// Read point projections</span>
<a name="l00351"></a>00351     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numPoints; i++)
<a name="l00352"></a>00352         pointTrackings &lt;&lt; QHash&lt; int, QPointF&gt;();
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL] Reading &quot;</span> &lt;&lt; numProjections &lt;&lt; <span class="stringliteral">&quot; projections&quot;</span> &lt;&lt; std::endl;
<a name="l00355"></a>00355     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> numProjection = 0; numProjection &lt; numProjections; numProjection++)
<a name="l00356"></a>00356         {
<a name="l00357"></a>00357         <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> line = readVector(file);
<a name="l00358"></a>00358         numline++;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (line.count() != 4)
<a name="l00361"></a>00361             std::cout &lt;&lt; <span class="stringliteral">&quot;Error: in point projections list.&quot;</span> &lt;&lt; std::endl;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         <span class="keyword">const</span> <span class="keywordtype">int</span> numCamera = line[0], numPoint = line[1];
<a name="l00364"></a>00364         <span class="keyword">const</span> QPointF projection(line[2], line[3]);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">if</span> (numCamera +1 &gt; numCameras or numCamera &lt; 0)
<a name="l00367"></a>00367             std::cout &lt;&lt; <span class="stringliteral">&quot;Error: camera index out of bounds.&quot;</span> &lt;&lt; std::endl;
<a name="l00368"></a>00368         <span class="keywordflow">if</span> (numPoint +1 &gt; numPoints or numPoint &lt; 0)
<a name="l00369"></a>00369             std::cout &lt;&lt; <span class="stringliteral">&quot;Error: point index out of bounds.&quot;</span> &lt;&lt; std::endl;
<a name="l00370"></a>00370         pointTrackings[numPoint][numCamera] = -projection;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <span class="keywordflow">if</span> ( numProjection % fractionProjections == 0 )
<a name="l00373"></a>00373             std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL]\t&quot;</span> &lt;&lt; int(<span class="keywordtype">double</span>(100*numProjection) / <span class="keywordtype">double</span>(numProjections)) &lt;&lt; <span class="stringliteral">&quot;% loaded.&quot;</span> &lt;&lt; std::endl;
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     QHash&lt;int, int&gt; fileCameraIndexToRealCameraIndex;
<a name="l00377"></a>00377     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL] Reading &quot;</span> &lt;&lt; numCameras &lt;&lt; <span class="stringliteral">&quot; cameras&quot;</span> &lt;&lt; std::endl;
<a name="l00378"></a>00378     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> numCamera = 0; numCamera &lt; numCameras; numCamera++)
<a name="l00379"></a>00379         {
<a name="l00380"></a>00380         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> rodriguesRotation, cameraCenter;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00383"></a>00383             {
<a name="l00384"></a>00384             rodriguesRotation &lt;&lt; readVector(file)[0];
<a name="l00385"></a>00385             }
<a name="l00386"></a>00386         numline+=3;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00389"></a>00389             cameraCenter &lt;&lt; readVector(file)[0];
<a name="l00390"></a>00390         numline+=3;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         <span class="keyword">const</span> <span class="keywordtype">double</span>    focal = readVector(file)[0],    <span class="comment">// Focal.</span>
<a name="l00393"></a>00393                 k1 = readVector(file)[0],       <span class="comment">// First radial distortion parameter.</span>
<a name="l00394"></a>00394                 k2 = readVector(file)[0];       <span class="comment">// Second radial distortion parameter.</span>
<a name="l00395"></a>00395         Q_UNUSED(k1);
<a name="l00396"></a>00396         Q_UNUSED(k2);
<a name="l00397"></a>00397         numline+=3;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         <span class="comment">// Do not add camera if the focal distance is not reasonable.</span>
<a name="l00400"></a>00400         <span class="keywordflow">if</span> (ABS(focal) &lt; 1e-1)
<a name="l00401"></a>00401             {
<a name="l00402"></a>00402             std::cout &lt;&lt; <span class="stringliteral">&quot;******* SMALL FOCAL at line &quot;</span> &lt;&lt; numline &lt;&lt; <span class="stringliteral">&quot; for camera &quot;</span>&lt;&lt; numCamera &lt;&lt; <span class="stringliteral">&quot; !!! &quot;</span> &lt;&lt; focal &lt;&lt; std::endl;
<a name="l00403"></a>00403             <span class="keywordflow">continue</span>;
<a name="l00404"></a>00404             }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         <span class="keywordflow">if</span> (ABS( focal ) &gt; 1e+10)
<a name="l00407"></a>00407             {
<a name="l00408"></a>00408             std::cout &lt;&lt; <span class="stringliteral">&quot;******* LARGE FOCAL at line &quot;</span> &lt;&lt; numline &lt;&lt; <span class="stringliteral">&quot; for camera &quot;</span>&lt;&lt; numCamera &lt;&lt; <span class="stringliteral">&quot; !!! &quot;</span> &lt;&lt; focal &lt;&lt; std::endl;
<a name="l00409"></a>00409             <span class="keywordflow">continue</span>;
<a name="l00410"></a>00410             }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412         <span class="keyword">const</span> <span class="keywordtype">double</span> angle = rodriguesRotation.<a class="code" href="classQVVector.html#a49c6f41f1fa80efcc943f1c26fdcbf05" title="Norm 2 of the vector.">norm2</a>();
<a name="l00413"></a>00413         <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> rotationVector = rodriguesRotation / angle;
<a name="l00414"></a>00414         <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R = <a class="code" href="group__qvmath.html#gad9a79664f7af4487d5af8fe2296fc7a4" title="Obtains the rotation matrix corresponding to the element from the Lie algebra so(3)...">expSO3</a>(rotationVector * angle);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keyword">const</span> <a class="code" href="classQVQuaternion.html" title="Implementation of quaternions.">QVQuaternion</a> q(R);
<a name="l00417"></a>00417         <span class="keyword">const</span> <a class="code" href="classQVEuclideanMapping3.html" title="Class modeling rotation-translation transformations for 3D points.">QVEuclideanMapping3</a> cameraPose(q, cameraCenter);<span class="comment">//q.inverse().rotate(cameraCenter) * (-1.0) );</span>
<a name="l00418"></a>00418         <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> K = focal * <a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(3);
<a name="l00419"></a>00419         K(2,2) = 1.0;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421         <span class="comment">// -------------------------</span>
<a name="l00422"></a>00422         fileCameraIndexToRealCameraIndex[numCamera] = cameraPoses.count();
<a name="l00423"></a>00423         cameraCalibrations &lt;&lt; K;
<a name="l00424"></a>00424         cameraPoses &lt;&lt; cameraPose;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426         <span class="comment">//if (fileCameraIndexToRealCameraIndex[numCamera] &gt;= cameras.count())</span>
<a name="l00427"></a>00427         <span class="comment">//      std::cout &lt;&lt; &quot;*** ERROR iiiiiii !!!!!!!!! &quot; &lt;&lt; numCamera &lt;&lt; &quot;, &quot; &lt;&lt; cameras.count() &lt;&lt; std::endl;</span>
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         <span class="keywordflow">if</span> ( numCamera % fractionCameras == 0 )
<a name="l00430"></a>00430             std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL]\t&quot;</span> &lt;&lt; int(<span class="keywordtype">double</span>(100*numCamera) / <span class="keywordtype">double</span>(numCameras)) &lt;&lt; <span class="stringliteral">&quot;% loaded.&quot;</span> &lt;&lt; std::endl;
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">// Reorganize projections container, eliminating projections to not added cameras due to unreasonable focal distances,</span>
<a name="l00434"></a>00434     <span class="comment">// and adjusting camera indexes.</span>
<a name="l00435"></a>00435     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pointTrackings.size(); i++)
<a name="l00436"></a>00436         {
<a name="l00437"></a>00437         <span class="keyword">const</span> QHash&lt; int, QPointF&gt; &amp;oldCorrespondences = pointTrackings[i];
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         QHash&lt; int, QPointF&gt; newCorrespondences;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <span class="keywordflow">foreach</span>(<span class="keywordtype">int</span> numCamera, oldCorrespondences.keys())
<a name="l00442"></a>00442             <span class="keywordflow">if</span> (fileCameraIndexToRealCameraIndex.contains(numCamera))
<a name="l00443"></a>00443                 newCorrespondences[ fileCameraIndexToRealCameraIndex[ numCamera ] ] = oldCorrespondences[numCamera];
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         pointTrackings[i] = newCorrespondences;
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL] Reading &quot;</span> &lt;&lt; numPoints &lt;&lt; <span class="stringliteral">&quot; points&quot;</span> &lt;&lt; std::endl;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="comment">// Read points</span>
<a name="l00451"></a>00451     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> numPoint = 0; numPoint &lt; numPoints; numPoint++)
<a name="l00452"></a>00452         {
<a name="l00453"></a>00453         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> point;
<a name="l00454"></a>00454         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00455"></a>00455             point &lt;&lt; readVector(file)[0];
<a name="l00456"></a>00456         points3D &lt;&lt; point;
<a name="l00457"></a>00457         rgbColors &lt;&lt; QColor(128,128,128);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="keywordflow">if</span> ( numPoint % fractionPoints == 0 )
<a name="l00460"></a>00460             std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BAITL]\t&quot;</span> &lt;&lt; int(<span class="keywordtype">double</span>(100*numPoint) / <span class="keywordtype">double</span>(numPoints)) &lt;&lt; <span class="stringliteral">&quot;% loaded.&quot;</span> &lt;&lt; std::endl;
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] Readed &quot;</span>   &lt;&lt; numPoints &lt;&lt; <span class="stringliteral">&quot; points, &quot;</span> &lt;&lt; numCameras &lt;&lt; <span class="stringliteral">&quot; cameras.&quot;</span> &lt;&lt; std::endl;
<a name="l00464"></a>00464     file.close();
<a name="l00465"></a>00465     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="comment">/*bool readReconstruction_BundlerOutput(        const QString &amp;fileName,</span>
<a name="l00469"></a>00469 <span class="comment">                    QList&lt;QVMatrix&gt; &amp;cameraCalibrations,</span>
<a name="l00470"></a>00470 <span class="comment">                    QList&lt;QVVector&gt; &amp;cameraRadialParameters,</span>
<a name="l00471"></a>00471 <span class="comment">                    QList&lt;QVCameraPose&gt; &amp;cameraPoses,</span>
<a name="l00472"></a>00472 <span class="comment">                    QList&lt;QV3DPointF&gt; &amp;points3D,</span>
<a name="l00473"></a>00473 <span class="comment">                    QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointTrackings,</span>
<a name="l00474"></a>00474 <span class="comment">                    QList&lt; QColor &gt; &amp;rgbColors</span>
<a name="l00475"></a>00475 <span class="comment">                    )</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment">    {</span>
<a name="l00478"></a>00478 <span class="comment">    cameraCalibrations.clear();</span>
<a name="l00479"></a>00479 <span class="comment">    cameraRadialParameters.clear();</span>
<a name="l00480"></a>00480 <span class="comment">    cameraPoses.clear();</span>
<a name="l00481"></a>00481 <span class="comment">    points3D.clear();</span>
<a name="l00482"></a>00482 <span class="comment">    pointTrackings.clear();</span>
<a name="l00483"></a>00483 <span class="comment">    rgbColors.clear();</span>
<a name="l00484"></a>00484 <span class="comment"></span>
<a name="l00485"></a>00485 <span class="comment">    std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput] Opening file&quot; &lt;&lt; std::endl;</span>
<a name="l00486"></a>00486 <span class="comment">    QFile file(fileName);</span>
<a name="l00487"></a>00487 <span class="comment">    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))</span>
<a name="l00488"></a>00488 <span class="comment">        {</span>
<a name="l00489"></a>00489 <span class="comment">        std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput] Could not open file &#39;&quot; &lt;&lt; qPrintable(fileName) &lt;&lt; &quot;&#39;&quot; &lt;&lt; std::endl;</span>
<a name="l00490"></a>00490 <span class="comment">        return false;</span>
<a name="l00491"></a>00491 <span class="comment">        }</span>
<a name="l00492"></a>00492 <span class="comment"></span>
<a name="l00493"></a>00493 <span class="comment">    // Read header</span>
<a name="l00494"></a>00494 <span class="comment">    const QString line = file.readLine();</span>
<a name="l00495"></a>00495 <span class="comment">    if (not line.contains(&quot;# Bundle file v0.3&quot;))</span>
<a name="l00496"></a>00496 <span class="comment">        {</span>
<a name="l00497"></a>00497 <span class="comment">        std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput] The file does not seems to contain a valid Bulde 0.3 format.&quot; &lt;&lt; std::endl;</span>
<a name="l00498"></a>00498 <span class="comment">        file.close();</span>
<a name="l00499"></a>00499 <span class="comment">        return false;</span>
<a name="l00500"></a>00500 <span class="comment">        }</span>
<a name="l00501"></a>00501 <span class="comment"></span>
<a name="l00502"></a>00502 <span class="comment">    // Read number of cameras and points</span>
<a name="l00503"></a>00503 <span class="comment">    bool ok = false;</span>
<a name="l00504"></a>00504 <span class="comment">    int numCameras = -1, numPoints = -1;</span>
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment">    while (not ok and not file.atEnd())</span>
<a name="l00507"></a>00507 <span class="comment">        {</span>
<a name="l00508"></a>00508 <span class="comment">        const QString line = file.readLine();</span>
<a name="l00509"></a>00509 <span class="comment">        if (line.contains(&quot;#&quot;))</span>
<a name="l00510"></a>00510 <span class="comment">            continue;</span>
<a name="l00511"></a>00511 <span class="comment"></span>
<a name="l00512"></a>00512 <span class="comment">        const QStringList stringList = line.split (&quot; &quot;, QString::SkipEmptyParts);</span>
<a name="l00513"></a>00513 <span class="comment"></span>
<a name="l00514"></a>00514 <span class="comment">        numCameras = stringList[0].toInt(&amp;ok);</span>
<a name="l00515"></a>00515 <span class="comment">        numPoints = stringList[1].toInt(&amp;ok);</span>
<a name="l00516"></a>00516 <span class="comment">        }</span>
<a name="l00517"></a>00517 <span class="comment"></span>
<a name="l00518"></a>00518 <span class="comment">    const int fractionCameras = numCameras / 7, fractionPoints = numPoints / 7;</span>
<a name="l00519"></a>00519 <span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">    std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput] Reading cameras.&quot; &lt;&lt; std::endl;</span>
<a name="l00521"></a>00521 <span class="comment">    // Read cameras</span>
<a name="l00522"></a>00522 <span class="comment">    int numCamera, numPoint, numProjections = 0;</span>
<a name="l00523"></a>00523 <span class="comment">    QHash&lt;int, int&gt; virtualCameraIndexToRealCameraIndex;</span>
<a name="l00524"></a>00524 <span class="comment">    for(numCamera = 0; numCamera &lt; numCameras and not file.atEnd(); numCamera++)</span>
<a name="l00525"></a>00525 <span class="comment">        {</span>
<a name="l00526"></a>00526 <span class="comment">        const QVVector intrinsics = readVector(file);</span>
<a name="l00527"></a>00527 <span class="comment"></span>
<a name="l00528"></a>00528 <span class="comment">        QList&lt;QVVector&gt; Rlist;</span>
<a name="l00529"></a>00529 <span class="comment">        Rlist &lt;&lt; readVector(file);</span>
<a name="l00530"></a>00530 <span class="comment">        Rlist &lt;&lt; readVector(file);</span>
<a name="l00531"></a>00531 <span class="comment">        Rlist &lt;&lt; readVector(file);</span>
<a name="l00532"></a>00532 <span class="comment"></span>
<a name="l00533"></a>00533 <span class="comment">        const QVMatrix R(Rlist);</span>
<a name="l00534"></a>00534 <span class="comment">        const QVQuaternion q(R);</span>
<a name="l00535"></a>00535 <span class="comment"></span>
<a name="l00536"></a>00536 <span class="comment">        const QVVector t = readVector(file);</span>
<a name="l00537"></a>00537 <span class="comment">        const QVEuclideanMapping3 cameraPose(q, t);</span>
<a name="l00538"></a>00538 <span class="comment">        QVMatrix K = intrinsics[0]*QVMatrix::identity(3);</span>
<a name="l00539"></a>00539 <span class="comment">        K(2,2) = 1.0;</span>
<a name="l00540"></a>00540 <span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment">        if (t != QV3DPointF(0.0, 0.0, 0.0))</span>
<a name="l00542"></a>00542 <span class="comment">            {</span>
<a name="l00543"></a>00543 <span class="comment">            virtualCameraIndexToRealCameraIndex[numCamera] = cameraPoses.count();</span>
<a name="l00544"></a>00544 <span class="comment">            cameraCalibrations &lt;&lt; K;</span>
<a name="l00545"></a>00545 <span class="comment">            cameraPoses &lt;&lt; cameraPose;</span>
<a name="l00546"></a>00546 <span class="comment">            cameraRadialParameters &lt;&lt; intrinsics.mid(1);</span>
<a name="l00547"></a>00547 <span class="comment">            }</span>
<a name="l00548"></a>00548 <span class="comment">        if ( numCamera % fractionCameras == 0 )</span>
<a name="l00549"></a>00549 <span class="comment">            std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput]\t&quot; &lt;&lt; int(double(100*numCamera) / double(numCameras)) &lt;&lt; &quot;% loaded.&quot; &lt;&lt; std::endl;</span>
<a name="l00550"></a>00550 <span class="comment">        }</span>
<a name="l00551"></a>00551 <span class="comment"></span>
<a name="l00552"></a>00552 <span class="comment">    std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput] Reading points&quot; &lt;&lt; std::endl;</span>
<a name="l00553"></a>00553 <span class="comment">    // Read points</span>
<a name="l00554"></a>00554 <span class="comment">    for(numPoint = 0, numProjections = 0; numPoint &lt; numPoints and not file.atEnd(); numPoint++)</span>
<a name="l00555"></a>00555 <span class="comment">        {</span>
<a name="l00556"></a>00556 <span class="comment">        const QVVector  position = readVector(file),</span>
<a name="l00557"></a>00557 <span class="comment">                color = readVector(file),</span>
<a name="l00558"></a>00558 <span class="comment">                viewList = readVector(file);</span>
<a name="l00559"></a>00559 <span class="comment"></span>
<a name="l00560"></a>00560 <span class="comment">        points3D &lt;&lt; position;</span>
<a name="l00561"></a>00561 <span class="comment">        rgbColors &lt;&lt; QColor(int(color[0]), int(color[1]),int(color[2]));</span>
<a name="l00562"></a>00562 <span class="comment"></span>
<a name="l00563"></a>00563 <span class="comment">        if (viewList[0] != (viewList.count() -1) / 4)</span>
<a name="l00564"></a>00564 <span class="comment">            std::cout &lt;&lt; &quot;Error: in point projections list.&quot; &lt;&lt; std::endl;</span>
<a name="l00565"></a>00565 <span class="comment">        else    {</span>
<a name="l00566"></a>00566 <span class="comment">            QHash&lt; int, QPointF&gt; projections;</span>
<a name="l00567"></a>00567 <span class="comment">            for (int i = 1; i &lt; viewList.count(); i+=4)</span>
<a name="l00568"></a>00568 <span class="comment">                {</span>
<a name="l00569"></a>00569 <span class="comment">                const int numCamera = viewList[i];</span>
<a name="l00570"></a>00570 <span class="comment">                const double coorX = viewList[i+2], coorY =  viewList[i+3];</span>
<a name="l00571"></a>00571 <span class="comment">                if (numCamera +1 &gt; numCameras or numCamera &lt; 0)</span>
<a name="l00572"></a>00572 <span class="comment">                    std::cout &lt;&lt; &quot;Error: camera index out of bounds.&quot; &lt;&lt; std::endl;</span>
<a name="l00573"></a>00573 <span class="comment">                if (virtualCameraIndexToRealCameraIndex.contains( numCamera ))</span>
<a name="l00574"></a>00574 <span class="comment">                    projections[ virtualCameraIndexToRealCameraIndex[ numCamera ] ] = -QPointF( coorX, coorY );</span>
<a name="l00575"></a>00575 <span class="comment">                else</span>
<a name="l00576"></a>00576 <span class="comment">                    std::cout &lt;&lt; &quot;Error: found point projection for uninitialized camera pose.&quot; &lt;&lt; std::endl;</span>
<a name="l00577"></a>00577 <span class="comment">                }</span>
<a name="l00578"></a>00578 <span class="comment">            pointTrackings &lt;&lt; projections;</span>
<a name="l00579"></a>00579 <span class="comment">            numProjections += projections.count();</span>
<a name="l00580"></a>00580 <span class="comment">            }</span>
<a name="l00581"></a>00581 <span class="comment">        if ( numPoint % fractionPoints == 0 )</span>
<a name="l00582"></a>00582 <span class="comment">            std::cout &lt;&lt; &quot;[readReconstruction_BundlerOutput]\t&quot; &lt;&lt; int(double(100*numPoint) / double(numPoints)) &lt;&lt; &quot;% loaded.&quot; &lt;&lt; std::endl;</span>
<a name="l00583"></a>00583 <span class="comment">        }</span>
<a name="l00584"></a>00584 <span class="comment"></span>
<a name="l00585"></a>00585 <span class="comment">    file.close();</span>
<a name="l00586"></a>00586 <span class="comment">    return true;</span>
<a name="l00587"></a>00587 <span class="comment">    }*/</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keywordtype">bool</span> readReconstruction_BundlerOutput(  <span class="keyword">const</span> QString &amp;fileName,
<a name="l00590"></a>00590                     QList&lt;QVMatrix&gt; &amp;cameraCalibrations,
<a name="l00591"></a>00591                     QList&lt;QVVector&gt; &amp;cameraRadialParameters,
<a name="l00592"></a>00592                     QList&lt;QVCameraPose&gt; &amp;cameraPoses,
<a name="l00593"></a>00593                     QList&lt;QV3DPointF&gt; &amp;points3D,
<a name="l00594"></a>00594                     QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointTrackings,
<a name="l00595"></a>00595                     QList&lt; QColor &gt; &amp;rgbColors
<a name="l00596"></a>00596                     )
<a name="l00597"></a>00597 
<a name="l00598"></a>00598     {
<a name="l00599"></a>00599     cameraCalibrations.clear();
<a name="l00600"></a>00600     cameraRadialParameters.clear();
<a name="l00601"></a>00601     cameraPoses.clear();
<a name="l00602"></a>00602     points3D.clear();
<a name="l00603"></a>00603     pointTrackings.clear();
<a name="l00604"></a>00604     rgbColors.clear();
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] Opening file&quot;</span> &lt;&lt; std::endl;
<a name="l00607"></a>00607     QFile file(fileName);
<a name="l00608"></a>00608     <span class="keywordflow">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00609"></a>00609         {
<a name="l00610"></a>00610         std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] Could not open file &#39;&quot;</span> &lt;&lt; qPrintable(fileName) &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00611"></a>00611         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00612"></a>00612         }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614     <span class="comment">// Read header</span>
<a name="l00615"></a>00615     <span class="keyword">const</span> QString line = file.readLine();
<a name="l00616"></a>00616     <span class="keywordflow">if</span> (not line.contains(<span class="stringliteral">&quot;# Bundle file v0.3&quot;</span>))
<a name="l00617"></a>00617         {
<a name="l00618"></a>00618         std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] The file does not seems to contain a valid Bulde 0.3 format.&quot;</span> &lt;&lt; std::endl;
<a name="l00619"></a>00619         file.close();
<a name="l00620"></a>00620         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     <span class="comment">// Read number of cameras and points</span>
<a name="l00624"></a>00624     <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00625"></a>00625     <span class="keywordtype">int</span> numCameras = -1, numPoints = -1;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     <span class="keywordflow">while</span> (not ok and not file.atEnd())
<a name="l00628"></a>00628         {
<a name="l00629"></a>00629         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00631"></a>00631             <span class="keywordflow">continue</span>;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="keyword">const</span> QStringList stringList = line.split (<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         numCameras = stringList[0].toInt(&amp;ok);
<a name="l00636"></a>00636         numPoints = stringList[1].toInt(&amp;ok);
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="keyword">const</span> <span class="keywordtype">int</span> fractionCameras = numCameras / 7, fractionPoints = numPoints / 7;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] Reading &quot;</span> &lt;&lt; numCameras &lt;&lt; <span class="stringliteral">&quot; cameras.&quot;</span> &lt;&lt; std::endl;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643     <span class="comment">// Read cameras</span>
<a name="l00644"></a>00644     <span class="keywordtype">int</span> numCamera, numPoint, numProjections = 0;
<a name="l00645"></a>00645     QHash&lt;int, int&gt; virtualCameraIndexToRealCameraIndex;
<a name="l00646"></a>00646     <span class="keywordflow">for</span>(numCamera = 0; numCamera &lt; numCameras and not file.atEnd(); numCamera++)
<a name="l00647"></a>00647         {
<a name="l00648"></a>00648         <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> intrinsics = readVector(file);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         QList&lt;QVVector&gt; Rlist;
<a name="l00651"></a>00651         Rlist &lt;&lt; readVector(file);
<a name="l00652"></a>00652         Rlist &lt;&lt; readVector(file);
<a name="l00653"></a>00653         Rlist &lt;&lt; readVector(file);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> R(Rlist);
<a name="l00656"></a>00656         <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> t = readVector(file);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658         <span class="keywordflow">if</span> ( numCamera % fractionCameras == 0 )
<a name="l00659"></a>00659             std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput]\t&quot;</span> &lt;&lt; int(<span class="keywordtype">double</span>(100*numCamera) / <span class="keywordtype">double</span>(numCameras)) &lt;&lt; <span class="stringliteral">&quot;% loaded.&quot;</span> &lt;&lt; std::endl;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661                 <span class="keywordflow">if</span> (R.<a class="code" href="classQVMatrix.html#a387750529622104faba8047cb0efa62a" title="Gets the norm2 for matrix.">norm2</a>() == 0)
<a name="l00662"></a>00662                         <span class="keywordflow">continue</span>;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664                 Q_ASSERT( (<a class="code" href="classQVMatrix.html#a6eb15980d17c17d4a55ab09a77bcd715" title="Creates an identity matrix.">QVMatrix::identity</a>(3)-R.<a class="code" href="classQVMatrix.html#a2f87710c9d8ae4b07b03605daea3782e" title="Change the order of the indexes in the matrix.">transpose</a>()* R).norm2() &lt; 1e-6 );
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (t != <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a>(0.0, 0.0, 0.0))
<a name="l00667"></a>00667             {
<a name="l00668"></a>00668             virtualCameraIndexToRealCameraIndex[numCamera] = cameraPoses.count();
<a name="l00669"></a>00669             cameraCalibrations &lt;&lt; <a class="code" href="classQVMatrix.html#a953207e797ad5c2f8477d3507dbcf86b" title="Creates an intrinsic camera calibration matrix.">QVMatrix::cameraCalibrationMatrix</a>(intrinsics[0]);
<a name="l00670"></a>00670             cameraPoses &lt;&lt; <a class="code" href="classQVEuclideanMapping3.html" title="Class modeling rotation-translation transformations for 3D points.">QVEuclideanMapping3</a>(R | t);
<a name="l00671"></a>00671             cameraRadialParameters &lt;&lt; intrinsics.mid(1);
<a name="l00672"></a>00672             }
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput] Reading points&quot;</span> &lt;&lt; std::endl;
<a name="l00676"></a>00676     <span class="comment">// Read points</span>
<a name="l00677"></a>00677     <span class="keywordflow">for</span>(numPoint = 0, numProjections = 0; numPoint &lt; numPoints and not file.atEnd(); numPoint++)
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679         <span class="keyword">const</span> <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a>  position = readVector(file),
<a name="l00680"></a>00680                 color = readVector(file),
<a name="l00681"></a>00681                 viewList = readVector(file);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         points3D &lt;&lt; position;
<a name="l00684"></a>00684         rgbColors &lt;&lt; QColor(<span class="keywordtype">int</span>(color[0]), <span class="keywordtype">int</span>(color[1]),<span class="keywordtype">int</span>(color[2]));
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="keywordflow">if</span> (viewList[0] != (viewList.count() -1) / 4)
<a name="l00687"></a>00687             std::cout &lt;&lt; <span class="stringliteral">&quot;Error: in point projections list.&quot;</span> &lt;&lt; std::endl;
<a name="l00688"></a>00688         <span class="keywordflow">else</span>    {
<a name="l00689"></a>00689             QHash&lt; int, QPointF&gt; projections;
<a name="l00690"></a>00690             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; viewList.count(); i+=4)
<a name="l00691"></a>00691                 {
<a name="l00692"></a>00692                 <span class="keyword">const</span> <span class="keywordtype">int</span> numCamera = viewList[i];
<a name="l00693"></a>00693                 <span class="keyword">const</span> <span class="keywordtype">double</span> coorX = viewList[i+2], coorY =  viewList[i+3];
<a name="l00694"></a>00694                 <span class="keywordflow">if</span> (numCamera +1 &gt; numCameras or numCamera &lt; 0)
<a name="l00695"></a>00695                     std::cout &lt;&lt; <span class="stringliteral">&quot;Error: camera index out of bounds.&quot;</span> &lt;&lt; std::endl;
<a name="l00696"></a>00696                 <span class="keywordflow">if</span> (virtualCameraIndexToRealCameraIndex.contains( numCamera ))
<a name="l00697"></a>00697                     projections[ virtualCameraIndexToRealCameraIndex[ numCamera ] ] = -QPointF( coorX, coorY );
<a name="l00698"></a>00698                 <span class="keywordflow">else</span>
<a name="l00699"></a>00699                     std::cout &lt;&lt; <span class="stringliteral">&quot;Error: found point projection for uninitialized camera pose.&quot;</span> &lt;&lt; std::endl;
<a name="l00700"></a>00700                 }
<a name="l00701"></a>00701             pointTrackings &lt;&lt; projections;
<a name="l00702"></a>00702             numProjections += projections.count();
<a name="l00703"></a>00703             }
<a name="l00704"></a>00704         <span class="keywordflow">if</span> ( numPoint % fractionPoints == 0 )
<a name="l00705"></a>00705             std::cout &lt;&lt; <span class="stringliteral">&quot;[readReconstruction_BundlerOutput]\t&quot;</span> &lt;&lt; int(<span class="keywordtype">double</span>(100*numPoint) / <span class="keywordtype">double</span>(numPoints)) &lt;&lt; <span class="stringliteral">&quot;% loaded.&quot;</span> &lt;&lt; std::endl;
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     file.close();
<a name="l00709"></a>00709     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00710"></a>00710     }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="keywordtype">bool</span> readCameras_laSBA(<span class="keyword">const</span> QString fileName, QList&lt;QVCameraPose&gt; &amp;cameraPoses)
<a name="l00713"></a>00713     {
<a name="l00714"></a>00714     QFile file(fileName);
<a name="l00715"></a>00715     <span class="keywordflow">if</span> (not file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00716"></a>00716         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="keywordflow">while</span> (not file.atEnd())
<a name="l00719"></a>00719         {
<a name="l00720"></a>00720         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00721"></a>00721         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00722"></a>00722             <span class="keywordflow">continue</span>;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="keyword">const</span> QStringList stringList = line.split (<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> v;
<a name="l00727"></a>00727         <span class="keywordflow">foreach</span>(QString <span class="keywordtype">string</span>, stringList)
<a name="l00728"></a>00728             {
<a name="l00729"></a>00729             <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00730"></a>00730             <span class="keyword">const</span> <span class="keywordtype">double</span> value = <span class="keywordtype">string</span>.toDouble(&amp;ok);
<a name="l00731"></a>00731             <span class="keywordflow">if</span> (ok)
<a name="l00732"></a>00732                 v &lt;&lt; value;
<a name="l00733"></a>00733             }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="keyword">const</span> <a class="code" href="classQVQuaternion.html" title="Implementation of quaternions.">QVQuaternion</a> q(v[1], v[2], v[3], v[0]);
<a name="l00736"></a>00736         <span class="keyword">const</span> <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> t(v[4], v[5], v[6]);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         cameraPoses &lt;&lt; <a class="code" href="classQVEuclideanMapping3.html" title="Class modeling rotation-translation transformations for 3D points.">QVEuclideanMapping3</a>(q, t);
<a name="l00739"></a>00739         }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="keywordtype">bool</span> readPoints_laSBA(<span class="keyword">const</span> QString fileName, QList&lt;QV3DPointF&gt; &amp;points3D, QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointTrackings)
<a name="l00745"></a>00745     {
<a name="l00746"></a>00746     QFile file(fileName);
<a name="l00747"></a>00747     <span class="keywordflow">if</span> (not file.open(QIODevice::ReadOnly | QIODevice::Text))
<a name="l00748"></a>00748         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750     <span class="keywordflow">while</span> (not file.atEnd())
<a name="l00751"></a>00751         {
<a name="l00752"></a>00752         <span class="keyword">const</span> QString line = file.readLine();
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         <span class="keywordflow">if</span> (line.contains(<span class="stringliteral">&quot;#&quot;</span>))
<a name="l00755"></a>00755             <span class="keywordflow">continue</span>;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="keyword">const</span> QStringList stringList = line.split (<span class="stringliteral">&quot; &quot;</span>, QString::SkipEmptyParts);
<a name="l00758"></a>00758         <a class="code" href="classQVVector.html" title="Implementation of numerical vectors.">QVVector</a> v;
<a name="l00759"></a>00759         <span class="keywordflow">foreach</span>(QString <span class="keywordtype">string</span>, stringList)
<a name="l00760"></a>00760             {
<a name="l00761"></a>00761             <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00762"></a>00762             <span class="keyword">const</span> <span class="keywordtype">double</span> value = <span class="keywordtype">string</span>.toDouble(&amp;ok);
<a name="l00763"></a>00763             <span class="keywordflow">if</span> (ok)
<a name="l00764"></a>00764                 v &lt;&lt; value;
<a name="l00765"></a>00765             }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767         <span class="keyword">const</span> <a class="code" href="classQV3DPointF.html" title="3D point representation">QV3DPointF</a> t(v[0], v[1], v[2]);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769         QHash&lt;int, QPointF&gt; projections;
<a name="l00770"></a>00770         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 4; i &lt; v.size(); i+=3)
<a name="l00771"></a>00771             projections[ v[i] ] = QPointF(v[i+1], v[i+2]);
<a name="l00772"></a>00772         pointTrackings &lt;&lt; projections;
<a name="l00773"></a>00773         points3D &lt;&lt; t;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keywordtype">bool</span> readSfMReconstruction_laSBA(       <span class="keyword">const</span> QString &amp;filesPath,
<a name="l00780"></a>00780                     QList&lt;QVMatrix&gt; &amp;cameraCalibrations,
<a name="l00781"></a>00781                     QList&lt;QVCameraPose&gt; &amp;cameraPoses,
<a name="l00782"></a>00782                     QList&lt;QV3DPointF&gt; &amp;points3D,
<a name="l00783"></a>00783                     QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointTrackings
<a name="l00784"></a>00784                     )
<a name="l00785"></a>00785     {
<a name="l00786"></a>00786     cameraCalibrations.clear();
<a name="l00787"></a>00787     cameraPoses.clear();
<a name="l00788"></a>00788     points3D.clear();
<a name="l00789"></a>00789     pointTrackings.clear();
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> Ks = readMatrix(filesPath + <span class="stringliteral">&quot;/calib.txt&quot;</span>);
<a name="l00792"></a>00792         Q_ASSERT(Ks.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() == 3);
<a name="l00793"></a>00793         Q_ASSERT(Ks.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>() == 3);
<a name="l00794"></a>00794 
<a name="l00795"></a>00795     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Ks.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(); i+=3)
<a name="l00796"></a>00796         cameraCalibrations &lt;&lt; Ks.<a class="code" href="classQVMatrix.html#a77b34335086bb9e12d7d72398c608e75" title="Gets a submatrix from a matrix.">getSubmatrix</a>(i, i+2, 0, 2);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="keywordflow">if</span> (not readCameras_laSBA(filesPath + <span class="stringliteral">&quot;/cams.txt&quot;</span>, cameraPoses))
<a name="l00799"></a>00799         {
<a name="l00800"></a>00800         std::cout &lt;&lt; <span class="stringliteral">&quot;[readSfMReconstruction_laSBA] Error: could not read file &quot;</span> &lt;&lt; qPrintable(filesPath + <span class="stringliteral">&quot;/cams.txt&quot;</span>) &lt;&lt; std::endl;
<a name="l00801"></a>00801         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00802"></a>00802         }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     <span class="keywordflow">if</span> (not readPoints_laSBA(filesPath + <span class="stringliteral">&quot;/pts.txt&quot;</span>, points3D, pointTrackings))
<a name="l00805"></a>00805         {
<a name="l00806"></a>00806         std::cout &lt;&lt; <span class="stringliteral">&quot;[readSfMReconstruction_laSBA] Error: could not read file &quot;</span> &lt;&lt; qPrintable(filesPath + <span class="stringliteral">&quot;/pts.txt&quot;</span>) &lt;&lt; std::endl;
<a name="l00807"></a>00807         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         Q_ASSERT_X( (cameraCalibrations.count() == 1) or (cameraCalibrations.count() == cameraPoses.count()), <span class="stringliteral">&quot;[readSfMReconstruction_laSBA]&quot;</span>, <span class="stringliteral">&quot;Error reading calibrations from file: incorrect number.&quot;</span>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 <span class="preprocessor">#include &lt;QFileInfo&gt;</span>
<a name="l00816"></a><a class="code" href="group__qvsfm.html#ga934b4f0190cd3442f11b875608941829">00816</a> <span class="keywordtype">bool</span> <a class="code" href="group__qvsfm.html#ga934b4f0190cd3442f11b875608941829" title="Loads a SfM reconstruction from a file or files. This function loads a SfM reconstruction...">readSfMReconstruction</a>(     <span class="keyword">const</span> QString &amp;path,
<a name="l00817"></a>00817                 QList&lt;QVMatrix&gt; &amp;cameraCalibrations,
<a name="l00818"></a>00818                 QList&lt;QVCameraPose&gt; &amp;initialCameraPoses,
<a name="l00819"></a>00819                 QList&lt;QV3DPointF&gt; &amp;filePoints3D,
<a name="l00820"></a>00820                 QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointsProjections
<a name="l00821"></a>00821                 )
<a name="l00822"></a>00822     {
<a name="l00823"></a>00823     <span class="keyword">const</span> QFileInfo info(path);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825     <span class="keywordflow">if</span> (not info.exists())
<a name="l00826"></a>00826         {
<a name="l00827"></a>00827         std::cout &lt;&lt; <span class="stringliteral">&quot;[readSfMReconstruction] Error: specified path &#39;&quot;</span> &lt;&lt; qPrintable(path) &lt;&lt; <span class="stringliteral">&quot;&#39; does not exists.&quot;</span> &lt;&lt; std::endl;
<a name="l00828"></a>00828         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00829"></a>00829         }
<a name="l00830"></a>00830     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info.isDir())
<a name="l00831"></a>00831         {
<a name="l00832"></a>00832         <span class="keywordflow">if</span> (not readSfMReconstruction_laSBA(path, cameraCalibrations, initialCameraPoses, filePoints3D, pointsProjections))
<a name="l00833"></a>00833             {
<a name="l00834"></a>00834             std::cout &lt;&lt; <span class="stringliteral">&quot;[readSfMReconstruction] Specified path is a directory, but one of the files is missing: &#39;calib.txt&#39;, &#39;pts.txt&#39; or &#39;cams.txt&#39;.&quot;</span> &lt;&lt; std::endl;
<a name="l00835"></a>00835             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00836"></a>00836             }
<a name="l00837"></a>00837         }
<a name="l00838"></a>00838     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info.isFile())
<a name="l00839"></a>00839         {
<a name="l00840"></a>00840         QList&lt; QColor &gt; rgbColors;
<a name="l00841"></a>00841         QList&lt;QVVector&gt; cameraRadialParameters;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         <span class="keywordflow">if</span> ( not readReconstruction_BundlerOutput(path, cameraCalibrations, cameraRadialParameters, initialCameraPoses, filePoints3D, pointsProjections, rgbColors) )
<a name="l00844"></a>00844             <span class="comment">// Try with a &quot;Bundle Adjustment in the Large&quot; dataset type.</span>
<a name="l00845"></a>00845             <span class="keywordflow">if</span> ( not readReconstruction_BAITL(path, cameraCalibrations, initialCameraPoses, filePoints3D, rgbColors, pointsProjections) )
<a name="l00846"></a>00846                 {
<a name="l00847"></a>00847                 std::cout &lt;&lt; <span class="stringliteral">&quot;[readSfMReconstruction] Could not load reconstruction from specified file.&quot;</span> &lt;&lt; std::endl;
<a name="l00848"></a>00848                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00849"></a>00849                 }
<a name="l00850"></a>00850         }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="comment">// ----------------------</span>
<a name="l00856"></a>00856 <span class="preprocessor">#include &lt;QTextStream&gt;</span>
<a name="l00857"></a>00857 <span class="keywordtype">bool</span> saveMatrix(<span class="keyword">const</span> QString fileName, <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> &amp;matrix)
<a name="l00858"></a>00858         {
<a name="l00859"></a>00859         QFile file(fileName);
<a name="l00860"></a>00860         <span class="keywordflow">if</span> (not file.open(QIODevice::WriteOnly | QIODevice::Text))
<a name="l00861"></a>00861                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00862"></a>00862 
<a name="l00863"></a>00863         QTextStream stream(&amp;file);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         stream.setRealNumberPrecision(16); <span class="comment">// Default is 6, not enough precission to faithfully store certain maps.</span>
<a name="l00866"></a>00866 
<a name="l00867"></a>00867         <span class="keyword">const</span> <span class="keywordtype">double</span> *data = matrix.<a class="code" href="classQVMatrix.html#a50de15cc657c8a1d9fcc749161192a64" title="Gets a read-only reference to the data buffer of the matrix.">getReadData</a>();
<a name="l00868"></a>00868         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; matrix.<a class="code" href="classQVMatrix.html#a4108aa685baecab8a9822dcc04e98b7f" title="Get height of the matrix.">getRows</a>(); i++)
<a name="l00869"></a>00869                 {
<a name="l00870"></a>00870                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; matrix.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>(); j++)
<a name="l00871"></a>00871                         stream &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(data[i*matrix.<a class="code" href="classQVMatrix.html#a420bba03aeccbd18161418049a025f66" title="Get width of the matrix.">getCols</a>() + j], -8, <span class="charliteral">&#39;f&#39;</span>, 6)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00872"></a>00872                 stream &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00873"></a>00873                 }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         file.close();
<a name="l00876"></a>00876         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00877"></a>00877         }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 <span class="keywordtype">void</span> writeCameras_laSBA(<span class="keyword">const</span> QString &amp;fileName, <span class="keyword">const</span> QList&lt;QVCameraPose&gt; &amp;cameraPoses)
<a name="l00880"></a>00880         {
<a name="l00881"></a>00881         QList&lt;QVVector&gt; cameraVectors;
<a name="l00882"></a>00882         <span class="keywordflow">foreach</span>(<a class="code" href="classQVCameraPose.html" title="Class for the camera pose of a view, in a 3D reconstruction.">QVCameraPose</a> cameraPose, cameraPoses)
<a name="l00883"></a>00883                 cameraVectors &lt;&lt; cameraPose.operator <a class="code" href="classQVEuclideanMapping3.html" title="Class modeling rotation-translation transformations for 3D points.">QVEuclideanMapping3</a>();
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> cameraPosesMatrixPre(cameraVectors);
<a name="l00886"></a>00886         <span class="keyword">const</span> <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a> cameraPosesMatrix = <a class="code" href="classQVMatrix.html" title="Implementation of numerical matrices.">QVMatrix</a>(cameraPosesMatrixPre.getCol(3)).transpose()
<a name="l00887"></a>00887                                                                                 | cameraPosesMatrixPre.getCol(0)
<a name="l00888"></a>00888                                                                                 | cameraPosesMatrixPre.getCol(1)
<a name="l00889"></a>00889                                                                                 | cameraPosesMatrixPre.getCol(2)
<a name="l00890"></a>00890                                                                                 | cameraPosesMatrixPre.getCol(4)
<a name="l00891"></a>00891                                                                                 | cameraPosesMatrixPre.getCol(5)
<a name="l00892"></a>00892                                                                                 | cameraPosesMatrixPre.getCol(6);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         saveMatrix(fileName, cameraPosesMatrix);
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00898"></a>00898 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00899"></a>00899 <span class="keywordtype">void</span> writePoints_laSBA(<span class="keyword">const</span> QString fileName, <span class="keyword">const</span> QList&lt;QV3DPointF&gt; &amp;points3D, <span class="keyword">const</span> QList&lt;QHash&lt;int, QPointF&gt; &gt; &amp;pointTrackings)
<a name="l00900"></a>00900         {
<a name="l00901"></a>00901         QFile file(fileName);
<a name="l00902"></a>00902         <span class="keywordflow">if</span> (not file.open(QIODevice::WriteOnly | QIODevice::Text))
<a name="l00903"></a>00903                 <span class="keywordflow">return</span>;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905         QTextStream stream(&amp;file);
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         stream.setRealNumberPrecision(16); <span class="comment">// Default is 6, not enough precission to faithfully store certain maps.</span>
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; points3D.size(); i++)
<a name="l00910"></a>00910                 {
<a name="l00911"></a>00911                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; points3D[i].size(); j++)
<a name="l00912"></a>00912                         stream &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(points3D[i][j], -8, <span class="charliteral">&#39;f&#39;</span>, 6)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00913"></a>00913                 stream &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(pointTrackings[i].count(), -8)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00914"></a>00914                 <span class="keywordflow">foreach</span>(<span class="keywordtype">int</span> index, pointTrackings[i].keys())
<a name="l00915"></a>00915                         stream  &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(index, -8)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l00916"></a>00916                                         &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(pointTrackings[i][index].x(), -8, <span class="charliteral">&#39;f&#39;</span>, 6)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l00917"></a>00917                                         &lt;&lt; qPrintable(QString(<span class="stringliteral">&quot;%1&quot;</span>).arg(pointTrackings[i][index].y(), -8, <span class="charliteral">&#39;f&#39;</span>, 6)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00918"></a>00918                 stream &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00919"></a>00919                 }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921         file.close();
<a name="l00922"></a>00922         }
<a name="l00923"></a>00923 
</pre></div></div>
</td></tr></table>

<br /><hr><br />
<center><a href="http://perception.inf.um.es/QVision">QVision framework</a>.
<a href="http://perception.inf.um.es">PARP research group</a>.
Copyright &copy; 2007, 2008, 2009, 2010, 2011.</center>
<br />
</body>
</html>
